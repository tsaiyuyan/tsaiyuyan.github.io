{"meta":{"title":"YuYan's blog","subtitle":"Death outside the ring is slow and painful, perhaps we should all remain there.(空気を読んだ雨降らないでよ)","description":"記錄一些工作經驗、知識，或轉錄一些好文章，避免日後忘記。","author":"YuYan","url":"https://tsaiyuyan.github.io","root":"/"},"pages":[{"title":"about","date":"2019-03-19T08:55:30.000Z","updated":"2020-05-11T07:35:19.294Z","comments":true,"path":"about/index.html","permalink":"https://tsaiyuyan.github.io/about/index.html","excerpt":"","text":""},{"title":"friends","date":"2019-03-19T08:55:58.000Z","updated":"2020-05-11T07:35:19.299Z","comments":true,"path":"friends/index.html","permalink":"https://tsaiyuyan.github.io/friends/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-03-19T08:54:13.000Z","updated":"2020-05-11T07:35:19.297Z","comments":true,"path":"categories/index.html","permalink":"https://tsaiyuyan.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-03-19T08:54:52.000Z","updated":"2020-05-11T07:35:21.417Z","comments":true,"path":"tags/index.html","permalink":"https://tsaiyuyan.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Openssl - 快速產生重要檔案","slug":"Openssl - 快速產生重要檔案","date":"2023-05-30T02:00:00.000Z","updated":"2023-06-02T07:04:43.009Z","comments":true,"path":"2023/05/30/openssl-kuai-su-chan-sheng-chong-yao-dang-an/","link":"","permalink":"https://tsaiyuyan.github.io/2023/05/30/openssl-kuai-su-chan-sheng-chong-yao-dang-an/","excerpt":"","text":"rootca.conf[ req ] default_bits = 2048 default_keyfile = rootkeyfile.pem distinguished_name = req_distinguished_name attributes = req_attributes prompt = no output_password = mypass [ req_distinguished_name ] C = TW ST = Test State or Province L = taipei O = adv OU = rd CN = rootca emailAddress = test@email.address [ req_attributes ] challengePassword = server.conf[ req ] default_bits = 2048 default_keyfile = rootkeyfile.pem distinguished_name = req_distinguished_name attributes = req_attributes prompt = no output_password = mypass [ req_distinguished_name ] C = TW ST = Test State or Province L = taipei O = adv OU = rd CN = server emailAddress = test@email.address [ req_attributes ] challengePassword = password create.sh#!/bin/bash echo \"create rootCA.key............\" openssl dsaparam -genkey -out rootCA.key 1024 echo \"create rootCA.pem............\" openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.pem -config rootca.conf echo \"create dh1024.pem............\" openssl dhparam -out dh1024.pem 1024 echo \"create server.key............\" openssl ecparam -name prime256v1 -out s_prime256v1.pem openssl ecparam -in s_prime256v1.pem -genkey -noout -out server.key echo \"create server_pub.pem............\" openssl ec -in server.key -pubout -out server_pub.pem echo \"create serverdsa.pem............\" openssl dsaparam -genkey -out serverdsa.pem 1024 echo \"create server.csr............\" openssl req -new -key serverdsa.pem -out server.csr -config server.conf echo \"create server_cert.pem............\" openssl x509 -req -in server.csr -CAkey ./rootCA.key -CA ./rootCA.pem -force_pubkey server_pub.pem -out server_cert.pem -CAcreateserial echo \"convert to server.pem.....\" cat server_cert.pem server.key > server.pem echo \"clear files......\" rm -f rootCA.key rootCA.srl s_prime256v1.pem server.csr server.key server_cert.pem server_pub.pem serverdsa.pem echo \"rootCA.pem server.pem dh1024.pem is needy.\" delete.sh#!/bin/bash rm -f *.csr *.key *.srl *.pem test command# 用sed 統一新舊 openssl tool 打印格式的小差別。 > openssl dhparam -in ./dh1024.pem -text -noout | sed 's/P:/prime:/' | sed 's/G:/generator:/' DH Parameters: (1024 bit) prime: 00:b5:be:5e:4d:5d:27:29:79:82:ce:99:6b:19:e1: 8c:49:4a:2b:39:05:e0:31:c9:57:80:6d:35:09:be: 06:c3:56:05:4d:19:d4:bb:e6:e0:31:e4:ae:b6:53: b9:0b:a1:f4:5f:88:92:5b:03:d4:f9:77:17:2a:3d: e3:dc:81:b2:c2:e8:19:1c:38:9b:09:a8:2a:db:23: 48:2c:66:62:9c:07:ba:8d:35:e7:18:40:63:cb:61: e9:79:bb:63:b7:37:c0:92:33:cf:76:8c:c8:06:d9: 2f:c6:3a:00:14:56:20:72:0b:ce:bc:5e:11:bb:a6: 5b:5a:08:76:78:82:45:7a:a3 generator: 2 (0x2) > openssl x509 -in ./server.pem -fingerprint -dates -subject -issuer -noout SHA1 Fingerprint=BE:AF:4F:65:71:06:9C:92:22:D1:EE:8C:F8:F5:30:6B:0D:1B:8A:6B notBefore=May 31 02:02:05 2023 GMT notAfter=Jun 30 02:02:05 2023 GMT subject=C = TW, ST = Test State or Province, L = taipei, O = adv, OU = rd, CN = server, emailAddress = test@email.address issuer=C = TW, ST = Test State or Province, L = taipei, O = adv, OU = rd, CN = rootca, emailAddress = test@email.address","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"openssl","slug":"openssl","permalink":"https://tsaiyuyan.github.io/tags/openssl/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"}]},{"title":"Ubuntu 試用 gptcommit 懶人工具","slug":"Linux/Ubuntu 試用 gptcommit 懶人工具","date":"2023-02-17T02:30:00.000Z","updated":"2023-02-21T07:46:42.142Z","comments":true,"path":"2023/02/17/linux/ubuntu-shi-yong-gptcommit-lan-ren-gong-ju/","link":"","permalink":"https://tsaiyuyan.github.io/2023/02/17/linux/ubuntu-shi-yong-gptcommit-lan-ren-gong-ju/","excerpt":"","text":"請先申請 openAI key, 透過 chatgpt 網站申請 Reference and Source site cargo install gptcommit github StartupInstall curl and cargosudo apt update sudo apt install curl -y sudo curl --proto &#39;=https&#39; --tlsv1.2 -sSf https://sh.rustup.rs | sh source &#39;$HOME/.cargo/env&#39; rustc --versionInstall gptcommit toolcargo install --locked gptcommitSet gptcommit with your openAI keygptcommit config set openai.api_key sk-XXXXXXXXXXOOOOOOOO....Install gptcommit act on your Repositoriescd [your_reoisutry_path] gptcommit install Installing gptcommit hook... Installing git hook to [your_reoisutry_path] gptcommit hook successfully installed!Try and enjoy itvim anything git commit -aTroubleshootingrustc version too old, require XXXXX or latersudo apt remove cargo sudo apt autoremovegptcommit commad not foundsource &#39;$HOME/.cargo/env&#39;","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"git","slug":"git","permalink":"https://tsaiyuyan.github.io/tags/git/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"tools","slug":"tools","permalink":"https://tsaiyuyan.github.io/tags/tools/"},{"name":"openAI","slug":"openAI","permalink":"https://tsaiyuyan.github.io/tags/openAI/"},{"name":"chatgpt","slug":"chatgpt","permalink":"https://tsaiyuyan.github.io/tags/chatgpt/"}]},{"title":"Ubuntu 使用 docker 快速架 mosquitto","slug":"Linux/Ubuntu 使用 docker 快速測試 mosquitto","date":"2022-12-27T02:00:00.000Z","updated":"2023-01-06T05:42:53.243Z","comments":true,"path":"2022/12/27/linux/ubuntu-shi-yong-docker-kuai-su-ce-shi-mosquitto/","link":"","permalink":"https://tsaiyuyan.github.io/2022/12/27/linux/ubuntu-shi-yong-docker-kuai-su-ce-shi-mosquitto/","excerpt":"","text":"Tree$ tree mosquitto/ mosquitto/ ├── config │ ├── certs │ │ ├── vcom_dh.pem │ │ ├── vcom.pem │ │ └── vcom_rootCA.pem │ └── mosquitto.conf ├── data └── log 執行Terminal 1 run mosquitto daemon: $ docker run -it --rm --name mqtt -p 1883:1883 -p 9001:9001 -p 8883:8883 -p 8884:8884 -v `pwd`/mosquitto:/mosquitto eclipse-mosquitto sh $ cat mosquitto/config/mosquitto.conf allow_anonymous true listener 1883 protocol mqtt listener 8883 protocol mqtt keyfile /mosquitto/config/certs/vcom.pem certfile /mosquitto/config/certs/vcom.pem cafile /mosquitto/config/certs/vcom_rootCA.pem require_certificate true $ mosquitto -c mosquitto/config/mosquitto.conf 1672046550: mosquitto version 2.0.15 starting 1672046550: Config loaded from mosquitto/config/mosquitto.conf. 1672046550: Opening ipv4 listen socket on port 8883. 1672046550: Opening ipv6 listen socket on port 8883. 1672046550: mosquitto version 2.0.15 running 1672046550: New connection from 127.0.0.1:56310 on port 8883. 1672046550: New client connected from 127.0.0.1:56310 as auto-3ADD4D06-E652-44B5-5D2A-52CE709FE8CA (p2, c1, k60). Terminal 2 test subscript: $ docker exec -it mqtt sh $ mosquitto_sub -p 8883 -h 127.0.0.1 -t '#' -v --key /mosquitto/config/certs/vcom.pem --cert /mosquitto/config/certs/vcom.pem --cafile /mosquitto/config/certs/vcom_rootCA.pem --insecure yuyuyuyu 1234wwwwwwwwwwwwww56 Terminal 3 test publish: $ docker exec -it mqtt sh $ mosquitto_pub -p 8883 -h 127.0.0.1 -t yuyuyuyu --key /mosquitto/config/certs/vcom.pem --cert /mosquitto/config/certs/vcom.pem --cafile /mosquitto/config/certs/vcom_rootCA.pem --insecure -m \"1234wwwwwwwwwwwwww56\"","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://tsaiyuyan.github.io/tags/docker/"},{"name":"mosquitto","slug":"mosquitto","permalink":"https://tsaiyuyan.github.io/tags/mosquitto/"}]},{"title":"Ubuntu 應用 net-snmp v3 snmptrap snmptrapd 範例筆記","slug":"Linux/Ubuntu 應用 net-snmp v3 snmptrap snmptrapd 範例筆記","date":"2022-11-16T02:00:00.000Z","updated":"2023-02-01T03:05:36.315Z","comments":true,"path":"2022/11/16/linux/ubuntu-ying-yong-net-snmp-v3-snmptrap-snmptrapd-fan-li-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2022/11/16/linux/ubuntu-ying-yong-net-snmp-v3-snmptrap-snmptrapd-fan-li-bi-ji/","excerpt":"","text":"下載 Dockfile 檔案> git clone https://github.com/dchidell/docker-snmptrap.git > cd docker-snmptrap # 產生image > docker build -t 'test/snmptrapd' ./ # 之後要刪掉就 > docker rmi test/snmptrapd 使用 docker 開啟 snmptrapd 服務 162> docker run -it --rm -v`pwd`/snmptrapd.conf:/etc/snmp/snmptrapd.conf -p 162:162/udp test/snmptrapd # --rm 隨用及刪, -v 引用外部檔案 或進入 sh 在執行服務 > docker run -it --rm -v`pwd`/snmptrapd.conf:/etc/snmp/snmptrapd.conf -p 162:162/udp test/snmptrapd sh # 進入容器 > vi /etc/snmp/snmptrapd.conf # 開啟snmptrapd服務 > snmptrapd -f -C -c /etc/snmp/snmptrapd.conf -Le -d # 另一種-D 參數 > snmptrapd -f -C -c /etc/snmp/snmptrapd.conf -Le -Dusm,usmUser,snmptrapd #-d dump raw package 可以不用加 編輯 snmptrapd.conf for snmpv3> vi /etc/snmp/snmptrapd.conf disableAuthorization no createUser -e 0x80001f8880bd343e4d59bb7263 yuyan123456 SHA authpass AES privpass authUser log,execute,net yuyan123456 authpriv # authpriv 可以替換成 noauthnopriv 或 authnopriv # 分別為noAuthNoPriv（不認證也不加密）、authNoPriv（認證但是不加密）、authPriv（既認證又加密) # AES 可換 (AES|DES) # SHA 可換 (MD5|SHA|SHA-224|SHA-256|SHA-384|SHA-512) 用 snmpget 取得 系統產生 engine id (這是錯的)網路上的範例通常會使用指定 engine id，但是其實可以透過 snmpget 去訪問 OID: .1.3.6.1.6.3.10.2.1.1.0， 就可以問到當下服務的 OID，當然這是對方有 snmpd 服務的情況下(通常應該會有) # 這邊用 v1 的方法詢問 > snmpget -mALL -v1 -cpublic localhost:161 .1.3.6.1.6.3.10.2.1.1.0 .1.3.6.1.6.3.10.2.1.1.0 = Hex-STRING: 80 00 1F 88 80 51 14 55 35 58 BB 72 63 # 80 00 1F 88 80 51 14 55 35 58 BB 72 63 就是 engine id 也可以使用一些 snmp 的免費工具軟體，就請隨意發揮。 snmptrap 測試 v3> snmptrap -v 3 -e 80001f88804993f817a758bc63 -u yuyan123456 -a SHA -A authpass -x AES -X privpass -l authPriv 10.0.7.4:162 0 .1.3.6.1.2.1.2.2.1.1.2 # 如果 snmptrapd 設定的 engine id 跟你不一樣就簡單的加個 -e 補上特定engine id 也可以通 > snmptrap -v 3 -e 0x80001f8880bd343e4d59bb7263 -u yuyan123456 -a SHA -A authpass -x AES -X privpass -l authPriv 10.0.7.4:162 0 .1.3.6.1.2.1.2.2.1.1.2 # 不然預設都是抓系統的 .1.3.6.1.6.3.10.2.1.1.0 # engine id snmptrap 與 snmptrapd的設定一定要相互匹配(重要) docker snmptrapd 收到 trap 會如下顯示> snmptrapd -f -C -c /etc/snmp/snmptrapd.conf -Le -d NET-SNMP version 5.8 2022-11-15 09:19:50 10.0.7.6 [UDP: [10.0.7.6]:52621->[172.18.0.4]:162]: DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (0) 0:00:00.00 SNMPv2-MIB::snmpTrapOID.0 = OID: IF-MIB::ifIndex.2 snmptrap V1 | V2c 補充範例 這邊建議下載 snmp trap watcher 軟體直接做 snmptrapd 測試來用比較方便google 搜尋 “BTT Software snmp trap watcher” snmptrap v1snmptrap -v1 -c public 10.0.7.5 1.3.6.1.4.1.1 10.0.7.5 2 3 1000 1.3.6.1.9.9.44.1.2.1 i 12 1.3.4.1.2.3.1 s test_snmptrap snmptrap v1 欄位 值 命令 snmptrap Snmp 協議版本 -v1 共同體 -c public Snmp 管理端 IP 10.0.7.5 Enterprise-OID 1.3.6.1.4.1.1 Snmp 代理 IP 10.0.7.5 Trap 類型 2 Trap 特徵碼 3 uptime 1000 被發送參數的 OID 1.3.6.1.9.9.44.1.2.1 數據類型 i 數據值 12 被發送參數的 OID 1.3.4.1.2.3.1 數據類型 s 數據值 test_snmptrap snmptrap v2csnmptrap -v2c -c public 10.0.7.5 \"aaa\" 1.3.6.1.4.1.2345 .1.3.6.1.2.1.1.6.0 s \"just here\" 10.0.7.5 “aaa” : 分別是 snmp 代理的 IP 和主機名稱，主機名稱可以為空 1.3.6.1.4.1.2345 : 企業 OID，Enterprise-OID .1.3.6.1.2.1.1.6.0 s “just here” : 分別是數據 OID、數據類型、數據值。 snmptrap v3snmptrap -v 3 -u yuyan123456 -a SHA -A authpass -x AES -X privpass -l authPriv 10.0.7.4:162 0 .1.3.6.1.2.1.2.2.1.1.2","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"net-snmp","slug":"net-snmp","permalink":"https://tsaiyuyan.github.io/tags/net-snmp/"},{"name":"snmp","slug":"snmp","permalink":"https://tsaiyuyan.github.io/tags/snmp/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"snmptrap","slug":"snmptrap","permalink":"https://tsaiyuyan.github.io/tags/snmptrap/"},{"name":"snmptrapd","slug":"snmptrapd","permalink":"https://tsaiyuyan.github.io/tags/snmptrapd/"}]},{"title":"Ubuntu 使用 docker 快速架 NTP Server","slug":"Linux/Ubuntu 使用 docker 快速架 NTP Server","date":"2022-09-12T02:00:00.000Z","updated":"2022-09-12T07:37:13.867Z","comments":true,"path":"2022/09/12/linux/ubuntu-shi-yong-docker-kuai-su-jia-ntp-server/","link":"","permalink":"https://tsaiyuyan.github.io/2022/09/12/linux/ubuntu-shi-yong-docker-kuai-su-jia-ntp-server/","excerpt":"","text":"因為專案有用到 ntp server 為避免一堆不必要的麻煩用docker image 直接架一個測試用的 ntp serverudp port : 123 執行# run ntp $> docker run --name=ntp \\ --restart=always \\ --detach \\ --publish=123:123/udp \\ cturra/ntp $> docker ps CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 6927a1944700 cturra/ntp \"/bin/sh /opt/startu…\" 7 seconds ago Up 5 seconds (health: starting) 0.0.0.0:123->123/udp, :::123->123/udp ntp # OR run ntp with higher security $> docker run --name=ntp \\ --restart=always \\ --detach \\ --publish=123:123/udp \\ --read-only \\ --tmpfs=/etc/chrony:rw,mode=1750 \\ --tmpfs=/run/chrony:rw,mode=1750 \\ --tmpfs=/var/lib/chrony:rw,mode=1750 \\ cturra/ntp","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://tsaiyuyan.github.io/tags/docker/"},{"name":"ntp","slug":"ntp","permalink":"https://tsaiyuyan.github.io/tags/ntp/"}]},{"title":"Git Github 筆記","slug":"Git Github 筆記","date":"2021-12-17T02:00:00.000Z","updated":"2022-12-05T08:53:05.187Z","comments":true,"path":"2021/12/17/git-github-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2021/12/17/git-github-bi-ji/","excerpt":"","text":"git commits 大合併# Reset the current branch to the commit just before the last 12: git reset --hard HEAD~12 # HEAD@{1} is where the branch was just before the previous command. # This command sets the state of the index to be as it would just # after a merge from that commit: git merge --squash HEAD@{1} # Commit those squashed changes. The commit message will be helpfully # prepopulated with the commit messages of all the squashed commits: git commit git loggit log --after=\"2020-05-15\" --before=\"2020-05-25\" git log --author=\"yuyan\" git log --grep=\"ISSUE-43560\" git log --pretty=format:\"%Cred%an - %ar%n %Cblue %h -%Cgreen %s %n\" #git log with diff changes git log -p 強制覆蓋 github 版本 (需注意這步將無法還原)git push -f origin What happens to the forks when deleting the original repository? It depends whether the original and the fork are public or private, according to GitHub’s documentation: Deleting a private repository will delete all of its forks. Deleting a public repository will not delete its forks. More detail on this page: Get github access tokenUsername for 'https://github.com': XXXXXXXXXXXX Password for 'https://XXXXXXXXXXXX@github.com': remote: Support for password authentication was removed on August 13, 2021. Please use a personal access token instead. remote: Please see https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/ for more information. fatal: Authentication failed for 'https://github.com/xxxxxxxx/xxxxxx.git/' 現在在使用 git clone 如果遇到要登入帳密的問題 tool 會告知要使用token 當密碼 打開github -&gt; Settings -&gt; Developer settings -&gt; Personal access token –&gt; Generate new token -&gt; repo 勾起來-&gt; save Deleting a private repositoryWhen you delete a private repository, all of its private forks are also deleted. Deleting a public repositoryWhen you delete a public repository, one of the existing public forks is chosen to be the new parent repository. All other repositories are forked off of this new parent and subsequent pull requests go to this new parent. Mermaid 語法graph LR A[Hard edge] -->|Link text| B(Round edge) B --> C{Decision} C -->|One| D[Result one] C -->|Two| E[Result two] logic examplesequenceDiagram Client ->> Server : ClientHello Server ->> Client : ServerHello par Server -->> Client : send Certificate Server -->> Client : send ServerKey exchange Note right of Server: TCP segment Server -->> Client : send Certificate end Server ->> Client : ServerHello done Note over Client,Server: ServerHello done par Client -->> Server : ClientKey exchange Client -->> Server : Chabge Cipher Spec Client ->> Server : Finished end Note over Client,Server: Finished LRUgraph start --> A subgraph userpass check A{userpass search? } end A -- match --> B[fast accept/drop] subgraph black check A -- not found --> b{black search? } b -- match --> C{try_cnt over?} end C -- Yes --> E[ban and drop, is hacker?] subgraph authorize check b -- not found--> D{LDAP/RADIUS check?} C -- no --> D end D -- fail --> f[drop and update black list] D -- success --> F[accept and update userpass list] usdg testsequenceDiagram Note right of PC: usdg slave mode Note right of EKI-1524-CE: --> vcom port1->port2 --> par PC -->> EKI-1524-CE : ssl_connect PC -->> EKI-1524-CE : mbus_rtu_over_ssl end EKI-1524-CE -->> Serial_Dev: mbus rtu/acscii Serial_Dev -->> EKI-1524-CE: mbus response EKI-1524-CE -->> PC : mbus_rtu_over_ssl SSLgraph TD PC -- SSL --- E[EKI1524] E -- Ser_TX --> S[Serial_Dev] S -- Ser_RX --> E rx_bcastgraph TD start --> r[rx bcast/mcast and get the interface index of the packet] r--> c{is rx source ip match interfaces?} c-- Yes --> k[keep previous info] --> K[end] c-- No --> w[walk ip_address with subnet] --> C{same subnet?} C-- True --> u[use interface & subnet] --> K[end] C-- False or previous info is empty --> U[use interface & ip_family] --> K[end] Other examplesequenceDiagramsequenceDiagram autonumber Alice->>John: Hello John, how are you? loop Healthcheck John->>John: Fight against hypochondria end Note right of John: Rational thoughts! John-->>Alice: Great! John->>Bob: How about you? Bob-->>John: Jolly good! classDiagramclassDiagram classA --|> classB : Inheritance classC --* classD : Composition classE --o classF : Aggregation classG --> classH : Association classI -- classJ : Link(Solid) classK ..> classL : Dependency classM ..|> classN : Realization classO .. classP : Link(Dashed) stateDiagram-v2 stateDiagram-v2 State1: The state with a note note right of State1 Important information! You can write notes. end note State1 --> State2 note left of State2 : This is the note to the left. journeyjourney title My working day section Go to work Make tea: 9: Me Go upstairs: 3: Me Do work: 1: Me, Cat section Go home Go downstairs: 5: Me Sit down: 5: Me ganttgantt title A Gantt Diagram dateFormat YYYY-MM-DD section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d another task : 24d piepie title Key elements in Product X \"Calcium\" : 42.96 \"Potassium\" : 50.05 \"Magnesium\" : 10.01 \"Iron\" : 5","categories":[{"name":"版控","slug":"版控","permalink":"https://tsaiyuyan.github.io/categories/%E7%89%88%E6%8E%A7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://tsaiyuyan.github.io/tags/git/"},{"name":"github","slug":"github","permalink":"https://tsaiyuyan.github.io/tags/github/"}]},{"title":"Ubuntu 工具 socat","slug":"Linux/Ubuntu 工具 socat","date":"2021-10-19T02:00:00.000Z","updated":"2022-03-23T02:52:49.286Z","comments":true,"path":"2021/10/19/linux/ubuntu-gong-ju-socat/","link":"","permalink":"https://tsaiyuyan.github.io/2021/10/19/linux/ubuntu-gong-ju-socat/","excerpt":"","text":"reference: [https://snoopysecurity.github.io/network-security/2018/03/21/introduction_to_socat.html] create loopback ttysudo socat pty,link=/dev/ttyAP0 pty,link=/dev/ttyAP0create tcp serversocat TCP-LISTEN:5000 -create TLS serversocat TCP-LISTEN:51000,fork,reuseaddr OPENSSL:remotehost:51000,cafile=certificate.pem,verify=0create telnet serversocat exec:&#39;bash -li&#39;,pty,stderr,setsid tcp-listen:5000,reuseaddrcreate ttysocat -d -d tcp-l:1233,reuseaddr,fork file:/dev/ttyUSB0,nonblock,raw,echo=0,waitlock=/var/run/tty,min=0,b115200","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"socat","slug":"socat","permalink":"https://tsaiyuyan.github.io/tags/socat/"}]},{"title":"Ubuntu 工具 graph-easy","slug":"Linux/Ubuntu 工具 graph-easy","date":"2021-10-19T02:00:00.000Z","updated":"2021-10-19T08:43:45.404Z","comments":true,"path":"2021/10/19/linux/ubuntu-gong-ju-graph-easy/","link":"","permalink":"https://tsaiyuyan.github.io/2021/10/19/linux/ubuntu-gong-ju-graph-easy/","excerpt":"","text":"reference: graph-easy-cn : https://weishu.gitbooks.io/graph-easy-cn/content/hinting/flow.html 1. install graph-easy$sudo apt install libgraph-easy-perl 2. edit file$vim simple.txt graph { flow: south; } [start] -> [userpass search?] [userpass search?] - match -> [fast accept/drop] [userpass search?] - not found -> [black search?] [black search?] - match -> [try_cnt over?] [black search?] - not found -> [LDAP/RADIUS check] [LDAP/RADIUS check] - success -> [accept and update userpass] [LDAP/RADIUS check] - fail -> [drop and update userpass/black] [try_cnt over?] - yes -> [ban drop, is hacker?] [try_cnt over?] - no -> [LDAP/RADIUS check] 3. graph it$graph-easy ./simple.txt 4. LRU cache as examplecache display: ### LRU - Least Recently Used Cache ### + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + ' 1.userpass cache: ' ' ' ' +-----------------++--------++--------------------------+ ' ' | latest || oldest || invalid | ' ' +-----------------++--------++--------------------------+ ' ' ' + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + ' 2.black cache: ' ' ' ' +-----------------++--------++--------------------------+ ' ' | latest || oldest || invalid | ' ' +-----------------++--------++--------------------------+ ' ' ' + - - - - - - - - - - - - - - - - - - - - - - - - - - - - - + head tail graph display: +----------------------------+ | start | +----------------------------+ | | v +--------------------------------+ match +----------------------------+ | fast accept/drop |","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"graph-easy","slug":"graph-easy","permalink":"https://tsaiyuyan.github.io/tags/graph-easy/"}]},{"title":"Hexo - gitalk 403 issue","slug":"Hexo/Hexo - gitalk 403 issue","date":"2021-10-18T02:00:00.000Z","updated":"2021-10-18T05:51:32.269Z","comments":true,"path":"2021/10/18/hexo/hexo-gitalk-403-issue/","link":"","permalink":"https://tsaiyuyan.github.io/2021/10/18/hexo/hexo-gitalk-403-issue/","excerpt":"","text":"issueblog 文章底下 gitalk 插件，再登入 github 帳號後 一直轉圈，並得到 error code 403 solvereference: https://umm.js.org/p/1d1d49e9/ 升級 gitalk 版本。(目前覺得最方便解決) $vim [your_hexo_folder]/themes/hexo-theme-matery/_config.yml - gitalk: /libs/gitalk/gitalk.css + gitalk: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.css - gitalk: /libs/gitalk/gitalk.min.js + gitalk: //cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://tsaiyuyan.github.io/categories/Hexo/"}],"tags":[]},{"title":"Ubuntu 手動新增 swap","slug":"Linux/Ubuntu 手動新增 swap","date":"2021-08-10T02:00:00.000Z","updated":"2021-08-10T03:03:19.800Z","comments":true,"path":"2021/08/10/linux/ubuntu-shou-dong-xin-zeng-swap/","link":"","permalink":"https://tsaiyuyan.github.io/2021/08/10/linux/ubuntu-shou-dong-xin-zeng-swap/","excerpt":"","text":"1. 切割 16GB 空間做為 swap 使用sudo fallocate -l 16G /swapfile2. 告知系統使用此檔案，啟用 swap 功能sudo chmod 600 /swapfile sudo mkswap /swapfile sudo swapon /swapfile3. 將 swap 設定為開機自動掛載sudo vim /etc/fstab # 加上 /swapfile none swap sw 0 04. fallocate: fallocate failed: Text file busysudo swapoff -a","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"swap","slug":"swap","permalink":"https://tsaiyuyan.github.io/tags/swap/"}]},{"title":"Ubuntu OpenLDAP 移植 mips64-octeon-linux(mips64-octeon-linux-gnu)","slug":"Linux/Ubuntu OpenLDAP 移植 mips64-octeon-linux(mips64-octeon-linux-gnu)","date":"2021-04-12T03:00:00.000Z","updated":"2021-08-09T03:32:54.292Z","comments":true,"path":"2021/04/12/linux/ubuntu-openldap-yi-zhi-mips64-octeon-linux-mips64-octeon-linux-gnu/","link":"","permalink":"https://tsaiyuyan.github.io/2021/04/12/linux/ubuntu-openldap-yi-zhi-mips64-octeon-linux-mips64-octeon-linux-gnu/","excerpt":"","text":"configure 時，指定 CC 、 CPPFLAGS 、LDFLAG， CPPFLAGS 是關鍵，不要使用 CFLAGS，不然會一直驗證 ssl 失敗 Build OpenLDAP with Openssl，only client tools# download OpenLDAP wget https://www.openldap.org/software/download/OpenLDAP/openldap-release/openldap-2.4.58.tgz --no-check-certificate tar zxvf openldap-2.4.58.tgz ; cd openldap-2.4.58 # configure ./configure --target=mips64-octeon-linux-gnu --host=mips64-octeon-linux-gnu --build=x86_64-linux-gnu --prefix=`pwd`/installed --enable-shared --disable-static --disable-debug --enable-dynamic --enable-syslog --disable-local --without-cyrus-sasl --without-fetch --with-tls --with-yielding_select=yes --with-threads --enable-null --disable-bdb --disable-hdb --disable-monitor --disable-relay --disable-slapd CC=mips64-octeon-linux-gnu-gcc LDFLAGS=\"-L/root/shared_data/embedded_rootfs/build/openssl -lssl -lcrypto\" CPPFLAGS=\"-I/root/shared_data/embedded_rootfs/build/openssl/include\" # other option --exec-prefix=/usr --bindir=/usr/bin --sbindir=/usr/sbin --libexecdir=/usr/lib --sysconfdir=/etc # 只選build client tools，不然再產生 doc 的檔案時候會出現 /bin/sh: 15: soelim: not found 的錯誤 # 或是安裝 apt-get install groff groff-base sed -i 's/SUBDIRS= include libraries clients servers tests doc/SUBDIRS= include libraries clients/ ' Makefile # 解決 undefined reference to `lutil_memcmp’. sed -i 's/#define NEED_MEMCMP_REPLACEMENT 1/\\/\\*#undef NEED_MEMCMP_REPLACEMENT\\*\\// ' include/portable.h # 解決 strip 參數的問題 sed -i 's/STRIP = -s/STRIP =/' clients/tools/Makefile # compile and build make depend && make # install make install # strip lib and bin mips64-octeon-linux-gnu-strip installed/bin/* installed/lib/*","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"OpenLDAP","slug":"OpenLDAP","permalink":"https://tsaiyuyan.github.io/tags/OpenLDAP/"},{"name":"cross-compiler","slug":"cross-compiler","permalink":"https://tsaiyuyan.github.io/tags/cross-compiler/"}]},{"title":"Ubuntu OpenLDAP 移植 arm-linux(arm-linux-gnueabihf)","slug":"Linux/Ubuntu OpenLDAP 移植 arm-linux(arm-linux-gnueabihf)","date":"2021-04-12T02:00:00.000Z","updated":"2021-08-09T02:06:49.267Z","comments":true,"path":"2021/04/12/linux/ubuntu-openldap-yi-zhi-arm-linux-arm-linux-gnueabihf/","link":"","permalink":"https://tsaiyuyan.github.io/2021/04/12/linux/ubuntu-openldap-yi-zhi-arm-linux-arm-linux-gnueabihf/","excerpt":"","text":"configure 時，指定 CC 、 CPPFLAGS 、LDFLAG， CPPFLAGS 是關鍵，不要使用 CFLAGS，不然會一直驗證 ssl 失敗 Build OpenLDAP with Openssl，only client tools# download OpenLDAP wget https://www.openldap.org/software/download/OpenLDAP/openldap-release/openldap-2.4.58.tgz --no-check-certificate tar zxvf openldap-2.4.58.tgz ; cd openldap-2.4.58 # configure ./configure --target=arm-linux-gnueabihf --host=arm-linux-gnueabihf --build=x86_64-linux-gnu --prefix=`pwd`/installed --enable-shared --disable-static --disable-debug --enable-dynamic --enable-syslog --disable-local --without-cyrus-sasl --without-fetch --with-tls --with-yielding_select=yes --with-threads --enable-null --disable-bdb --disable-hdb --disable-monitor --disable-relay --disable-slapd CC=arm-linux-gnueabihf-gcc LDFLAGS=\"-L/root/shared_data/lib/libssl -lssl -lcrypto\" CPPFLAGS=\"-I/root/shared_data/lib/libssl/include\" # other option --exec-prefix=/usr --bindir=/usr/bin --sbindir=/usr/sbin --libexecdir=/usr/lib --sysconfdir=/etc # 只選build client tools，不然再產生 doc 的檔案時候會出現 /bin/sh: 15: soelim: not found 的錯誤 # 或是安裝 apt-get install groff groff-base sed -i 's/SUBDIRS= include libraries clients servers tests doc/SUBDIRS= include libraries clients/ ' Makefile # 解決 undefined reference to `lutil_memcmp’. sed -i 's/#define NEED_MEMCMP_REPLACEMENT 1/\\/\\*#undef NEED_MEMCMP_REPLACEMENT\\*\\// ' include/portable.h # 解決 strip 參數的問題 sed -i 's/STRIP = -s/STRIP =/' clients/tools/Makefile # compile and build make depend && make # install make install # strip lib and bin arm-linux-gnueabihf-strip installed/bin/* installed/lib/*","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"OpenLDAP","slug":"OpenLDAP","permalink":"https://tsaiyuyan.github.io/tags/OpenLDAP/"},{"name":"cross-compiler","slug":"cross-compiler","permalink":"https://tsaiyuyan.github.io/tags/cross-compiler/"}]},{"title":"1038. Binary Search Tree to Greater Sum Tree","slug":"Leetcode/1038_Binary Search Tree to Greater Sum Tree","date":"2020-10-30T02:10:00.000Z","updated":"2020-10-30T02:28:09.491Z","comments":true,"path":"2020/10/30/leetcode/1038-binary-search-tree-to-greater-sum-tree/","link":"","permalink":"https://tsaiyuyan.github.io/2020/10/30/leetcode/1038-binary-search-tree-to-greater-sum-tree/","excerpt":"","text":"Link: https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/ Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Note: This question is the same as 1038: : https://leetcode.com/problems/convert-bst-to-greater-tree/] Example 1: Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Example 2: Input: root = [0,null,1] Output: [1,null,1] Example 3: Input: root = [1,0,2] Output: [3,3,2] Example 4: Input: root = [3,2,4,1] Output: [7,9,4,10] 題目翻譯: 將二元樹變成 greater 二元樹。 程式思路: 簡單說就是 當前節點等於右邊子樹的總和。先用postorder 走一遍存入陣列，然後計算後再走一次 postorder。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int> arr; void postorder(TreeNode *node) { if(node == NULL) return; postorder(node->right); arr.push_back(node->val); postorder(node->left); } void greater_postorder(TreeNode *node,int &amp;idx) { if(node == NULL) return; greater_postorder(node->right,idx); node->val = arr[idx++]; greater_postorder(node->left,idx); } TreeNode* bstToGst(TreeNode* root) { postorder(root); int sz = arr.size(); for(int i = 1;i &lt; sz;i++) arr[i] = arr[i-1] + arr[i]; int idx = 0; greater_postorder(root,idx); return root; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"538. Convert BST to Greater Tree","slug":"Leetcode/538_Convert BST to Greater Tree","date":"2020-10-30T02:00:00.000Z","updated":"2020-10-30T02:28:11.623Z","comments":true,"path":"2020/10/30/leetcode/538-convert-bst-to-greater-tree/","link":"","permalink":"https://tsaiyuyan.github.io/2020/10/30/leetcode/538-convert-bst-to-greater-tree/","excerpt":"","text":"Link: https://leetcode.com/problems/convert-bst-to-greater-tree/ Given the root of a Binary Search Tree (BST), convert it to a Greater Tree such that every key of the original BST is changed to the original key plus sum of all keys greater than the original key in BST. As a reminder, a binary search tree is a tree that satisfies these constraints: The left subtree of a node contains only nodes with keys less than the node’s key. The right subtree of a node contains only nodes with keys greater than the node’s key. Both the left and right subtrees must also be binary search trees. Note: This question is the same as 1038: [https://leetcode.com/problems/binary-search-tree-to-greater-sum-tree/] Example 1: Input: root = [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8] Output: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8] Example 2: Input: root = [0,null,1] Output: [1,null,1] Example 3: Input: root = [1,0,2] Output: [3,3,2] Example 4: Input: root = [3,2,4,1] Output: [7,9,4,10] 題目翻譯: 將二元樹變成 greater 二元樹。 程式思路: 簡單說就是 當前節點等於右邊子樹的總和。先用postorder 走一遍存入陣列，然後計算後再走一次 postorder。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode() : val(0), left(nullptr), right(nullptr) {} * TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} * TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {} * }; */ class Solution { public: vector&lt;int> arr; void postorder(TreeNode *node) { if(node == NULL) return; postorder(node->right); arr.push_back(node->val); postorder(node->left); } void greater_postorder(TreeNode *node,int &amp;idx) { if(node == NULL) return; greater_postorder(node->right,idx); node->val = arr[idx++]; greater_postorder(node->left,idx); } TreeNode* convertBST(TreeNode* root) { postorder(root); int sz = arr.size(); for(int i = 1;i &lt; sz;i++) { arr[i] = arr[i-1] + arr[i]; } int idx = 0; greater_postorder(root,idx); return root; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"Ubuntu 啟用 google bbr","slug":"Linux/Ubuntu 啟用 google bbr","date":"2020-10-27T02:00:00.000Z","updated":"2020-12-08T01:19:45.875Z","comments":true,"path":"2020/10/27/linux/ubuntu-qi-yong-google-bbr/","link":"","permalink":"https://tsaiyuyan.github.io/2020/10/27/linux/ubuntu-qi-yong-google-bbr/","excerpt":"","text":"reference: quic: [https://en.wikipedia.org/wiki/QUIC] eanble bbr: [https://www.mf8.biz/ubuntu-20-04-bbr/] Ubuntu 18.04 默認內核是 4.15版本的內核 Linux Kernel 內核升級到 4.9 及以上版本可以實現 BBR 加速，由於，由於Ubuntu 20.04 默認的內核就是 5.4 版本的內核，並已經默認編譯了 TCP BBR 模塊，所以可以直接通過參數開啟。 新的 TCP 擁塞控制算法 BBR (Bottleneck Bandwidth and RTT) 可以讓服務器的帶寬儘量跑慢，並且儘量不要有排隊的情況，讓網絡服務更佳穩定和高效。 修改系統變量 echo net.core.default_qdisc=fq >> /etc/sysctl.conf echo net.ipv4.tcp_congestion_control=bbr >> /etc/sysctl.conf 保存生效 sysctl -p 執行 sysctl net.ipv4.tcp_available_congestion_control net.ipv4.tcp_available_congestion_control = bbr cubic reno 或是用 lsmod | grep tcp_bbr。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"quic","slug":"quic","permalink":"https://tsaiyuyan.github.io/tags/quic/"},{"name":"bbr","slug":"bbr","permalink":"https://tsaiyuyan.github.io/tags/bbr/"}]},{"title":"1081. Smallest Subsequence of Distinct Characters","slug":"Leetcode/1081_Smallest Subsequence of Distinct Characters","date":"2020-10-14T02:00:00.000Z","updated":"2020-10-14T02:36:00.320Z","comments":true,"path":"2020/10/14/leetcode/1081-smallest-subsequence-of-distinct-characters/","link":"","permalink":"https://tsaiyuyan.github.io/2020/10/14/leetcode/1081-smallest-subsequence-of-distinct-characters/","excerpt":"","text":"Link: [https://leetcode.com/problems/smallest-subsequence-of-distinct-characters/]Return the lexicographically smallest subsequence of s that contains all the distinct characters of s exactly once. Note: This question is the same as 316: [https://leetcode.com/problems/remove-duplicate-letters/] Example 1: Input: s = \"bcabc\" Output: \"abc\" Example 2: Input: s = \"cbacdcbc\" Output: \"acdb\" Constraints: 1 &lt;= s.length &lt;= 1000 s consists of lowercase English letters. 題目翻譯: X 程式思路: X class Solution { public: string smallestSubsequence(string s) { vector &lt;int> seen (26,false); vector &lt;int> freq (26,0); stack &lt;char> stk; for (auto c : s) { freq[c - 'a']++; } for (int i = 0; i &lt; s.length(); i++) { char ch = s[i]; freq[ch - 'a']--; if (seen[ch - 'a']) continue; while (!stk.empty() &amp;&amp; stk.top() > ch &amp;&amp; freq[stk.top() - 'a'] > 0) { seen[stk.top() - 'a'] = false; stk.pop(); } stk.push(ch); seen[ch - 'a'] = true; } string res; while (!stk.empty()) { res += stk.top(); stk.pop(); } reverse(res.begin(), res.end()); return res; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"1399_Count Largest Group","slug":"Leetcode/1399_Count Largest Group","date":"2020-10-05T03:00:00.000Z","updated":"2020-10-05T05:20:32.329Z","comments":true,"path":"2020/10/05/leetcode/1399-count-largest-group/","link":"","permalink":"https://tsaiyuyan.github.io/2020/10/05/leetcode/1399-count-largest-group/","excerpt":"","text":"Link: https://leetcode.com/problems/count-largest-group/ Given an integer n. Each number from 1 to n is grouped according to the sum of its digits. Return how many groups have the largest size. Example 1: Input: n = 13 Output: 4 Explanation: There are 9 groups in total, they are grouped according sum of its digits of numbers from 1 to 13: [1,10], [2,11], [3,12], [4,13], [5], [6], [7], [8], [9]. There are 4 groups with largest size. Example 2: Input: n = 2 Output: 2 Explanation: There are 2 groups [1], [2] of size 1. Example 3: Input: n = 24 Output: 5 Constraints: 1 &lt;= n &lt;= 10^4 題目翻譯: 給定一個 n，然後將 1~n 進行分組，分組的方法就是，數字 程式思路: 很 easy class Solution { private: int digits_sum(int input) { int sum = 0; while (input/10 != 0) { sum += input %10; input/=10; } sum += input %10; return sum; } public: int countLargestGroup(int n) { vector &lt;int> count(36,0); // max 1~9999 = 1 ~ 36 for(int i = 1; i &lt;= n; i++) { count[digits_sum(i)-1]++; } int maxi = *max_element(count.begin(),count.end()); return count_if(begin(count), end(count), [&amp;maxi](const auto &amp;p) {return p == maxi;}); } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1446. Consecutive Characters","slug":"Leetcode/1446_Consecutive Characters","date":"2020-09-30T04:00:00.000Z","updated":"2020-09-30T05:06:04.184Z","comments":true,"path":"2020/09/30/leetcode/1446-consecutive-characters/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/30/leetcode/1446-consecutive-characters/","excerpt":"","text":"Link: https://leetcode.com/problems/consecutive-characters/ Given a string s, the power of the string is the maximum length of a non-empty substring that contains only one unique character. Return the power of the string. Example 1: Input: s = \"leetcode\" Output: 2 Explanation: The substring \"ee\" is of length 2 with the character 'e' only. Example 2: Input: s = \"abbcccddddeeeeedcba\" Output: 5 Explanation: The substring \"eeeee\" is of length 5 with the character 'e' only. Example 3: Input: s = \"triplepillooooow\" Output: 5 Example 4: Input: s = \"hooraaaaaaaaaaay\" Output: 11 Example 5: Input: s = \"tourist\" Output: 1 Constraints: 1 &lt;= s.length &lt;= 500 s contains only lowercase English letters. 題目翻譯: 就找出字串裡的字母最大連續數量。 程式思路: easy class Solution { public: int maxPower(string s) { int power = 0; int max_power = 0; char c = '\\0'; for(auto it : s) { if(it != c) power = 1; else power++; c = it; if(power > max_power) max_power = power; } return max_power; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"LeetCode Note.","slug":"Leetcode/LeetCode Note","date":"2020-09-30T03:00:00.000Z","updated":"2020-12-24T01:31:05.583Z","comments":true,"path":"2020/09/30/leetcode/leetcode-note/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/30/leetcode/leetcode-note/","excerpt":"","text":"Common Container1. string substr(i,str.length()-i) find rfind c_str() erase 2. vector 用emplace_front, emplace, emplace_back 代替 push_front, insert, push_back emplace 相關函式可以減少記憶體拷貝和移動。當插入 rvalue，它節約了一次 move 構造，當插入 lvalue，它節約了一次 copy 構造。 pop_back() 3. queue and deque Hint: Deque is short for “Double ended queue”. Queue: you can insert only in one end and remove from the other. Deque: you can insert and remove from both ends. Methods: emplace_back(val) erase empty() push_front(val) pop_back() 4. stack s.top() s.pop() s.push() 5. map and unordered_mapstd::unordered_map&lt;char,int> umap; string J = \"12345678abcdef\"; for (unsigned i=0; i&lt;J.length(); ++i) umap.insert( pair&lt;char, int>( J.at(i), i)); //... if(umap.find('a') != umap.end()) //... unordered_map &lt;char, char> table; string pattern,word; for(i = 0; i&lt; pattern.length(); i++) { auto ret = table.insert(std::pair &lt;char,char> (pattern[i],word[i])); if(ret.second == false) { //already exist } } 6. set and unordered_set 常用於紀錄是否有重複之類的 .insert unordered_set &lt;char> mark; auto ret = mark.insert('a'); if(ret.second == false) { //already exist } Functions or Methods1.找容器極值int max = *std::max_element(nums.begin(),nums.end()) int min = *std::min_element(nums.begin(),nums.end()) int sum = std::accumulate(nums.begin(), nums.end(), 0) 2.型態極值 有些題目會用到極值來判斷 #include &lt;limits> #include &lt;iostream> int main() { std::cout &lt;&lt; \"bool\\t\" &lt;&lt; std::numeric_limits&lt;bool>::lowest() &lt;&lt; \"\\t\\t\" &lt;&lt; std::numeric_limits&lt;bool>::min() &lt;&lt; \"\\t\\t\" &lt;&lt; std::numeric_limits&lt;bool>::max() &lt;&lt; '\\n' &lt;&lt; \"uchar\\t\" &lt;&lt; +std::numeric_limits&lt;unsigned char>::lowest() &lt;&lt; \"\\t\\t\" &lt;&lt; +std::numeric_limits&lt;unsigned char>::min() &lt;&lt; \"\\t\\t\" &lt;&lt; +std::numeric_limits&lt;unsigned char>::max() &lt;&lt; '\\n' &lt;&lt; \"int\\t\" &lt;&lt; std::numeric_limits&lt;int>::lowest() &lt;&lt; '\\t' &lt;&lt; std::numeric_limits&lt;int>::min() &lt;&lt; '\\t' &lt;&lt; std::numeric_limits&lt;int>::max() &lt;&lt; '\\n' &lt;&lt; \"float\\t\" &lt;&lt; std::numeric_limits&lt;float>::lowest() &lt;&lt; '\\t' &lt;&lt; std::numeric_limits&lt;float>::min() &lt;&lt; '\\t' &lt;&lt; std::numeric_limits&lt;float>::max() &lt;&lt; '\\n' &lt;&lt; \"double\\t\" &lt;&lt; std::numeric_limits&lt;double>::lowest() &lt;&lt; '\\t' &lt;&lt; std::numeric_limits&lt;double>::min() &lt;&lt; '\\t' &lt;&lt; std::numeric_limits&lt;double>::max() &lt;&lt; '\\n'; } Possible output: bool 0 0 1 uchar 0 0 255 int -2147483648 -2147483648 2147483647 float -3.40282e+38 1.17549e-38 3.40282e+38 double -1.79769e+308 2.22507e-308 1.79769e+308 3. 排序 sort std::sort(vector.begin(), vector.end(), std::less&lt;int&gt;()) : 由大排到小 std::sort(vector.begin(), vector.end(), std::greater&lt;int&gt;()) : 由小排到大 4. 轉換大小寫// c++ string str; std::transform(str.begin(), str.end(), str.begin(), ::tolower); std::transform(str.begin(), str.end(), str.begin(), ::toupper); for_each(str.begin(), str.end(), [](char &amp;x){x = tolower(x);}); for_each(str.begin(), str.end(), [](char &amp;x){x = toupper(x);}); // c int offset = 'A' - 'a'; for(int i =0; i &lt; str.length() ; i++) { if(str[i] >='A' &amp;&amp; str[i] &lt;= 'Z') { str[i] -= offset; } } 5. for_eachfor_each(A.begin(),A.end(), [](int &amp;a){ a *= a;}); for_each(str.begin(), str.end(), [](char &amp;x){x = tolower(x);}); for_each(str.begin(), str.end(), [](char &amp;x){x = toupper(x);}); for_each(nums.begin(), nums.end(), [&amp;sum, &amp;nums](int&amp; n) { sum += n; }); 6. LambdaCapturing Local Variables by Reference inside Lambda // Local Variables std::string msg = \"Hello\"; int counter = 10; // Defining Lambda function and // Capturing Local variables by Reference auto func = [&amp;msg, &amp;counter] () { //... }; Capture All Local Variables from outer scope by Value // Capturing all Local variables by Value auto func = [=] () { //... }; Capture all local variables from outer scope by Reference // Capturing all Local variables by Reference auto func = [&amp;] () { //... }; 7. count_ifvector &lt;int> count; ... count_if(begin(count), end(count), [&amp;maxi](const auto &amp;p) {return p == maxi;} What’s the most efficient way to erase duplicates and sort a vector//ust using vector, sort + unique sort( vec.begin(), vec.end() ); vec.erase( unique( vec.begin(), vec.end() ), vec.end() ); //Convert to set (manually) set&lt;int> s; unsigned size = vec.size(); for( unsigned i = 0; i &lt; size; ++i ) s.insert( vec[i] ); vec.assign( s.begin(), s.end() ); //Convert to set (using a constructor) set&lt;int> s( vec.begin(), vec.end() ); vec.assign( s.begin(), s.end() ); ... ## 河內塔 ```c #include &lt;iostream> #include &lt;cstdio> using namespace std; int cnt; //全局變量，每次調用會+1 void move(int id, char from, char to) // 打印移動方式：編號，從哪個盤子移動到哪個盤子 { printf (\"step %d: move %d from %c->%c\\n\", ++cnt, id, from, to); } void hanoi(int n, char x, char y, char z) { if(n == 0)//注意遞歸的出口，不然就是死遞歸了 return; hanoi(n - 1, x, z, y); //將n-1個在x柱子上的盤子通過z這個柱子移動到y這個柱子上。 move(n, x, z); hanoi(n - 1, y, x, z); //將n-1個在y柱子上的盤子通過x這個柱子移動到z這個柱子上。 } int main() { int n; cnt = 0; scanf (\"%d\", &amp;n); hanoi(n, 'A', 'B', 'C'); return 0; } the positive number separated into vectorint n = 12345678; deque &lt;int> dq; while (n > 0) { dq.push_front(n%10); n /= 10; } //check range if( ans > INT_MAX/10 || ans == INT_MAX/10 &amp;&amp; n > INT_MAX %10) 名詞the smallest in lexicographical order最小字典序","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"}]},{"title":"1413. Minimum Value to Get Positive Step by Step Sum","slug":"Leetcode/1413_Minimum Value to Get Positive Step by Step Sum","date":"2020-09-29T08:00:00.000Z","updated":"2020-09-29T07:58:00.066Z","comments":true,"path":"2020/09/29/leetcode/1413-minimum-value-to-get-positive-step-by-step-sum/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/29/leetcode/1413-minimum-value-to-get-positive-step-by-step-sum/","excerpt":"","text":"Link: https://leetcode.com/problems/minimum-value-to-get-positive-step-by-step-sum/ Given an array of integers nums, you start with an initial positive value startValue. In each iteration, you calculate the step by step sum of startValue plus elements in nums (from left to right). Return the minimum positive value of startValue such that the step by step sum is never less than 1. Example 1: Input: nums = [-3,2,-3,4,2] Output: 5 Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1. step by step sum startValue = 4 | startValue = 5 | nums (4 -3 ) = 1 | (5 -3 ) = 2 | -3 (1 +2 ) = 3 | (2 +2 ) = 4 | 2 (3 -3 ) = 0 | (4 -3 ) = 1 | -3 (0 +4 ) = 4 | (1 +4 ) = 5 | 4 (4 +2 ) = 6 | (5 +2 ) = 7 | 2 Example 2: Input: nums = [1,2] Output: 1 Explanation: Minimum start value should be positive. Example 3: Input: nums = [1,-2,-3] Output: 5 Constraints: 1 &lt;= nums.length &lt;= 100 -100 &lt;= nums[i] &lt;= 100 題目翻譯: 選擇一個 startvalue 而這個值在跟陣列的從頭到尾的元素相加時不能小於 1。 startvalue 至少要是正數。 程式思路: 很 easy 的題目。 class Solution { public: int minStartValue(vector&lt;int>&amp; nums) { int x = 0, step_min = 0; for(auto it : nums) { x += it; if(step_min > x) step_min = x; } return (step_min >= 0) ? 1 : 1 - step_min; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1403. Minimum Subsequence in Non-Increasing Order","slug":"Leetcode/1403_Minimum Subsequence in Non-Increasing Order","date":"2020-09-29T07:00:00.000Z","updated":"2020-09-29T07:23:24.354Z","comments":true,"path":"2020/09/29/leetcode/1403-minimum-subsequence-in-non-increasing-order/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/29/leetcode/1403-minimum-subsequence-in-non-increasing-order/","excerpt":"","text":"Link: https://leetcode.com/problems/minimum-subsequence-in-non-increasing-order/ Given the array nums, obtain a subsequence of the array whose sum of elements is strictly greater than the sum of the non included elements in such subsequence. If there are multiple solutions, return the subsequence with minimum size and if there still exist multiple solutions, return the subsequence with the maximum total sum of all its elements. A subsequence of an array can be obtained by erasing some (possibly zero) elements from the array. Note that the solution with the given constraints is guaranteed to be unique. Also return the answer sorted in non-increasing order. Example 1: Input: nums = [4,3,10,9,8] Output: [10,9] Explanation: The subsequences [10,9] and [10,8] are minimal such that the sum of their elements is strictly greater than the sum of elements not included, however, the subsequence [10,9] has the maximum total sum of its elements. Example 2: Input: nums = [4,4,7,6,7] Output: [7,7,6] Explanation: The subsequence [7,7] has the sum of its elements equal to 14 which is not strictly greater than the sum of elements not included (14 = 4 + 4 + 6). Therefore, the subsequence [7,6,7] is the minimal satisfying the conditions. Note the subsequence has to returned in non-decreasing order. Example 3: Input: nums = [6] Output: [6] Constraints: 1 &lt;= nums.length &lt;= 500 1 &lt;= nums[i] &lt;= 100 題目翻譯: 就是在陣列中取最少的元素，而這些被選重的元素總和必須大於其他元素合。 程式思路: 很 easy 的題目。先把陣列排過一遍，然後計算總合，在慢慢扣掉元素值，即是答案。 class Solution { public: vector&lt;int> minSubsequence(vector&lt;int>&amp; nums) { sort(nums.begin(),nums.end(),std::greater&lt;int>()); auto sum = std::accumulate(nums.begin(), nums.end(), 0); int dsum = 0,i; for(i = 0; i &lt; nums.size(); i++) { if(sum &lt; dsum) break; sum -= nums[i]; dsum += nums[i]; } return vector&lt;int> (nums.begin(),nums.begin() + i); } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"algorithm - test2","slug":"algorithm_test/test2","date":"2020-09-28T10:32:00.000Z","updated":"2020-09-28T10:32:17.405Z","comments":true,"path":"2020/09/28/algorithm-test/test2/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/28/algorithm-test/test2/","excerpt":"","text":"Question輸入一個金額 dst，列出最佳找法。 Anwser程式思路: 用 BFS 直接展開解 #include &lt;iostream> #include &lt;queue> #include &lt;vector> using namespace std; void printpath(vector&lt;int>&amp; path) { int size = path.size(); for (int i = 1; i &lt; size; i++) { cout &lt;&lt; path[i] - path[i - 1] &lt;&lt; \" \"; } cout &lt;&lt; \" use \" &lt;&lt; size - 1 &lt;&lt; \" coins\"; cout &lt;&lt; endl; } int isNotVisited(int x, vector&lt;int>&amp; path) { int size = path.size(); for (int i = 0; i &lt; size; i++) if (path[i] == x) return 0; return 1; } int solution(int dst) { int coin[3] = { 1,5,10}; int ways = 0; vector&lt;int> visited; vector&lt;int> path; queue &lt; vector&lt;int> > q; path.push_back(0); q.push(path); while (!q.empty()) { path = q.front(); q.pop(); int last = path[path.size() - 1]; if (last == dst) { printpath(path); ways++; break; } for (int i = 0; i &lt; 3; i++) { int sum = coin[i] + last; if (sum > dst) { break; } if (isNotVisited(sum, path)) { vector&lt;int> newpath(path); newpath.push_back(sum); q.push(newpath); } } } return ways; } #define TEST(x) printf(\"------------\\n\",x,solution(x)); int main(int argc, char* argv[]) { TEST(13); TEST(16); TEST(23); return 0; } Result1 1 1 10 use 4 coins ------------ 1 5 10 use 3 coins ------------ 1 1 1 10 10 use 5 coins ------------","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://tsaiyuyan.github.io/categories/Exercise/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"}]},{"title":"algorithm - test1","slug":"algorithm_test/test1","date":"2020-09-27T07:00:00.000Z","updated":"2020-09-28T07:59:34.395Z","comments":true,"path":"2020/09/27/algorithm-test/test1/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/27/algorithm-test/test1/","excerpt":"","text":"QuestionGiven a string with “a~z” and “&lt;” that represent you type the keyboard (“&lt;” means backspace). For example, “abc&lt;&lt;dd&lt;&lt;” represents “a”, and “zzz&lt;&lt;&lt;” represents “” 不會出現刪到空格的情形，例如 “a&lt;&lt;”（我猜實際面試的時候這問題要你自己問） 基本 - Implement a functionbool equal(string, string) that whether the two strings are equal. 延伸 1 - Can you avoid using extra O(n) space? 延伸 2 - Can you avoid using extra O(n) space and avoid modifying the input string? Anwser程式思路: 先做好一個對照組，用 deque 做方便後續驗證，字串如果從頭掃到尾變數會太大，所以這次的兩個字串應該從尾巴開始往頭掃。兩個字串個別用兩個變數作筆記， an,bn 為記錄 ‘-‘的數量, ap,bp 為紀錄目前掃到哪個位置。 int an = 0, bn = 0; int ap = a.length() - 1, bp = b.length() - 1; #include &lt;stdio.h> #include &lt;deque> #include &lt;string> #include &lt;iostream> using namespace std; string func(string input) { std::deque&lt;char> q; for (auto it : input) { if (it != '&lt;') q.push_back(it); else if (!q.empty()) q.pop_back(); } //out &lt;&lt; input &lt;&lt; \" >> \" &lt;&lt; string(q.begin(), q.begin()).c_str() &lt;&lt; endl; return string(q.begin(), q.end()); } bool equal(string a, string b) { return !func(a).compare(func(b)); } bool equal2(string a, string b) { int an = 0, bn = 0; int ap = a.length() - 1, bp = b.length() - 1; while (ap >= 0 &amp;&amp; bp >= 0) { //value compare if (a[ap] != '&lt;' &amp;&amp; b[bp] != '&lt;') { if ((an == 0) &amp;&amp; (bn == 0)) { if (a[ap] != b[bp]) return false; else ap--, bp--; continue; } } // symbol or letter? if (a[ap] == '&lt;') an++, ap--; else if (an > 0) ap--, an--; if (b[bp] == '&lt;') bn++, bp--; else if (bn > 0) ap--, bn--; } //why break? if (ap != bp) { //final while (bp >= 0) { if (b[bp] == '&lt;') bn++, bp--; else //letter { if (bn > 0) bp--, bn--; else break; } } while (ap >= 0) { if (a[ap] == '&lt;') an++, ap--; else //letter { if (an > 0) ap--, an--; else break; } } } return (ap == bp) ? true : false; } #define YTEST PTEST #define PRINTF(a,b) printf(#a\" \"#b\" is equal? %s\", equal(a, b) ? \"yes\" : \"no\"); printf( \" %s\\n\", equal2(a, b) ? \"yes\" : \"no\"); #define PTEST(a,b) printf(#a\" \"#b\" is pass? %s\\n\", (equal2(a, b) == equal(a,b)) ? \"yes\" : \"no\"); int main() { YTEST(\"aab&lt;c&lt;&lt;dd&lt;\", \"bazzb&lt;zz&lt;&lt;&lt;&lt;\"); YTEST(\"aab&lt;&lt;&lt;\", \"bbb&lt;&lt;&lt;&lt;\"); YTEST(\"abc\", \"abc\"); YTEST(\"abc\", \"abc&lt;\"); YTEST(\"abc\", \"&lt;abc\"); YTEST(\"abc&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\", \"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;\"); YTEST(\"&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;abc&lt;&lt;\", \"a\"); return 0; }","categories":[{"name":"Exercise","slug":"Exercise","permalink":"https://tsaiyuyan.github.io/categories/Exercise/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"}]},{"title":"1122. Relative Sort Array","slug":"Leetcode/1122_Relative Sort Array","date":"2020-09-26T09:30:00.000Z","updated":"2020-09-28T07:48:37.835Z","comments":true,"path":"2020/09/26/leetcode/1122-relative-sort-array/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/26/leetcode/1122-relative-sort-array/","excerpt":"","text":"Given two arrays arr1 and arr2, the elements of arr2 are distinct, and all elements in arr2 are also in arr1. Sort the elements of arr1 such that the relative ordering of items in arr1 are the same as in arr2. Elements that don’t appear in arr2 should be placed at the end of arr1 in ascending order. Example 1: Input: arr1 = [2,3,1,3,2,4,6,7,9,2,19], arr2 = [2,1,4,3,9,6] Output: [2,2,2,1,4,3,3,9,6,7,19] Constraints: arr1.length, arr2.length &lt;= 1000 0 &lt;= arr1[i], arr2[i] &lt;= 1000 Each arr2[i] is distinct. Each arr2[i] is in arr1. 題目翻譯: 讓 arr1 的排列類似於 arr2。但如果 arr1 的元素沒在 arr2 之中，則放到最後麵，以遞升來排序。 程式思路: 我們可以利用壓縮的概念來做，先算出 arr2 的元素在 arr1 用了幾個，在一口氣解壓縮，串上 others 的元素，代碼如下。 class Solution { public: vector&lt;int> relativeSortArray(vector&lt;int>&amp; arr1, vector&lt;int>&amp; arr2) { vector&lt;int> result; vector&lt;int> others; vector&lt;int> frq (arr2.size(),0); int i,j; for(i = 0;i &lt; arr1.size();i++){ for(j = 0;j &lt; arr2.size();j++){ if(arr1[i]==arr2[j]){ //compression frq[j]++; arr1[i] = -1; break; } } if(arr1[i]>=0) others.push_back(arr1[i]); } //uncompression for(j = 0;j&lt;arr2.size();j++){ for(i =0;i&lt;frq[j];i++) result.push_back(arr2[j]); } std::sort(others.begin(), others.end(), std::less&lt;int>()); for(auto it : others) result.push_back(it); return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1512. Number of Good Pairs","slug":"Leetcode/1512_Number of Good Pairs","date":"2020-09-26T08:00:00.000Z","updated":"2020-09-28T07:49:46.118Z","comments":true,"path":"2020/09/26/leetcode/1512-number-of-good-pairs/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/26/leetcode/1512-number-of-good-pairs/","excerpt":"","text":"Link: https://leetcode.com/problems/number-of-good-pairs/ Given an array of integers nums. A pair (i,j) is called good if nums[i] == nums[j] and i &lt; j. Return the number of good pairs. Example 1: Input: nums = [1,2,3,1,1,3] Output: 4 Explanation: There are 4 good pairs (0,3), (0,4), (3,4), (2,5) 0-indexed. Example 2: Input: nums = [1,1,1,1] Output: 6 Explanation: Each pair in the array are good. Example 3: Input: nums = [1,2,3] Output: 0 Constraints: 1 &lt;= nums.length &lt;= 100 1 &lt;= nums[i] &lt;= 100 題目翻譯: keyword nums[i] == nums[j] and i &lt; j 程式思路: 很 easy 的題目，nums[i] == nums[j] and i &lt; j 照這個條件做就好。 class Solution { public: int numIdenticalPairs(vector&lt;int>&amp; nums) { int ret = 0; for(int j = 1;j &lt; nums.size();j++) { for(int i = 0;i &lt; j; i++) { if( nums[i] == nums[j]) ret++; } } return ret; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1528. Shuffle String","slug":"Leetcode/1528_Shuffle String","date":"2020-09-26T07:30:00.000Z","updated":"2020-10-14T01:32:54.434Z","comments":true,"path":"2020/09/26/leetcode/1528-shuffle-string/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/26/leetcode/1528-shuffle-string/","excerpt":"","text":"Given a string s and an integer array indices of the same length. The string s will be shuffled such that the character at the ith position moves to indices[i] in the shuffled string. Return the shuffled string. Example 1: Input: s = \"codeleet\", indices = [4,5,6,7,0,2,1,3] Output: \"leetcode\" Explanation: As shown, \"codeleet\" becomes \"leetcode\" after shuffling. Example 2: Input: s = \"abc\", indices = [0,1,2] Output: \"abc\" Explanation: After shuffling, each character remains in its position. Example 3: Input: s = \"aiohn\", indices = [3,1,4,2,0] Output: \"nihao\" Example 4: Input: s = \"aaiougrt\", indices = [4,0,2,6,7,3,1,5] Output: \"arigatou\" Example 5: Input: s = \"art\", indices = [1,0,2] Output: \"rat\" Constraints: s.length == indices.length == n 1 &lt;= n &lt;= 100 s contains only lower-case English letters. 0 &lt;= indices[i] &lt; n All values of indices are unique (i.e. indices is a permutation of the integers from 0 to n - 1). 題目翻譯: X 程式思路: 把字串重組根據vector&lt;int&gt;&amp; indices. class Solution { public: string restoreString(string s, vector&lt;int>&amp; indices) { string result(s); for(int i = 0;i &lt; indices.size(); i++) { result[indices[i]] = s[i]; } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1431. Kids With the Greatest Number of Candies","slug":"Leetcode/1431_Kids With the Greatest Number of Candies","date":"2020-09-26T07:00:00.000Z","updated":"2020-09-28T07:49:55.408Z","comments":true,"path":"2020/09/26/leetcode/1431-kids-with-the-greatest-number-of-candies/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/26/leetcode/1431-kids-with-the-greatest-number-of-candies/","excerpt":"","text":"Link: https://leetcode.com/problems/kids-with-the-greatest-number-of-candies/ Given the array candies and the integer extraCandies, where candies[i] represents the number of candies that the ith kid has. For each kid check if there is a way to distribute extraCandies among the kids such that he or she can have the greatest number of candies among them. Notice that multiple kids can have the greatest number of candies. Example 1: Input: candies = [2,3,5,1,3], extraCandies = 3 Output: [true,true,true,false,true] Explanation: Kid 1 has 2 candies and if he or she receives all extra candies (3) will have 5 candies --- the greatest number of candies among the kids. Kid 2 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. Kid 3 has 5 candies and this is already the greatest number of candies among the kids. Kid 4 has 1 candy and even if he or she receives all extra candies will only have 4 candies. Kid 5 has 3 candies and if he or she receives at least 2 extra candies will have the greatest number of candies among the kids. Example 2: Input: candies = [4,2,1,1,2], extraCandies = 1 Output: [true,false,false,false,false] Explanation: There is only 1 extra candy, therefore only kid 1 will have the greatest number of candies among the kids regardless of who takes the extra candy. Example 3: Input: candies = [12,1,12], extraCandies = 10 Output: [true,false,true] Constraints: 2 &lt;= candies.length &lt;= 100 1 &lt;= candies[i] &lt;= 100 1 &lt;= extraCandies &lt;= 50 題目翻譯: 就檢查小朋友拿到額外的糖果後，檢查是不是全部小朋友裡面最多的 程式思路: 先找出最大值，然後小朋友拿的加上額外的比最大值大就是答案。 class Solution { public: vector&lt;bool> kidsWithCandies(vector&lt;int>&amp; candies, int extraCandies) { vector&lt;bool> result; auto it = max_element(std::begin(candies), std::end(candies)); for(int i = 0;i &lt; candies.size();i++) { if(candies[i] + extraCandies >= *it ) result.push_back(true); else result.push_back(false); } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1480. Running Sum of 1d Array","slug":"Leetcode/1480_Running Sum of 1d Array","date":"2020-09-26T06:00:00.000Z","updated":"2020-10-05T03:08:52.981Z","comments":true,"path":"2020/09/26/leetcode/1480-running-sum-of-1d-array/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/26/leetcode/1480-running-sum-of-1d-array/","excerpt":"","text":"Link: https://leetcode.com/problems/running-sum-of-1d-array/ Given an array nums. We define a running sum of an array as runningSum[i] = sum(nums[0]…nums[i]). Return the running sum of nums. Example 1: Input: nums = [1,2,3,4] Output: [1,3,6,10] Explanation: Running sum is obtained as follows: [1, 1+2, 1+2+3, 1+2+3+4]. Example 2: Input: nums = [1,1,1,1,1] Output: [1,2,3,4,5] Explanation: Running sum is obtained as follows: [1, 1+1, 1+1+1, 1+1+1+1, 1+1+1+1+1]. Example 3: Input: nums = [3,1,2,10,1] Output: [3,4,6,16,17] Constraints: 1 &lt;= nums.length &lt;= 1000 -10^6 &lt;= nums[i] &lt;= 10^6 題目翻譯: 陣列加加 程式思路: 很 easy class Solution { public: vector&lt;int> runningSum(vector&lt;int>&amp; nums) { int acc = 0; for(int i = 0; i &lt; nums.size(); i++) acc = nums[i] += acc; return nums; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1470. Shuffle the Array","slug":"Leetcode/1470_Shuffle the Array","date":"2020-09-26T05:41:00.000Z","updated":"2020-09-28T07:49:47.486Z","comments":true,"path":"2020/09/26/leetcode/1470-shuffle-the-array/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/26/leetcode/1470-shuffle-the-array/","excerpt":"","text":"Link: https://leetcode.com/problems/shuffle-the-array/ Given the array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn]. Return the array in the form [x1,y1,x2,y2,...,xn,yn]. Example 1: Input: nums = [2,5,1,3,4,7], n = 3 Output: [2,3,5,4,1,7] Explanation: Since x1=2, x2=5, x3=1, y1=3, y2=4, y3=7 then the answer is [2,3,5,4,1,7]. Example 2: Input: nums = [1,2,3,4,4,3,2,1], n = 4 Output: [1,4,2,3,3,2,4,1] Example 3: Input: nums = [1,1,2,2], n = 2 Output: [1,2,1,2] 題目翻譯: 排陣列 程式思路: 很 easy class Solution { public: vector&lt;int> shuffle(vector&lt;int>&amp; nums, int n) { vector&lt;int> result; int size = nums.size()/2; for(int i = 0;i &lt; size;i++) { result.push_back(nums[i]); result.push_back(nums[size + i]); } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1313. Decompress Run-Length Encoded List","slug":"Leetcode/1313_Decompress Run-Length Encoded List","date":"2020-09-26T03:47:00.000Z","updated":"2020-09-28T07:49:54.308Z","comments":true,"path":"2020/09/26/leetcode/1313-decompress-run-length-encoded-list/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/26/leetcode/1313-decompress-run-length-encoded-list/","excerpt":"","text":"Link: https://leetcode.com/problems/decompress-run-length-encoded-list/ We are given a list nums of integers representing a list compressed with run-length encoding. Consider each adjacent pair of elements [freq, val] = [nums[2i], nums[2i+1]] (with i &gt;= 0). For each such pair, there are freq elements with value val concatenated in a sublist. Concatenate all the sublists from left to right to generate the decompressed list. Return the decompressed list. Example 1: Input: nums = [1,2,3,4] Output: [2,4,4,4] Explanation: The first pair [1,2] means we have freq = 1 and val = 2 so we generate the array [2]. The second pair [3,4] means we have freq = 3 and val = 4 so we generate [4,4,4]. At the end the concatenation [2] + [4,4,4] is [2,4,4,4]. Example 2: Input: nums = [1,1,2,3] Output: [1,3,3] Constraints: 2 &lt;= nums.length &lt;= 100 nums.length % 2 == 0 1 &lt;= nums[i] &lt;= 100 題目翻譯: 解壓縮。 程式思路: 很 easy class Solution { public: vector&lt;int> decompressRLElist(vector&lt;int>&amp; nums) { vector&lt;int> result; for(int i = 0; i &lt; nums.size(); i++) { if( i%2 == 1 ) { for(int j = 0; j &lt; nums[i-1]; j++) { result.push_back(nums[i]); } } } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"FreeRadius Server and Client Note","slug":"FreeRadius Server and Client Note","date":"2020-09-21T02:00:00.000Z","updated":"2020-12-30T05:10:30.802Z","comments":true,"path":"2020/09/21/freeradius-server-and-client-note/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/21/freeradius-server-and-client-note/","excerpt":"","text":"About FreeRADIUSThe FreeRADIUS Server Project is a high performance and highly configurable multi-protocol policy server, supporting RADIUS, DHCPv4 and VMPS. Using RADIUS allows authentication and authorization for a network to be centralized, and minimizes the number of changes that have to be done when adding or deleting new users to a network. FreeRADIUS can authenticate users on systems such as 802.1x (WiFi), dialup, PPPoE, VPN’s, VoIP, and many others. It supports back-end databases such as MySQL, PostgreSQL, Oracle, Microsoft Active Directory, Redis, OpenLDAP. It is used daily to authenticate the Internet access for hundreds of millions of people, in sites ranging from 10 to 10 million+ users. wiki : wikipedia.org/wiki/FreeRADIUS freeradius/freeradius-server docker : [https://hub.docker.com/r/freeradius/freeradius-server/] Server ver : 3.0.21 Client ver : 1.1.7 FreeRadius-ServerUsing docker fastly build Server for test$docker run -it --rm --name radius-server -p 1812-1813:1812-1813/udp -v ~/Desktop/radius_shared:/shared freeradius/freeradius-server bash -l 進入 docker# 更新 $apt update && apt install vim # 編輯身分驗證 $vim /etc/raddb/users bob Cleartext-Password := \"test\" Reply-Message := \"Hello, %{User-Name}\" # 編輯帳戶 $vim /etc/raddb/clients.conf client dockernet { ipaddr = 172.18.0.0/24 secret = testing123 } # 啟動 Server $ ./docker-entrypoint.sh -X (-X : debug mode 可以不加) Testing the configuration1. radtest$ radtest bob test 127.0.0.1 0 testing123 Sent Access-Request Id 50 from 0.0.0.0:55240 to 127.0.0.1:1812 length 73 User-Name = \"bob\" User-Password = \"test\" NAS-IP-Address = 172.18.0.2 NAS-Port = 0 Message-Authenticator = 0x00 Cleartext-Password = \"test\" Received Access-Accept Id 50 from 127.0.0.1:1812 to 127.0.0.1:55240 length 32 Reply-Message = \"Hello, bob\" 2. radclient$ echo \"User-Name=bob,User-Password=test\" | radclient 172.18.0.2 auth testing123 -x Sent Access-Request Id 190 from 0.0.0.0:40644 to 172.18.0.2:1812 length 43 User-Name = \"bob\" User-Password = \"test\" Cleartext-Password = \"test\" Received Access-Accept Id 190 from 172.18.0.2:1812 to 172.18.0.2:40644 length 32 Reply-Message = \"Hello, bob\" FreeRaduis-clientDownload website: [https://freeradius.org/ftp/pub/freeradius/] $ tree . |-- etc | `-- radiusclient | |-- dictionary | |-- dictionary.ascend | |-- dictionary.compat | |-- dictionary.merit | |-- dictionary.sip | |-- issue | |-- port-id-map | |-- radiusclient.conf | `-- servers |-- include | `-- freeradius-client.h |-- lib | |-- libfreeradius-client.la | |-- libfreeradius-client.so -> libfreeradius-client.so.2.0.0 | |-- libfreeradius-client.so.2 -> libfreeradius-client.so.2.0.0 | `-- libfreeradius-client.so.2.0.0 `-- sbin |-- login.radius |-- radacct |-- radembedded |-- radexample |-- radiusclient |-- radlogin `-- radstatus execute radacct(not use) radexample(not use) radlogin(not use) radembedded(not use) radiusclient radstatus(not use) 1.radiusclient$radiusclient -h radiusclient: invalid option -- 'h' usage: radiusclient [-f config_file] [-p nas_port] [-s | [-a] a1=v1 [a2=v2[...[aN=vN]...]]] $radiusclient -f /usr/etc/radiusclient/radiusclient.conf -p 1812 User-Name=bob Password=test Reply-Message = 'Hello, bob' $ echo $?","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"note","slug":"note","permalink":"https://tsaiyuyan.github.io/tags/note/"},{"name":"FreeRadius","slug":"FreeRadius","permalink":"https://tsaiyuyan.github.io/tags/FreeRadius/"}]},{"title":"Openssl - Certificate expiration check","slug":"Openssl - Certificate expiration check","date":"2020-09-03T02:00:00.000Z","updated":"2020-09-30T03:33:21.656Z","comments":true,"path":"2020/09/03/openssl-certificate-expiration-check/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/03/openssl-certificate-expiration-check/","excerpt":"","text":"Openssl CA expiration check scriptTest enviroment docker run -it ubuntu:20.04 bash -l apt update &amp;&amp; apt install openssl Edit script vim ca_check.sh #!/bin/bash if [ $# -eq 0 ]; then echo \"No arguments supplied\" exit fi ca=$1 if [ ! -f \"$ca\" ]; then echo \"File $ca not exists.\" exit fi if openssl x509 -in $ca -noout -fingerprint -inform pem >/dev/null 2>&amp;1; then format=\"pem\" elif openssl x509 -in $ca -noout -fingerprint -inform der 2>&amp;1 >/dev/null 2>&amp;1; then format=\"der\" elif openssl x509 -in $ca -noout -fingerprint -inform cer 2>&amp;1 >/dev/null 2>&amp;1; then format=\"cer\" else echo \"$ca is unknown type.\" exit fi #echo \"format=$format\" if openssl x509 -checkend 259200 -noout -in $ca -inform $format; then echo \"Certificate is good for another day!\" else echo \"Certificate has expired or will do so within 30 days!(or is invalid/not found)\" fi Test$sh ./ca_check xxxxx.crt Certificate is good for another day! $sh ./ca_check ooooo.pem Certificate has expired or will do so within 30 days!(or is invalid/not found) 用 snmpd 來管理 CA 是否過期用 docker 做個 snmpd server 測試用 Link : https://hub.docker.com/r/polinux/snmpd vim /tmp/snmpd.conf syslocation Taiwan syscontact XXXXXXXXXXX@gmail.com rouser yuyan priv rwuser wyuyan createUser yuyan MD5 987654321 DES 123456789 createUser wyuyan MD5 987654321 DES 123456789 agentAddress udp:0.0.0.0:161 master agentx agentxsocket tcp:localhost:1610 extend .1.3.6.1.4.1.2021.51 ps /bin/ps extend .1.3.6.1.4.1.2021.52 ca_check /bin/sh /tmp/ca_check.sh 啟動 docker docker run --rm -it --name snmpd -p161:161/udp -v /tmp/snmpd.conf:/etc/snmp/snmpd.conf polinux/snmpd -c /etc/snmp/snmpd.conf -Le Test command example yuyan : 是唯讀使用者並且有 private 權限 wyuyan : 是讀寫使用者並沒有 private 權限 test command like following $snmpwalk -v3 -u yuyan -l authPriv -a MD5 -A \"987654321\" -x DES -X 123456789 192.168.7.20 $snmpwalk -v3 -u wyuyan -l authNoPriv -a MD5 -A \"987654321\" -x DES -X 123456789 192.168.7.20 .1.3.6.1.4.1.2021.51 $snmpwalk -v3 -u yuyan -l authPriv -a MD5 -A \"987654321\" -x DES -X 123456789 192.168.7.20 .1.3.6.1.4.1.2021 OpenWrt pre-build net-snmpd OpenWrt 有提供 net-snmpd 的模組使用， agent/extend : 要有這個 conf 才能使用 extend 關鍵字，extend 可用於執行 shell script 或是一般 command。 --with-openssl=internal : 要打開這個 option snmpdV3 才能使用 git diff Makefile diff --git a/net/net-snmp/Makefile b/net/net-snmp/Makefile index 3446d151..02c65e7e 100644 --- a/net/net-snmp/Makefile +++ b/net/net-snmp/Makefile @@ -137,6 +137,7 @@ SNMP_MIB_MODULES_INCLUDED = \\ ucd-snmp/vmstat \\ util_funcs \\ utilities/execute \\ + agent/extend \\ SNMP_MIB_MODULES_EXCLUDED = \\ agent_mibs \\ @@ -180,7 +181,7 @@ CONFIGURE_ARGS += \\ --with-mib-modules=\"$(SNMP_MIB_MODULES_INCLUDED)\" \\ --with-out-transports=\"$(SNMP_TRANSPORTS_EXCLUDED)\" \\ --with-transports=\"$(SNMP_TRANSPORTS_INCLUDED)\" \\ - --without-openssl \\ + --with-openssl=internal \\ --without-libwrap \\ --without-rpm \\ --without-zlib \\","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"openssl","slug":"openssl","permalink":"https://tsaiyuyan.github.io/tags/openssl/"},{"name":"snmpd","slug":"snmpd","permalink":"https://tsaiyuyan.github.io/tags/snmpd/"},{"name":"openwrt","slug":"openwrt","permalink":"https://tsaiyuyan.github.io/tags/openwrt/"}]},{"title":"OpenWRT snmpd v3 - snmpwalk authpriv Decryption error","slug":"OpenWRT snmpd v3 - snmpwalk authpriv Decryption error","date":"2020-09-01T02:00:00.000Z","updated":"2020-09-30T03:33:20.014Z","comments":true,"path":"2020/09/01/openwrt-snmpd-v3-snmpwalk-authpriv-decryption-error/","link":"","permalink":"https://tsaiyuyan.github.io/2020/09/01/openwrt-snmpd-v3-snmpwalk-authpriv-decryption-error/","excerpt":"","text":"snmp.conf 設定檔 vim /etc/snmp/snmp.conf createUser user MD5 \"987654321\" DES \"123456789\" rouser user priv rouser user2 agentAddress udp:0.0.0.0:161 exec .1.3.6.1.4.1.2021.51 ps /bin/ps exec .1.3.6.1.4.1.2021.52 openssl /usr/bin/openssl x509 -in /etc/uhttpd.crt -noout -dates -fingerprint -inform der snmpwalk 測試 openWRT 端，執行snmpd -f -Le 測試端，執行snmpwalk -v3 -u user2 -l authNoPriv -a MD5 -A &quot;987654321&quot; -x DES -X 123456789 192.168.7.20，可正常運行 測試端，執行snmpwalk -v3 -u user -l authPriv -a MD5 -A &quot;987654321&quot; -x DES -X 123456789 192.168.7.20 .1.3.6.1.4.1.2021.52 iso.3.6.1.4.1.2021.52.1.0 = INTEGER: 1 iso.3.6.1.4.1.2021.52.2.1.2.8.99.97.95.99.104.101.99.107 = STRING: \"/bin/sh\" iso.3.6.1.4.1.2021.52.2.1.3.8.99.97.95.99.104.101.99.107 = STRING: \"/tmp/ca_check.sh\" iso.3.6.1.4.1.2021.52.2.1.4.8.99.97.95.99.104.101.99.107 = \"\" iso.3.6.1.4.1.2021.52.2.1.5.8.99.97.95.99.104.101.99.107 = INTEGER: 5 iso.3.6.1.4.1.2021.52.2.1.6.8.99.97.95.99.104.101.99.107 = INTEGER: 1 iso.3.6.1.4.1.2021.52.2.1.7.8.99.97.95.99.104.101.99.107 = INTEGER: 1 iso.3.6.1.4.1.2021.52.2.1.20.8.99.97.95.99.104.101.99.107 = INTEGER: 4 iso.3.6.1.4.1.2021.52.2.1.21.8.99.97.95.99.104.101.99.107 = INTEGER: 1 iso.3.6.1.4.1.2021.52.3.1.1.8.99.97.95.99.104.101.99.107 = STRING: \"/bin/sh: can't open '/tmp/ca_check.sh'\" iso.3.6.1.4.1.2021.52.3.1.2.8.99.97.95.99.104.101.99.107 = STRING: \"/bin/sh: can't open '/tmp/ca_check.sh'\" iso.3.6.1.4.1.2021.52.3.1.3.8.99.97.95.99.104.101.99.107 = INTEGER: 1 iso.3.6.1.4.1.2021.52.3.1.4.8.99.97.95.99.104.101.99.107 = INTEGER: 2 iso.3.6.1.4.1.2021.52.4.1.2.8.99.97.95.99.104.101.99.107.1 = STRING: \"/bin/sh: can't open '/tmp/ca_check.sh'\" 發生問題snmpwalk: Unknown engine ID or snmpwalk: Decryption error Use option --with-openssl=internal vim net-snmp/Makefile diff --git a/net/net-snmp/Makefile b/net/net-snmp/Makefile index 3446d151..9728478c 100644 --- a/net/net-snmp/Makefile +++ b/net/net-snmp/Makefile @@ -137,6 +137,7 @@ SNMP_MIB_MODULES_INCLUDED = \\ ucd-snmp/vmstat \\ util_funcs \\ utilities/execute \\ +# agent/extend \\ SNMP_MIB_MODULES_EXCLUDED = \\ agent_mibs \\ @@ -180,7 +181,7 @@ CONFIGURE_ARGS += \\ --with-mib-modules=\"$(SNMP_MIB_MODULES_INCLUDED)\" \\ --with-out-transports=\"$(SNMP_TRANSPORTS_EXCLUDED)\" \\ --with-transports=\"$(SNMP_TRANSPORTS_INCLUDED)\" \\ - --without-openssl \\ + --with-openssl=internal \\ --without-libwrap \\ --without-rpm \\ --without-zlib \\ 之後重 build, 即可使用 SNMPV3 authPriv。 reference : snmpwalk: Decryption error (snmp v3) (openWRT) compile error : snmp v3 with openssl missing libcrypto.so.1.0.0","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"net-snmp","slug":"net-snmp","permalink":"https://tsaiyuyan.github.io/tags/net-snmp/"},{"name":"snmp","slug":"snmp","permalink":"https://tsaiyuyan.github.io/tags/snmp/"},{"name":"OpenWRT","slug":"OpenWRT","permalink":"https://tsaiyuyan.github.io/tags/OpenWRT/"}]},{"title":"Ubuntu 使用 SocksV5 筆記","slug":"Linux/Ubuntu 使用 SocksV5 筆記","date":"2020-07-24T02:00:00.000Z","updated":"2020-12-08T09:57:27.513Z","comments":true,"path":"2020/07/24/linux/ubuntu-shi-yong-socksv5-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2020/07/24/linux/ubuntu-shi-yong-socksv5-bi-ji/","excerpt":"","text":"看 proxy 時，看到除了HTTP/HTTPS代理還有另外的代理方法，SOCKS 是相當於 TCP/IP 層的代理，V5版本就可以UDP/TCP 做代理了，也看到中國那邊之前也是用類似的socks 協定去做翻牆動作。他們還在github 討論怎麼才不會被翻牆軟體偵測到www，被抓到會被叫去喝茶。 protocal: RFC 1928 dante-serverEnviroment using docker ubuntu:18.04 FROM ubuntu:18.04 MAINTAINER Yuyan \"yuyan.tsai@advantech.com.tw\" LABEL Description=\"This dockerfile is dante-server test environment\" LABEL Vendor=\"Advantech\" LABEL Version=\"1.0\" # Install libraries RUN apt-get update RUN apt-get upgrade -y RUN apt-get install vim -y RUN apt-get install gcc -y RUN apt-get install make -y RUN apt-get install wget curl -y # auto completion tool RUN apt-get install bash-completion -y # ping tool RUN apt-get install iputils-ping # htop tool (optional) RUN apt-get install htop -y # ifconfig tool RUN apt install net-tools -y # ip, route tool RUN apt install iproute2 -y ENTRYPOINT [\"bash\",\"-l\"] WORKDIR /root Command# apt install $apt install dante-server -y $danted -v # file $less /etc/init.d/danted $vim /etc/danted.conf $cat /var/log/socks.log # test $cat /var/log/socks.log # service operation $service danted start $service danted stop $service danted restart /etc/danted.conf internal: eth0 port = 1080 external: eth0 clientmethod: none socksmethod: none user.privileged: root user.notprivileged: nobody client pass { from: 0.0.0.0/0 to: 0.0.0.0/0 log: error connect disconnect } client block { from: 0.0.0.0/0 to: 0.0.0.0/0 log: connect error } socks pass { from: 0.0.0.0/0 to: 0.0.0.0/0 log: error connect disconnect } socks block { from: 0.0.0.0/0 to: 0.0.0.0/0 log: connect error } proxychains apt install proxychains vim /etc/proxychains.conf proxychains curl https://myexternalip.com/raw # ProxyList format # type host port [user pass] # (values separated by 'tab' or 'blank') # # # Examples: # # socks5 192.168.67.78 1080 lamer secret # http 192.168.89.3 8080 justu hidden # socks4 192.168.1.49 1080 # http 192.168.39.93 8080 # # # proxy types: http, socks4, socks5 # ( auth types supported: \"basic\"-http \"user/pass\"-socks ) # [ProxyList] # add proxy here ... # meanwile # defaults set to \"tor\" socks5 172.18.0.3 1080 Test開啟另一台不同ip的終端，已知dante-server ip為172.18.0.3.port為1080。將委託172.18.0.3作為代理ip。 curl test$curl -x socks5://172.18.0.3:1080 ifconfig.co proxychains testex. proxychain [command] proxychain curl https://myexternalip.com/raw proxychain ~/Desktop/sokit-1.3.1-linux64/sokit","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"note","slug":"note","permalink":"https://tsaiyuyan.github.io/tags/note/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"socks","slug":"socks","permalink":"https://tsaiyuyan.github.io/tags/socks/"}]},{"title":"Ubuntu 使用 docker 筆記_Part2","slug":"Linux/Ubuntu 使用 docker 筆記_Part2","date":"2020-06-19T02:00:00.000Z","updated":"2021-03-18T08:47:47.928Z","comments":true,"path":"2020/06/19/linux/ubuntu-shi-yong-docker-bi-ji-part2/","link":"","permalink":"https://tsaiyuyan.github.io/2020/06/19/linux/ubuntu-shi-yong-docker-bi-ji-part2/","excerpt":"","text":"使用 docker 前，建議可以將使用者加入 docker 群組，可以省去一直打 sudo 的麻煩。 一、安裝 docker安裝指令#Install docker $curl -sSL https://get.docker.com/ | sudo sh #Install docker-compose $sudo curl -L \"https://github.com/docker/compose/releases/download/1.28.5/docker-compose-$(uname -s)-$(uname -m)\" -o /usr/local/bin/docker-compose $sudo chmod +x /usr/local/bin/docker-compose $sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose $docker-compose --version docker-compose version 1.28.5, build 1110ad01 Use docker without sudoreference: How can I use docker without sudo ? # 1.Add the docker group if it doesn't already exist: $sudo groupadd docker groupadd: group 'docker' already exists # 2.Add the connected user \"[USER]\" to the docker group. # $sudo gpasswd -a [USER] docker # Change the user name to match your preferred user if you do not want to use your current user: $sudo gpasswd -a [USER] docker Adding user [USER] to group docker. $newgrp docker $docker run hello-world 二、Use DockerFile example1. vim DockerFile這是一個要 build driver 的範例 # The container download from dockerhub https://hub.docker.com/_/ubuntu/ # which is official ubuntu dockerhub account FROM ubuntu:18.04 #FROM ubuntu:14.04.5 MAINTAINER Yuyan \"yuyan.tsai@advantech.com.tw\" LABEL Description=\"This dockerfile is ubuntu-VCOM building environment\" LABEL Vendor=\"Advantech\" LABEL Version=\"1.0\" VOLUME /root/shared_data # Install libraries RUN apt-get update RUN apt-get upgrade -y RUN apt-get install vim -y RUN apt-get install gcc -y RUN apt-get install make -y RUN apt-get install wget -y RUN apt-get install build-essential -y RUN apt-get install linux-headers-`uname -r` -y; exit 0 RUN apt-get install libssl-dev -y RUN apt-get install dkms -y # auto completion tool RUN apt-get install bash-completion -y # killall tool RUN apt-get install psmisc -y # ping tool RUN apt-get install iputils-ping # htop tool (optional) RUN apt-get install htop -y # add user (optional) RUN apt-get -y install sudo RUN useradd -m user && echo \"user:user\" | chpasswd && adduser user sudo WORKDIR /root note: bash-completion 會有login logout 的問題哦，所以在執行docker 的時候要用 “bash l” 替代 單純的”/bin/bash”。當然也可以用另外的替代方案，進入後下 source /etc/profile.d/bash_completion.sh 讓此套件有效。 2. build container by using Dockerfile#sudo docker build -t [main-resp]/[sub-resp]:[tag] ./ $docker build -t yuyan/build_env:ver1.0 ./ $docker images REPOSITORY TAG IMAGE ID CREATED SIZE yuyan/build_env ver1.0 496420cf7797 3 days ago 465MB ubuntu 18.04 c3c304cb4f22 8 weeks ago 64.2MB hello-world latest bf756fb1ae65 5 months ago 13.3kB ubuntu 14.04.5 132b7427a3b4 3 years ago 188MB 3. run container 有兩種常用的用法，一種是用完即拋，在 docker run 的指令多補個 –rm，在離開 container 後就會，順便把 container 刪掉 # 簡易 $docker run -ti [main-resp]/[sub-resp]:[tag] bash -l or # 進階 $docker run -ti --rm --privileged -v [path_to_folder]:/root/shared_data [main-resp]/[sub-resp]:[tag] bash -l -v: Bind mount a volume. -ti: Allocate a pseudo-tty. + Keep STDIN open even if not attached. --rm: automatically clean up the container and remove the file system when the container exits. --privileged: Give extended privileges to this container (enable access to host OS hardware. ex.insmod) [path_to_folder]: Host OS folder path [main-resp]/[sub-resp]:[tag] : named whatever ex. yuyan/build_env:ver1.0 三、常用指令Run docker service$service docker start List the docker image$docker images Remove docker image$docker rmi [image_id] Remove all the docker images$docker rmi -f $(docker images -q) List the docker container (get container id)$docker ps -a Remove the docker container$docker rm [container ID] Remove all the docker container$docker rm $(docker ps -aq) Build docker image$docker built -t [main-resp]/[sub-resp]:[tag] [PATH_TO_DOCKERFILE] ex. docker build -t yuyan/build_env:ver1.0 ./ Run the docker image$docker run -ti -v [PATH_TO_FOLDER]:/root/shared_data [main-resp]/[sub-resp]:[tag] /bin/bash Save the docker image modification$docker commit -m=\"COMMIT_MESSAGE\" -a=\"AUTHOR\" [container_id] [main-resp]/[sub-resp]:[tag] ex. docker commit -m=\"Update 202006019\" -a=\"yuyan\" [container_id] yuyan/build_env:ver1.1 Restart the stopped docker container$docker start -ai [container_id] or $docker start -ai [container_name] List container$docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES 3307a856267e yuyan/build_env:ver1.0 \"bash -l\" 3 days ago Exited (0) 14 seconds ago trusting_hofstadter","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"note","slug":"note","permalink":"https://tsaiyuyan.github.io/tags/note/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://tsaiyuyan.github.io/tags/docker/"}]},{"title":"Example C code - Multicast","slug":"Example C code - Multicast ","date":"2020-06-13T02:00:00.000Z","updated":"2022-03-07T02:12:26.847Z","comments":true,"path":"2020/06/13/example-c-code-multicast/","link":"","permalink":"https://tsaiyuyan.github.io/2020/06/13/example-c-code-multicast/","excerpt":"","text":"multicast_client.c/* *multicast_client.c - 多播的客戶端 */ #define MCAST_PORT 8888 #define MCAST_ADDR \"224.0.0.88\" #define MCAST_DATA \"BROADCAST TEST DATA\" /*多播發送的數據*/ #define MCAST_INTERVAL 5 /*發送間隔時間*/ int main(int argc, char* argv) { int s; struct sockaddr_in mcast_addr; s = socket(AF_INET, SOCK_DGRAM, 0); /*建立套接字*/ if (s == -1) { perror(\"socket()\"); return -1; } memset(&amp;mcast_addr, 0, sizeof(mcast_addr)); /*初始化IP多播地址為0*/ mcast_addr.sin_family = AF_INET; /*設置協議族類行為AF*/ mcast_addr.sin_addr.s_addr = inet_addr(MCAST_ADDR); /*設置多播IP地址*/ mcast_addr.sin_port = htons(MCAST_PORT); /*設置多播端口*/ /*向多播地址發送數據*/ while (1) { int n = sendto(s, /*套接字描述符*/ MCAST_DATA, /*數據*/ sizeof(MCAST_DATA), /*長度*/ 0, (struct sockaddr*)&amp;mcast_addr, sizeof(mcast_addr)); if (n &lt; 0) { perror(\"sendto()\"); return -2; } sleep(MCAST_INTERVAL); /*等待一段時間*/ } return 0; } multicast_server.c/* *multicast_server.c - 多播服務程序 */ #include &lt;stdio.h> #include &lt;string.h> #include &lt;stdlib.h> #include &lt;unistd.h> #include &lt;fcntl.h> #include &lt;sys/types.h> #include &lt;arpa/inet.h> #include &lt;sys/stat.h> #include &lt;net/if.h> #define MCAST_PORT 8888 #define MCAST_ADDR \"224.0.0.88\" /*一個局部連接多播地址，路由器不進行轉發*/ #define MCAST_INTERVAL 5 /*發送間隔時間*/ #define BUFF_SIZE 256 /*接收緩衝區大小*/ int main(int argc, char* argv[]) { int s; /*套接字文件描述符*/ struct sockaddr_in local_addr; /*本地地址*/ int err = -1; s = socket(AF_INET, SOCK_DGRAM, 0); /*建立套接字*/ if (s == -1) { perror(\"socket()\"); return -1; } /*初始化地址*/ memset(&amp;local_addr, 0, sizeof(local_addr)); local_addr.sin_family = AF_INET; local_addr.sin_addr.s_addr = htonl(INADDR_ANY); local_addr.sin_port = htons(MCAST_PORT); /*綁定socket*/ err = bind(s, (struct sockaddr*)&amp;local_addr, sizeof(local_addr)); if (err &lt; 0) { perror(\"bind()\"); return -2; } /*設置回環許可*/ int loop = 1; err = setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, &amp;loop, sizeof(loop)); if (err &lt; 0) { perror(\"setsockopt():IP_MULTICAST_LOOP\"); return -3; } struct ip_mreq mreq; /*加入廣播組*/ mreq.imr_multiaddr.s_addr = inet_addr(MCAST_ADDR); /*廣播地址*/ mreq.imr_interface.s_addr = htonl(INADDR_ANY); /*網絡接口為默認*/ /*將本機加入廣播組*/ err = setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, &amp;mreq, sizeof(mreq)); if (err &lt; 0) { perror(\"setsockopt():IP_ADD_MEMBERSHIP\"); return -4; } int times = 0; int addr_len = 0; char buff[BUFF_SIZE]; int n = 0; /*循環接收廣播組的消息，5次後退出*/ for (times = 0; times &lt; 5; times++) { addr_len = sizeof(local_addr); memset(buff, 0, BUFF_SIZE); /*清空接收緩衝區*/ /*接收數據*/ n = recvfrom(s, buff, BUFF_SIZE, 0, (struct sockaddr*)&amp;local_addr, &amp;addr_len); if (n == -1) { perror(\"recvfrom()\"); } /*打印信息*/ printf(\"Recv %dst message from server:%s\\n\", times, buff); sleep(MCAST_INTERVAL); } /*退出廣播組*/ err = setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, &amp;mreq, sizeof(mreq)); close(s); return 0; }","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://tsaiyuyan.github.io/categories/C-C/"}],"tags":[]},{"title":"ezio_worklog/YuYan's Uboot 簡易筆記","slug":"ezio_worklog/YuYan's Uboot 簡易筆記","date":"2020-06-01T06:37:27.246Z","updated":"2020-09-21T05:44:38.530Z","comments":true,"path":"2020/06/01/ezio-worklog/yuyan-s-uboot-jian-yi-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2020/06/01/ezio-worklog/yuyan-s-uboot-jian-yi-bi-ji/","excerpt":"","text":"YuYan’s Uboot 簡易筆記uboot command example U-Boot# mii info PHY 0x01: OUI = 0x80017, Model = 0x09, Rev = 0x00, 100baseT, FDX PHY 0x03: OUI = 0x80017, Model = 0x09, Rev = 0x00, 10baseT, HDX U-Boot# mii dump 1 0 0. (3100) -- PHY control register -- (8000:0000) 0.15 = 0 reset (4000:0000) 0.14 = 0 loopback (2040:2000) 0. 6,13 = b01 speed selection = 100 Mbps (1000:1000) 0.12 = 1 A/N enable (0800:0000) 0.11 = 0 power-down (0400:0000) 0.10 = 0 isolate (0200:0000) 0. 9 = 0 restart A/N (0100:0100) 0. 8 = 1 duplex = full (0080:0000) 0. 7 = 0 collision test enable (003f:0000) 0. 5- 0 = 0 (reserved) U-Boot# mii dump 1 1 1. (786d) -- PHY status register -- (8000:0000) 1.15 = 0 100BASE-T4 able (4000:4000) 1.14 = 1 100BASE-X full duplex able (2000:2000) 1.13 = 1 100BASE-X half duplex able (1000:1000) 1.12 = 1 10 Mbps full duplex able (0800:0800) 1.11 = 1 10 Mbps half duplex able (0400:0000) 1.10 = 0 100BASE-T2 full duplex able (0200:0000) 1. 9 = 0 100BASE-T2 half duplex able (0100:0000) 1. 8 = 0 extended status (0080:0000) 1. 7 = 0 (reserved) (0040:0040) 1. 6 = 1 MF preamble suppression (0020:0020) 1. 5 = 1 A/N complete (0010:0000) 1. 4 = 0 remote fault (0008:0008) 1. 3 = 1 A/N able (0004:0004) 1. 2 = 1 link status (0002:0000) 1. 1 = 0 jabber detect (0001:0001) 1. 0 = 1 extended capabilities U-Boot# mii dump 1 3 3. (5c90) -- PHY ID 2 register -- (fc00:5c00) 3.15-10 = 23 OUI portion (03f0:0090) 3. 9- 4 = 9 manufacturer part number (000f:0000) 3. 3- 0 = 0 manufacturer rev. number 雜項 8P8C，也稱RJ45，是乙太網路使用雙絞線連接時常用的一種連接器插頭。 1 個 phy 配 1 個 RJ45，所以板子上有 2 個 RJ45，所以在 uboot 使用 mii info 要能夠找到 2 個 phy。 phy 上面會有自己所謂的 ID ，稱做 phy id ，會用於 MDIO/MDC 配對時用 QSGMII 是一種接線法，連接 4 個 phy，負責交換 data，最大 5G(4 個 phy 加起來) SGMII 是一種接憲法 搭配 1 個 phy， 負責交換 data，最大 1.25G XXXXX_driver.cbuild .ko 檔 // 這是一個標準的phy範例格式 static struct phy_driver dp83640_driver = { .phy_id = DP83640_PHY_ID, .phy_id_mask = 0xfffffff0, .name = \"NatSemi DP83640\", /* PHY_BASIC_FEATURES */ .probe = dp83640_probe, .remove = dp83640_remove, .soft_reset = dp83640_soft_reset, .config_init = dp83640_config_init, .ack_interrupt = dp83640_ack_interrupt, .config_intr = dp83640_config_intr, .ts_info = dp83640_ts_info, .hwtstamp = dp83640_hwtstamp, .rxtstamp = dp83640_rxtstamp, .txtstamp = dp83640_txtstamp, }; lua + C Lua 是一種輕量語言，它的官方版本只包括一個精簡的核心和最基本的庫。這使得 Lua 體積小、啟動速度快。它用 ANSI C 語言編寫並以原始碼形式開放，編譯後僅僅一百餘 K，可以很方便的嵌入別的程式裡。和許多「大而全」的語言不一樣，網路通訊、圖形介面等都沒有預設提供。但是 Lua 可以很容易地被擴充：由宿主語言（通常是 C 或 C++）提供這些功能，Lua 可以使用它們，就像是本來就內建的功能一樣。事實上，現在已經有很多成熟的擴充模組可供選用。 標題Re: [問題] 請問有在用 Lua 的大大們... C 與 Lua 會結合，就是因為沒有十全十美的程式語言 C 的優點是執行效率高，缺點是寫起來麻煩又不安全(undefined behavior) Lua 跑起來雖然慢，但寫起來簡單，開發速度快 我們要截長補短，所以並沒有一定要讓誰呼叫誰比較好的規則，而是看需求： * 程式規格固定、需要高效率、或是要呼叫底層函式的部份用 C 寫 * 規格時常變動，需要快速做出來驗證效果的，用 Lua 來寫 * 想要更高的彈性，因此設計 plug-in 系統，更適合用 Lua 比如說你想做個爬網頁的程式，那麼開 socket 的部份自然得用 C 寫 但是網頁抓下來後你可能想做各式各樣的動作，像是存圖片、掃瞄關鍵字等等 這部份用 Lua 寫就可以很靈活的變化，這種情況是 Lua 呼叫 C 又比如說許多遊戲引擎使用 C++ 來實作運算吃重的核心 但是會在特定位置呼叫外部的 Lua script 這麼一來就可以用 Lua 快速實做出不同玩法的遊戲 等到玩法確定後，再把需要效能改善的部份用 C++ 重寫 如果全部都用 C++ 開發，那麼開發時程是會大幅拉長的 另一個 Lua 的優勢是它的 runtime 很小，只依賴 standard c library 只要環境能跑 C 就可以把 Lua runtime 編起來跑 在 C 程式中包進一個 Lua interpreter 比起 python / ruby 是簡單許多的 而且正因為 Lua standard library 功能非常陽春 當你想要設計 plug-in 系統時，會比較容易去禁止 plug-in 做壞事 反正它真需要什麼底層功能，你再給它對應的 library 即可 沒有人規定給 C 呼叫的 function 一定要跑得和 C 一樣快 選擇適當的工具去滿足開發需求，這才是程式設計師的專業所在 -- ※ 發信站: 批踢踢實業坊(ptt.cc), 來自: 114.25.243.240 ※ 文章網址: https://www.ptt.cc/bbs/C_and_CPP/M.1484745230.A.918.html 推 Neisseria: 感謝大大說明，現在比較有概念了 01/18 21:34 推 CoNsTaR: 對C來講，或許包給Lua做事的部分可以在函式名稱上有區別 01/19 03:54 → CoNsTaR: 沒有人規定給C呼叫的函式一定要和C一樣快 01/19 03:54 → CoNsTaR: 但是當你的系統裡面存在越來越多這種和表面上看起來有一 01/19 03:54 → CoNsTaR: 點點不一樣的東西 01/19 03:54 → CoNsTaR: 我想累積下來一定也不是什麼好事吧～ 01/19 03:54 → hichcock: 這篇寫的很棒ㄚ~ 01/19 09:02 → hichcock: 重點在於 C + Lua 可以把效能 + 彈性的效果最大化 01/19 09:17 推 shadow0326: 推 01/19 10:51 推 eye5002003: 補個優點，lua語法簡單，有機會開放讓非程式人員修改 01/22 22:46 → alex70266: 重點是彈性阿，C call lua script 包 C module很常用","categories":[],"tags":[]},{"title":"Ubuntu 安裝 TFTP Server","slug":"Linux/Ubuntu 安裝 TFTP Server","date":"2020-05-19T02:00:00.000Z","updated":"2021-05-31T03:23:52.206Z","comments":true,"path":"2020/05/19/linux/ubuntu-an-zhuang-tftp-server/","link":"","permalink":"https://tsaiyuyan.github.io/2020/05/19/linux/ubuntu-an-zhuang-tftp-server/","excerpt":"","text":"因為要節省 embadded system 的空間，所以改使用 tftp 去 download 二進制檔案。相比 NFS 是比較小包，但是沒有列出檔案的功能，這點要稍微注意一下。 一、安裝 TFTP 服務(在 host 端) xinted 跟 tftpd-hpa 擇一即可 tftpd-hpa (recommended)1.下載 tftpd-hpa$sudo apt-get install tftpd-hpa 2.設定分享的目錄, 以下是 /home/yuyan/Public/tftp$sudo mkdir -p /home/yuyan/Public/tftp $sudo chmod -R 777 /home/yuyan/Public/tftp 3. 配置 /etc/default/tftpd-hpa$vim /etc/default/tftpd-hpa # /etc/default/tftpd-hpa TFTP_USERNAME=\"tftp\" TFTP_DIRECTORY=\"/home/yuyan/Public/tftp\" TFTP_ADDRESS=\":69\" TFTP_OPTIONS=\"-l -c -s\" #-c: Allow new files to be created #-s: Change root directory on startup. #-l: Run the server in standalone (listen) mode, rather than run from inetd. 4. 重啟 tftpd-hpa$sudo service tftpd-hpa restart xinetd(has-been)1.下載 xinetd$sudo apt-get install xinetd tftp tftp-server 2.設定分享的目錄,以下是 /home/yuyan/Public/tftp$sudo mkdir -p /home/yuyan/Public/tftp $sudo chmod -R 777 /home/yuyan/Public/tftp 3. 配置 /etc/xinetd.d/tftp$vim /etc/xinetd.d/tftp service tftp { disable = no socket_type = dgram protocol = udp wait = yes user = yuyan server = /usr/sbin/in.tftpd server_args = -s /home/yuyan/Public/tftp -c per_source = 11 cps = 100 2 } 4. restart xinetd service$sudo /etc/init.d/xinetd restart 二、用busybox tftp 測試 (guest 端)tftp help $ busybox tftp --help BusyBox v1.26.2 (2020-05-13 07:49:33 UTC) multi-call binary. Usage: tftp [OPTIONS] HOST [PORT] Transfer a file from/to tftp server -l FILE Local FILE -r FILE Remote FILE -g Get file -p Put file -b SIZE Transfer blocks of SIZE octets $ tftp get example $tftp -g -r hello 192.168.7.2 69 tftp put example tftp -p -l ./test 192.168.7.2 69","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"tftp","slug":"tftp","permalink":"https://tsaiyuyan.github.io/tags/tftp/"}]},{"title":"Gstreamer 編譯筆記","slug":"Gstreamer 編譯筆記","date":"2020-05-11T07:35:19.103Z","updated":"2021-12-27T02:04:04.532Z","comments":true,"path":"2020/05/11/gstreamer-bian-yi-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2020/05/11/gstreamer-bian-yi-bi-ji/","excerpt":"","text":"build documentation sudo apt install libglib2.0-devflex bison gst/parse/meson.build:7:0: ERROR: Program(s) [&#39;flex&#39;, &#39;win_flex&#39;] not found or not executable sudo apt-get install flex bisonlibxml2-devPackage libxml-2.0 was not found in the pkg-config search path.sudo apt-get install libxml2-dev json-glib-1.0Package json-glib-1.0 was not found in the pkg-config search path sudo apt-get install libjson-glib-dev pkg-config --cflags json-glib-1.0hotdoc docs/meson.build:37:0: ERROR: Program(s) [&#39;hotdoc&#39;] not found or not executabl sudo -s python3 -m pip install hotdocninja sudo apt-get install ninja-build =&gt; 1.5 fail python3.7 -m pip install ninja =&gt; 1.9.0.git.kitware.dyndep-1.jobserver-1meson build/ =&gt;libpng12-dev fail FFMEG../subprojects/FFmpeg/libavfilter/avf_showcqt.c:40:35: fatal error: fontconfig/fontconfig.h: No such file or directory compilation terminated. sudo apt-get install libpng-dev libfreetype6-dev libfontconfig1-dev meson configure -Dgst-plugins-bad:iqa=disabled -Dgst-plugins-good:png=disabled build/ ninja -C build libpng16-dev/usr/include/libpng12/pngconf.h:383:21: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘attribute’ before ‘.’ tokenpngconf.h in libpng already includes setjmp.h;^/usr/include/libpng12/pngconf.h:384:12: error: unknown type name ‘dont’dont include it again.;^/usr/include/libpng12/pngconf.h:384:29: error: expected ‘=’, ‘,’, ‘;’, ‘asm’ or ‘attribute’ before ‘it’dont include it again.;^/usr/include/libpng12/pngconf.h:384:29: error: unknown type name ‘it’ sudo apt-get install libpng16-dev -y 升級 python 3.5 到 3.7https://medium.com/k2shouai/ubuntu-16-04-%E6%9B%B4%E6%96%B0-python-3-7-f08cee97a64b sudo python3 -m pip install –upgrade pip cmake apt-get install cmakeERROR: Dependency “mount” not found, tried pkgconfig sudo apt install libmount libmount-dev flex bison cmakemeson resultAll GStreamer modules 1.17.0.1 Subprojects FFmpeg: YES 3 warnings dssim: YES gl-headers: YES glib: YES 1 warnings gst-devtools: YES gst-editing-services: YES gst-examples: YES gst-integration-testsuites: YES gst-libav: YES gst-omx: NO Feature 'omx' disabled gst-plugins-bad: YES 2 warnings gst-plugins-base: YES 4 warnings gst-plugins-good: YES 6 warnings gst-plugins-rs: NO Feature 'rs' disabled gst-plugins-ugly: YES 1 warnings gst-python: NO Could not find dependency pygobject_dep in subproject pygobject gst-rtsp-server: YES gstreamer: YES 1 warnings gstreamer-sharp: NO Feature 'sharp' disabled gstreamer-vaapi: NO Feature 'vaapi' disabled json-glib: YES 3 warnings libdrm: NO Dependency \"pciaccess\" not found, tried pkgconfig libmicrodns: YES libnice: YES libpsl: YES libsoup: NO [Errno 2] No such file or directory: 'glib-compile-resources': 'glib-compile-resources' libxml2: YES openh264: NO Program(s) ['nasm', 'nasm.exe'] not found or not executable orc: YES pygobject: NO Subproject directory not found and gobject-introspection.wrap file not found tinyalsa: NO Subproject directory not found and tinyalsa.wrap file not found x264: YES Option buildtype is: debug [default: debugoptimized] Found ninja-1.9.0.git.kitware.dyndep-1.jobserver-1 at /home/yuyan/.local/bin/ninja","categories":[],"tags":[]},{"title":"Doxygen 筆記","slug":"Doxygen 筆記","date":"2020-04-28T02:00:00.000Z","updated":"2020-06-01T05:46:55.029Z","comments":true,"path":"2020/04/28/doxygen-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2020/04/28/doxygen-bi-ji/","excerpt":"","text":"下載點 先安裝 Doxygen 再安裝 Graphviz 1.DoxygenLink 2.GraphvizLink Windows 下使用 doxygen 閱讀和分析 C/C++代碼雖然使用各種 IDE 或者 Source Insight 可以方便地在 windows 下閱讀和分析 C/C++代碼，但是一步步 Go to Definetion 實在令人痛苦。Doxygen 能夠生成函數調用關係圖，所有的函數調用關係可以一目了然，另外他還能統計文檔中所有的類，成員變數，成員函數等。總的來說，Doxygen 不但能從局部把握代碼，還能從全局審視代碼，後者是一般 IDE 和 Source Insight 不能做到的。所以，使用 doxygen 閱讀分析代碼可以達到事半功倍的效果。 doxygen 的安裝很簡單，到官方網站下載 doxygen 的 windows 安裝程式即可。除了安裝 doxygen 外，還需要安裝 graphviz，因為 doxygen 需要使用 graphviz 的 dot.exe 生成調用圖。graphviz 在它的官方網站上也可以下載到安裝程式。不過我下載的安裝程式在安裝時老是報 cab 檔錯誤。最後我下載了 graphviz 的 release 檔，即安裝程式下面的 zip 壓縮檔，下載完成後解壓縮即可。 安裝完 doxygen 後即可進行適當的配置，然後運行 doxyfile 生成文檔。基本的配置前人早有說明，不再贅述。需要注意的是： 要勾選 Expert-&gt;Dot 選項卡下面的 HAVEDOT、CALL_GRAPH 、CALLER_GRAPH 選項。並在 DOT_PATH 下面填入 dot.exe 的路徑，也就是 graphviz 安裝目錄下的 bin 檔夾。**(default: C:\\Program Files (x86)\\Graphviz2.38\\bin)_\\\\ 勾選 Wizard-&gt;Project 選項卡下面的 Scan recursively！ 勾選 Expert -&gt;Build 選項卡下面的 EXTRACT_ALL、EXTRACT_PRIVATE、EXTRACT_STATIC、EXTRACT_LOCAL_CLASSES、EXTRACT_LOCAL_METHODS 選項 如果程式裏面有中文，Exoert -&gt; project -&gt; DOXYFILE_ENCODING INPUT_ENCODING 改為 BIG5 可以勾掉 LATEX 輸出，這樣節省編譯時間 Doxygen 效果請參考附件圖片 Expert -&gt; Source Browser 可以勾選 SOURCE_BROWSER 可以在網站上看到 source code Vs code 自動生成 Doxygen 格式註釋(有用 Vs code 仁兄可參考)Link","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[{"name":"note","slug":"note","permalink":"https://tsaiyuyan.github.io/tags/note/"}]},{"title":"TI-RTOS vxi11 儀器服務的實現_part2","slug":"TI-RTOS/TI-RTOS vxi11 儀器服務的實現_part2","date":"2020-04-27T02:00:00.000Z","updated":"2020-05-11T07:35:19.138Z","comments":true,"path":"2020/04/27/ti-rtos/ti-rtos-vxi11-yi-qi-fu-wu-de-shi-xian-part2/","link":"","permalink":"https://tsaiyuyan.github.io/2020/04/27/ti-rtos/ti-rtos-vxi11-yi-qi-fu-wu-de-shi-xian-part2/","excerpt":"","text":"差異列表 num 平台/參數 windows/Unix TI-RTOS(lwip1.4.1) 1 socket unsigned short void * 2 sizeof(enum) 4 (int) 1(packed) 3 endian big-endian little-endian 4 htonl function macro 5 ntohl function macro 6 htons function macro 7 ntohs function macro 8 select() select(a,b,c,d,e) fdSelect(a,(fdset )b,(fdset *)c,(fd_set \\)d,e) 9 getpid() 有 無 10 errno.h 有 有(但缺一些宣告) 11 FD_SETSIZE 64 NDK_FD_SETSIZE 16 12 abort 有 有但不可以使用，會讓程式整個退出 13 關閉 socket closesocket fdclose 14 struct hostent 有 無 15 struct hostent 有 無 16 _rpc_dtablesize 有 無 17 gettimeofday 有 無 18 register 數量 夠 不夠 19 get_myad.c 有 自行實作 移植開始1.socket 間的差異，看到 TI-RTOS 是地址，Windos/Unix 是單純的變數，在 rpc 某些部分文件是有很大的影響，因為 rpc 有一個部分會用 socket 的值拿來當作陣列的 index 所以， 很明顯 TI-RTOS 會讓整個陣列空間爆掉所以我們必須要替換他的演算法。 像是 svc.c原本的 code 長這樣 xports[sock] = xprt; 但很明顯 TI-RTOS 的 socket 放進去 陣列一定會爆掉，所以我們必須換掉成 ndk_socket_to_sock_set(sock,idx); xports[idx] = xprt; svc.c 上面相關 function 長這樣 // static SOCKET ysocks[YSOCKS_SIZE]={0}; // added by yuyan /* * ndk_socket_to_sock_find() function for xports * if find sock in ysocks ,then return idx; otherwise return free room idx */ int ndk_socket_to_sock_find(sock) SOCKET sock; { int i; int free_latest = -1; for(i = 0;i &lt; YSOCKS_SIZE;i++) { if(ysocks[i] == sock) //find room return i; if(free_latest == -1 &amp;&amp; ysocks[i] == 0) free_latest = i; } return free_latest; } int ndk_socket_to_sock_release(int idx) { ysocks[idx] = 0; } int ndk_socket_to_sock_set(SOCKET sock,int idx) { ysocks[idx] = sock; } 基本上解決的個大致上就先完成了一半。 2.sizeof(enum) 的差異很不巧的是在 rpc 模組中他設定的 sizeof(enum)必須要是 4，否則會影響送出去封包的大小，當然在 TI-RTOS 也可以在 CCS 專案 properties 設定成 4，但因為在我那個板子上設定成 4 會有其他問題，所以只能改變 rpc 模組，讓他不使用 enum，簡單來說，我用一般 define + int 型態去替換掉，就可以解決這個問題。 以這個做例子 enum clnt_stat enum clnt_stat { RPC_SUCCESS=0, /* call succeeded */ /* * local errors */ RPC_CANTENCODEARGS=1, /* can't encode arguments */ RPC_CANTDECODERES=2, /* can't decode results */ RPC_CANTSEND=3, /* failure in sending call */ RPC_CANTRECV=4, /* failure in receiving result */ RPC_TIMEDOUT=5, /* call timed out */ /* * remote errors */ RPC_VERSMISMATCH=6, /* rpc versions not compatible */ RPC_AUTHERROR=7, /* authentication error */ RPC_PROGUNAVAIL=8, /* program not available */ RPC_PROGVERSMISMATCH=9, /* program version mismatched */ RPC_PROCUNAVAIL=10, /* procedure unavailable */ RPC_CANTDECODEARGS=11, /* decode arguments error */ RPC_SYSTEMERROR=12, /* generic \"other problem\" */ /* * callrpc &amp; clnt_create errors */ RPC_UNKNOWNHOST=13, /* unknown host name */ RPC_UNKNOWNPROTO=17, /* unkown protocol */ /* * _ create errors */ RPC_PMAPFAILURE=14, /* the pmapper failed in its call */ RPC_PROGNOTREGISTERED=15, /* remote program is not registered */ /* * unspecified error */ RPC_FAILED=16 }; 改成這樣 #define RPC_SUCCESS 0 /* call succeeded */ /* * local errors */ #define RPC_CANTENCODEARGS 1 /* can't encode arguments */ #define RPC_CANTDECODERES 2 /* can't decode results */ #define RPC_CANTSEND 3 /* failure in sending call */ #define RPC_CANTRECV 4 /* failure in receiving result */ #define RPC_TIMEDOUT 5 /* call timed out */ /* * remote errors */ #define RPC_VERSMISMATCH 6 /* rpc versions not compatible */ #define RPC_AUTHERROR 7 /* authentication error */ #define RPC_PROGUNAVAIL 8 /* program not available */ #define RPC_PROGVERSMISMATCH 9 /* program version mismatched */ #define RPC_PROCUNAVAIL 10 /* procedure unavailable */ #define RPC_CANTDECODEARGS 11 /* decode arguments error */ #define RPC_SYSTEMERROR 12 /* generic \"other problem\" */ /* * callrpc &amp; clnt_create errors */ #define RPC_UNKNOWNHOST 13 /* unknown host name */ #define RPC_UNKNOWNPROTO 17 /* unkown protocol */ /* * _ create errors */ #define RPC_PMAPFAILURE 14 /* the pmapper failed in its call */ #define RPC_PROGNOTREGISTERED 15 /* remote program is not registered */ /* * unspecified error */ #define RPC_FAILED 16 #define clnt_stat int // enum clnt_stat 3.big-endian and little-endian 的差異經過我的測試，沒有影響。 4-7.htonl、ntohl、htons、ntohs 這個東西主要是在替換高低位元的值，在建置封包時很容易看到，但宣告成 macro 或用 function 在 RPC 上有著極大的差異，讓我們看一段 code。 socketndk.h #define htonl(a) ((((a) &amp; 0xff000000) >> 24) | (((a) &amp; 0x00ff0000) >> 8) | \\ (((a) &amp; 0x0000ff00) &lt;&lt; 8) | (((a) &amp; 0x000000ff) &lt;&lt; 24) ) #define ntohl(a) htonl(a) #define ntohs(a) htons(a) 在 xdr.h 的檔案中 #define IXDR_GET_LONG(buf) ((long)ntohl((u_long)*(buf)++)) ... // 當使用者呼叫 IXDR_GET_LONG(buf) // macro 的ntohl 會被展開成 ((long)ntohl((((((u_long)*(buf)++))) &amp; 0xff000000) >> 24) | ((((u_long)*(buf)++))) &amp; 0x00ff0000) >> 8) | \\ ((((u_long)*(buf)++))) &amp; 0x0000ff00) &lt;&lt; 8) | ((((u_long)*(buf)++))) &amp; 0x000000ff) &lt;&lt; 24) ) 可以看到 buf 的指標被++了 4 次，很明顯會有問題，所以我改成自己寫 NTOHL、HTONL、NTOHS、HTONS 用 function 的方式 替換掉所有的 ntohl、htonl、ntohs、htons vxi11-rtos.h static unsigned short HTONS(unsigned short a) { return ( (((a)&gt;&gt;8)&amp;0xff) + (((a)&lt;&lt;8)&amp;0xff00) ); } static unsigned int HTONL(unsigned int n) { return (((((unsigned long)(n) &amp; 0xFF)) &lt;&lt; 24) | \\ ((((unsigned long)(n) &amp; 0xFF00)) &lt;&lt; 8) | \\ ((((unsigned long)(n) &amp; 0xFF0000)) &gt;&gt; 8) | \\ ((((unsigned long)(n) &amp; 0xFF000000)) &gt;&gt; 24)); } #define NTOHL(a) HTONL(a) #define NTOHS(a) HTONS(a) 接下來就是把 rpc 內所有檔案有用到 ntohl、htonl、ntohs、htons 替換成 NTOHL、HTONL、NTOHS、HTONS 上面自己實作的 function 8.select()差異這個東西好辦，TI-RTOS 跟 Windows/Unix 下的 select 長得差不多。所以就 vxi-rtos.h #define select(a,b,c,d,e) fdSelect(a,(fd_set *)b,(fd_set *)c,(fd_set *)d,e) 9. getpid()這個東西在 TI-RTOS 裡面是沒有的，但是我仔細的看了 rpc 使用他做了什麼式，發現只是為了產生隨機 port 的範圍，為了能夠隨機所以才使用他，所以隨便給他訂個數字就可以了 vxi-rtos.h #define getpid() 123 //隨意 10.errno.hTI-RTOS 沒有 EAFNOSUPPORT 所以就隨意宣告給他。vxi-rtos.h #include &lt;errno.h> #define EAFNOSUPPORT 106 /* Address family not supported by protocol family */ TI-RTOS 沒有 errlist，所以就隨意宣告給他。vxi-rtos.c char *sys_errlist[10]={0}; 11.NDK_FD_SETSIZE這個東西是只 select 可監控的 socket 最大數是多少，ti-rtos 有 16，所以夠用 vxi-rtos.h #define YSOCKS_SIZE NDK_FD_SETSIZE #define _rpc_dtablesize() YSOCKS_SIZE 另外，portmap 會用掉 2 個(udp+tcp)，vxi 會用掉 2 個(udp+tcp)，所以可以得知 vxi 的連線量最多可達到 16-4=12 條。 12.abortTI-RTOS 有但不可以使用，會讓程式整個退出，所以把 rpc 所有檔案看到的 abort 換成自己寫的 yabort vxi-rtos.c void yabort() { UARTprintf(\"yuyan abort()..... \\n\"); } 13.關閉 socket這個簡單，直接 vxi-rtos.h #define closesocket fdClose 14-15.struct hostent、struct hostent因為 TI-RTOS 的 socketndk.h 沒有這個結構，所以自己補上 vxi-rtos.h struct hostent { char * h_name; /* official name of host */ char ** h_aliases; /* alias list */ short h_addrtype; /* host address type */ short h_length; /* length of address */ char ** h_addr_list; /* list of addresses */ #define h_addr h_addr_list[0] /* address, for backward compat */ }; struct protoent { char * p_name; /* official protocol name */ char ** p_aliases; /* alias list */ short p_proto; /* protocol # */ }; 16. _rpc_dtablesize這個東西是 unix 裡才有的東西，但實際上跟 FD_SETSIZE 是一樣的東西所以就 vxi-rtos.h #define YSOCKS_SIZE NDK_FD_SETSIZE #define _rpc_dtablesize() YSOCKS_SIZE 17.gettimeofdayTI-RTOS 並沒有時間這個函數，於是我看 rpc 用這個函數在做甚麼咚咚，原來只是要取亂數值，所以替換方法就是有用到他的地方用亂數取代，像是 先宣告的 tick vxi-rtos.c int vxi11_tick() { unsigned long t = (unsigned long)Clock_getTicks(); return (int64_t) t; } 原本的 auth_uni.c (void)gettimeofday(&amp;now, (struct timezone *)0); aup.aup_time = now.tv_sec; 改成 //(void)gettimeofday(&amp;now, (struct timezone *)0); // changed by yuyan aup.aup_time = vxi11_tick()/1000000;//now.tv_sec; 18.register 數量(可選)這個東西我比較不確定 TI-RTOS 的東西夠不夠用，rpc 原本有使用目的是希望存在記憶體，能夠更快數的存取 socket list 結構，所以我懶的驗證就把所有有關的 register 全部先幹掉。 19.get_myad.c最後就是這個檔案啦，裡面有 get_myaddress(addr)函式，這個東西就是 portmap 要知道自己的 local ip 是多少，所以內容就自行實作， 原本為 static char sccsid[] = \"@(#)get_myaddress.c 1.4 87/08/11 Copyr 1984 Sun Micro\"; #endif /* * get_myaddress.c * * Get client's IP address via ioctl. This avoids using the yellowpages. * Copyright (C) 1984, Sun Microsystems, Inc. */ #ifdef WIN32 #include &lt;rpc/rpc.h> #include &lt;rpc/pmap_pro.h> #include &lt;stdio.h> #define MAX_NAME_LEN 255 #else #include &lt;rpc/types.h> #include &lt;rpc/pmap_prot.h> #include &lt;sys/socket.h> #include &lt;stdio.h> #include &lt;net/if.h> #include &lt;sys/ioctl.h> #include &lt;arpa/inet.h> #include &lt;netinet/in.h> /* * don't use gethostbyname, which would invoke yellow pages */ #endif get_myaddress(addr) struct sockaddr_in *addr; { #ifdef WIN32 struct hostent *Hostent; char my_name[MAX_NAME_LEN]; gethostname(my_name, MAX_NAME_LEN); Hostent = gethostbyname(my_name); if (Hostent == NULL) { errno; perror(\"Can not get host info\"); exit (1); } addr->sin_family = AF_INET; addr->sin_port = htons(PMAPPORT); bcopy((char *)Hostent->h_addr, (char *)&amp;addr->sin_addr, Hostent->h_length); #else int s; char buf[BUFSIZ]; struct ifconf ifc; struct ifreq ifreq, *ifr; int len; if ((s = socket(AF_INET, SOCK_DGRAM, 0)) &lt; 0) { perror(\"get_myaddress: socket\"); exit(1); } ifc.ifc_len = sizeof (buf); ifc.ifc_buf = buf; if (ioctl(s, SIOCGIFCONF, (char *)&amp;ifc) &lt; 0) { perror(\"get_myaddress: ioctl (get interface configuration)\"); exit(1); } ifr = ifc.ifc_req; for (len = ifc.ifc_len; len; len -= sizeof ifreq) { ifreq = *ifr; if (ioctl(s, SIOCGIFFLAGS, (char *)&amp;ifreq) &lt; 0) { perror(\"get_myaddress: ioctl\"); exit(1); } if ((ifreq.ifr_flags &amp; IFF_UP) &amp;&amp; ifr->ifr_addr.sa_family == AF_INET) { *addr = *((struct sockaddr_in *)&amp;ifr->ifr_addr); addr->sin_port = htons(PMAPPORT); break; } ifr++; } (void) close(s); #endif 被我改為 static char sccsid[] = \"@(#)get_myaddress.c 1.4 87/08/11 Copyr 1984 Sun Micro\"; #endif /* * get_myaddress.c * * Get client's IP address via ioctl. This avoids using the yellowpages. * Copyright (C) 1984, Sun Microsystems, Inc. */ #include \"../vxi11-rtos.h\" #include &lt;stdio.h> #include &lt;rpc/types.h> #include &lt;rpc/pmap_pro.h> //#include &lt;sys/socket.h> // //#include &lt;net/if.h> //#include &lt;sys/ioctl.h> //#include &lt;arpa/inet.h> //#include &lt;netinet/in.h> /* * don't use gethostbyname, which would invoke yellow pages */ #include \"menu/data/dataMenu.h\" get_myaddress(addr) struct sockaddr_in *addr; { //UARTprintf(\"get_myaddress()\\n\"); unsigned char *local_ip = NULL; if (Conf.intf_sel.LAN.dhcp) { local_ip = Dhcp.ip; } else { local_ip = Conf.intf_sel.LAN.ip; } unsigned int ip4 = 0; if ((local_ip[3] &lt; 256) &amp;&amp; (local_ip[2] &lt; 256) &amp;&amp; (local_ip[1] &lt; 256) &amp;&amp; (local_ip[0] &lt; 256)) { ip4 = (local_ip[3] &lt;&lt; 24) + (local_ip[2] &lt;&lt; 16) + (local_ip[1] &lt;&lt; 8) + local_ip[0]; } addr->sin_family = AF_INET; addr->sin_port = HTONS(PMAPPORT); addr->sin_addr.s_addr = ip4; //inet_pton(AF_INET, \"192.168.31.239\", &amp;addr->sin_addr); return; } 就是這麼的樸實無華且枯燥~。 結語本篇只大概講了大概的轉換方向，畢竟修改的東西相當繁多，當然我也會將轉換前後的代碼放在我的 github，一個是可以在 windows 上執行的專案，另一個是在 TI-RTOS 上執行的，完整的專案就交給前公司了，如果有需要修正的地方歡迎來信指教。 github 連結(待補) gitlab 連結(待補)","categories":[{"name":"TI-RTOS","slug":"TI-RTOS","permalink":"https://tsaiyuyan.github.io/categories/TI-RTOS/"}],"tags":[]},{"title":"Ubuntu avahi-daemon 移植 imxrt1064(arm-v7-linux-uclibceabi)","slug":"Linux/Ubuntu avahi-daemon 移植 imxrt1064(arm-v7-linux-uclibceabi)","date":"2020-04-16T02:00:00.000Z","updated":"2022-07-18T01:55:35.461Z","comments":true,"path":"2020/04/16/linux/ubuntu-avahi-daemon-yi-zhi-imxrt1064-arm-v7-linux-uclibceabi/","link":"","permalink":"https://tsaiyuyan.github.io/2020/04/16/linux/ubuntu-avahi-daemon-yi-zhi-imxrt1064-arm-v7-linux-uclibceabi/","excerpt":"","text":"前言 真香注意 由於此板子需要遵守廠商規則必須 build 成-static 的程式，但是 avahi-daemon 本身會 build 成 -shard 的程式，所以我們必須修改相關的 makefile，所以單純的./configure 已經沒辦法滿足，看不懂我在工三小就直接往下看。 avahi-daemon 移植 imxrt1064(arm-v7-linux-uclibceabi) 以下請自行準備相關 toolchain，並遵照廠商提供的編譯方法。 1.下載 4 個 tar 包 libdaemon-0.14.tar.gz avahi-0.7.tar.gz expat-2.2.9.tar.bzip attr-2.5.1.tar.gz 自行解壓縮到指定資料夾，本文示範如下 $ tree -L 1 ~/Desktop/avahi-daemon-imxrt1064/ /home/yuyan/Desktop/avahi-daemon-imxrt1064/ ├── avahi-0.7 ├── expat-2.2.9 ├── libdaemon-0.14 └── attr-2.5.1 4 directories, 0 files 2.編譯 libdaemon#因為產生再/opt底下，所以切至root權限 $sudo -s #設置 $./configure --host=arm-v7-linux-uclibceabi --prefix=/opt/imxrt1064/libdaemon CC=arm-v7-linux-uclibceabi-gcc \\ --config-cache #錯誤訊息: configure: error: cannot check setpgrp when cross compiling #訂正方法: $echo \"ac_cv_func_setpgrp_void=yes\" > config.cache # 再次執行 $./configure --host=arm-v7-linux-uclibceabi --prefix=/opt/imxrt1064/libdaemon CC=arm-v7-linux-uclibceabi-gcc \\ --config-cache $make # 會碰到這些錯誤 CCLD libdaemon.la .libs/dfork.o: In function `daemon_fork': /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dfork.c:178: undefined reference to `fork' /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dfork.c:245: undefined reference to `fork' .libs/dexec.o: In function `daemon_execv': /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dexec.c:62: undefined reference to `fork' collect2: error: ld returned 1 exit status Makefile:339: recipe for target 'libdaemon.la' failed make[2]: *** [libdaemon.la] Error 1 make[2]: Leaving directory '/home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon' Makefile:382: recipe for target 'all-recursive' failed make[1]: *** [all-recursive] Error 1 make[1]: Leaving directory '/home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14' Makefile:287: recipe for target 'all' failed make: *** [all] Error 2 # 因為uclinux 沒有fork這東西所以全部用vfork 代替 --- # 將這2個文件內的 fork 全部替換成 vfork $vim /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dfork.c $vim /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dexec.c $make $make install 3.編譯 expat (如果 toolchain 沒有的話)#解壓縮 $bzip2 -d expat-2.2.9.tar.bz2ls $tar xvf expat-2.2.9.tar ./ #因為要產生在/opt底下，所以切至root權限 $sudo -s $./configure --host=arm-v7-linux-uclibceabi --prefix=/opt/imxrt1064/expat-2.2.9 CC=arm-v7-linux-uclibceabi-gcc $make $make install 4.編譯 libattr (如果 toolchain 沒有的話)(可選) (20220718 補充) 編譯流程跟expat差不多 &lt;= 有需要調整請自行修正我不確定這隻cross compiler 需不需要自己build這個 lib，如果avahi需要的話，在build好此lib 在CFLAGS 跟LDFLAGS 補上 #解壓縮 $tar zxvf attr-2.5.1.tar.gz $sudo -s $./configure --host=arm-v7-linux-uclibceabi --prefix=/opt/imxrt1064/attr CC=arm-v7-linux-uclibceabi-gcc $make $make install 5.編譯 avahi 這邊目的只在於編譯 avahi-daemon，所以其他的工具都會 disable。 Optional Features: opertion description –disable-option-checking ignore unrecognized –enable/–with options –disable-FEATURE do not include FEATURE (same as –enable-FEATURE=no) –enable-FEATURE[=ARG] include FEATURE [ARG=yes] –enable-silent-rules less verbose build output (undo: “make V=1”) –disable-silent-rules verbose build output (undo: “make V=0”) –enable-dependency-tracking do not reject slow dependency extractors –disable-dependency-tracking speeds up one-time build –disable-stack-protector Disable GCC’s/libc’s stack-smashing protection –enable-shared[=PKGS] build shared libraries [default=yes] –enable-static[=PKGS] build static libraries [default=yes] –enable-fast-install[=PKGS] optimize for fast installation [default=yes] –disable-libtool-lock avoid locking (might break parallel builds) –disable-nls do not use Native Language Support –disable-rpath do not hardcode runtime library paths –disable-glib Disable use of GLib –disable-gobject Disable use of GLib GObject –enable-introspection=[no/auto/yes] Enable introspection for this build –disable-libevent Disable use of libevent –enable-qt3 Enable building of Qt3 mainloop integration –disable-qt4 Disable building of Qt4Core mainloop integration –disable-qt5 Disable building of Qt5Core mainloop integration –disable-gtk Disable use of GTK+ 2 –disable-gtk3 Disable use of GTK+ 3 –disable-dbus Disable use of D-Bus –enable-dbm Enable use of DBM –disable-gdbm Disable use of GDBM –disable-libdaemon Disable use of libdaemon –disable-python Disable scripts that depends on python –disable-pygobject Disable use of Python GObject –disable-python-dbus Disable use of D-Bus in Python –disable-mono Disable mono bindings –disable-monodoc Disable documentation for mono bindings –disable-autoipd Disable building of avahi-autoipd –disable-doxygen-doc don’t generate any doxygen documentation –disable-doxygen-dot don’t generate graphics for doxygen documentation –enable-doxygen-man generate doxygen manual pages –enable-doxygen-rtf generate doxygen RTF documentation –disable-doxygen-xml don’t generate doxygen XML documentation –enable-doxygen-chm generate doxygen compressed HTML help documentation –enable-doxygen-chi generate doxygen seperate compressed HTML help index file –disable-doxygen-html don’t generate doxygen plain HTML documentation –enable-doxygen-ps generate doxygen PostScript documentation –enable-doxygen-pdf generate doxygen PDF documentation –enable-core-docs Enable building of documentation for avahi-core –disable-manpages Disable building and installation of man pages –disable-xmltoman Disable rebuilding of man pages with xmltoman –enable-tests Enable building of tests and examples –enable-compat-libdns_sd Enable compatibility layer for libdns_sd –enable-compat-howl Enable compatibility layer for HOWL 開始編譯: #直接root編譯 $sudo -s #因為我們要build static 的avahi 所以我們要通過他的-pthread驗證所以先動點手腳 $ vim ./configure #切到17606行 :17060 #會看到 CFLAGS=\"-shared -fPIC -Wl,-z,defs $CFLAGS $PTHREAD_CFLAGS\" #改成 CFLAGS=\"-static -fPIC -Wl,-z,defs $CFLAGS $PTHREAD_CFLAGS\" #存檔離開 :wq #build avahi $./configure --host=arm-v7-linux-uclibceabi \\ --prefix=/opt/imxrt1064/avahi/ \\ --with-distro=none \\ --sysconfdir=/etc \\ --with-xml=expat \\ --with-avahi-user=\"root\" \\ --with-avahi-group=\"root\" \\ --localstatedir=/var \\ --enable-libdaemon \\ --disable-glib \\ --disable-gobject \\ --disable-dbus \\ --disable-gdbm \\ --disable-autoipd \\ --disable-qt3 \\ --disable-qt4 \\ --disable-gtk \\ --disable-gtk3 \\ --disable-python \\ --disable-pygtk \\ --disable-python-dbus \\ -disable-mono \\ -disable-monodoc \\ -disable-doxygen-html \\ -disable-xmltoman \\ -disable-manpages \\ CC=arm-v7-linux-uclibceabi-gcc \\ CFLAGS=\"-I/opt/imxrt1064/avahi/include -I/opt/imxrt1064/expat-2.2.9/include -I/linux-cortexm-2.5.2/linux/tools/perf/util/ -I/home/allen/Desktop/nxp/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/sysroot/include \" \\ LDFLAGS=\"-L/opt/imxrt1064/avahi/lib -L/opt/imxrt1064/expat-2.2.9/lib\" \\ LIBS=\"-static\" \\ LIBDAEMON_CFLAGS=\"-I/opt/imxrt1064/libdaemon/include \" \\ LIBDAEMON_LIBS=\"/opt/imxrt1064/libdaemon/lib/libdaemon.a\" # 這邊開始動些手腳 $make # 他會依序build folder ./avahi-common => ./avahi-core => ./avahi-daemon #進入 avahi-daemon $cd ./avahi-daemon # 先清掉 $make clean # 我們要竄改Makefile $vim Makefile #找到 -lssp這個東西(478行)， 改成toolchain 底下的 libssp.a檔 #原為 LIBS = -static -lssp #改成 LIBS = -static /home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib/libssp.a #找到 --silent(235行) #原為 am__v_lt_0 = --silent #改成 am__v_lt_0 = #--silent #這個的目的是他在最後用 libtool link的時候你就可以很清楚看到link的所有檔案 $make --- libtool: warning: library '/home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib/libssp.la' was moved. libtool: link: #這段就是所有的link 可以看到有些檔案是.so檔 arm-v7-linux-uclibceabi-gcc -std=gnu99 -I.. \"-DDEBUG_TRAP=__asm__(\\\"int \\$3\\\")\" -DAVAHI_DAEMON_RUNTIME_DIR=\\\"/run/avahi-daemon/\\\" -DAVAHI_SOCKET=\\\"/run/avahi-daemon/socket\\\" -DAVAHI_SERVICE_DIR=\\\"/etc/avahi/services\\\" -DAVAHI_CONFIG_FILE=\\\"/etc/avahi/avahi-daemon.conf\\\" -DAVAHI_HOSTS_FILE=\\\"/etc/avahi/hosts\\\" -DAVAHI_DBUS_INTROSPECTION_DIR=\\\"/opt/imxrt1064/avahi/share/dbus-1/interfaces\\\" -DAVAHI_CONFIG_DIR=\\\"/etc/avahi\\\" -I/opt/imxrt1064/libdaemon/include -DUSE_EXPAT_H -I/opt/imxrt1064/avahi/include -I/opt/imxrt1064/expat-2.2.9/include -I/linux-cortexm-2.5.2/linux/tools/perf/util/ -I/home/allen/Desktop/nxp/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/sysroot/include -Wall -W -Wextra -pedantic -pipe -Wformat -Wold-style-definition -Wdeclaration-after-statement -Wfloat-equal -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wredundant-decls -Wmissing-noreturn -Wshadow -Wendif-labels -Wpointer-arith -Wbad-function-cast -Wcast-qual -Wcast-align -Wwrite-strings -fdiagnostics-show-option -Wno-cast-qual -fno-strict-aliasing -o avahi-daemon avahi_daemon-main.o avahi_daemon-simple-protocol.o avahi_daemon-static-services.o avahi_daemon-static-hosts.o avahi_daemon-ini-file-parser.o avahi_daemon-setproctitle.o avahi_daemon-sd-daemon.o avahi_daemon-check-nss.o -L/opt/imxrt1064/avahi/lib -L/opt/imxrt1064/expat-2.2.9/lib ../avahi-common/.libs/libavahi-common.a ../avahi-core/.libs/libavahi-core.a /home/yuyan/Desktop/avahi-daemon-imxrt1064/avahi-0.7/avahi-common/.libs/libavahi-common.a /home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib/libssp.so /opt/imxrt1064/libdaemon/lib/libdaemon.a /opt/imxrt1064/expat-2.2.9/lib/libexpat.so /home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib/libssp.a -pthread -Wl,-rpath -Wl,/home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib -Wl,-rpath -Wl,/opt/imxrt1064/expat-2.2.9/lib -Wl,-rpath -Wl,/home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib -Wl,-rpath -Wl,/opt/imxrt1064/expat-2.2.9/lib /home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib/libssp.so: warning: the 'gets' function is dangerous and should not be used. #會看到這些東西 #重新再連結一次，將連結的 .so 換掉，尾巴補上-static $arm-v7-linux-uclibceabi-gcc -std=gnu99 -I.. \"-DDEBUG_TRAP=__asm__(\\\"int \\$3\\\")\" -DAVAHI_DAEMON_RUNTIME_DIR=\\\"/run/avahi-daemon/\\\" -DAVAHI_SOCKET=\\\"/run/avahi-daemon/socket\\\" -DAVAHI_SERVICE_DIR=\\\"/etc/avahi/services\\\" -DAVAHI_CONFIG_FILE=\\\"/etc/avahi/avahi-daemon.conf\\\" -DAVAHI_HOSTS_FILE=\\\"/etc/avahi/hosts\\\" -DAVAHI_DBUS_INTROSPECTION_DIR=\\\"/opt/imxrt1064/avahi/share/dbus-1/interfaces\\\" -DAVAHI_CONFIG_DIR=\\\"/etc/avahi\\\" -I/opt/imxrt1064/libdaemon/include -DUSE_EXPAT_H -I/opt/imxrt1064/avahi/include -I/opt/imxrt1064/expat-2.2.9/include -I/linux-cortexm-2.5.2/linux/tools/perf/util/ -I/home/allen/Desktop/nxp/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/sysroot/include -Wall -W -Wextra -pedantic -pipe -Wformat -Wold-style-definition -Wdeclaration-after-statement -Wfloat-equal -Wmissing-declarations -Wmissing-prototypes -Wstrict-prototypes -Wredundant-decls -Wmissing-noreturn -Wshadow -Wendif-labels -Wpointer-arith -Wbad-function-cast -Wcast-qual -Wcast-align -Wwrite-strings -fdiagnostics-show-option -Wno-cast-qual -fno-strict-aliasing -o avahi-daemon avahi_daemon-main.o avahi_daemon-simple-protocol.o avahi_daemon-static-services.o avahi_daemon-static-hosts.o avahi_daemon-ini-file-parser.o avahi_daemon-setproctitle.o avahi_daemon-sd-daemon.o avahi_daemon-check-nss.o -L/opt/imxrt1064/avahi/lib -L/opt/imxrt1064/expat-2.2.9/lib ../avahi-common/.libs/libavahi-common.a ../avahi-core/.libs/libavahi-core.a /home/yuyan/Desktop/avahi-daemon-imxrt1064/avahi-0.7/avahi-common/.libs/libavahi-common.a /home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib/libssp.a /opt/imxrt1064/libdaemon/lib/libdaemon.a /opt/imxrt1064/expat-2.2.9/lib/libexpat.a /home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib/libssp.a -pthread -Wl,-rpath -Wl,/home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib -Wl,-rpath -Wl,/opt/imxrt1064/expat-2.2.9/lib -Wl,-rpath -Wl,/home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib -Wl,-rpath -Wl,/opt/imxrt1064/expat-2.2.9/lib -static #用 readlf -d 確認avahi-daemon沒有任何的動態連結 $arm-v7-linux-uclibceabi-readelf -d ./avahi-daemon # 全部靜態的結果會是這樣 There is no dynamic section in this file. # 如果沒加-static 就會變成 Dynamic section at offset 0x54598 contains 29 entries: Tag Type Name/Value 0x00000001 (NEEDED) Shared library: [libgcc_s.so.1] 0x00000001 (NEEDED) Shared library: [libpthread.so.0] 0x00000001 (NEEDED) Shared library: [libc.so.0] 0x0000000f (RPATH) Library rpath: [/home/yuyan/Desktop/linux-cortexm-2.5.2/tools/arm-v7-linux-uclibceabi/arm-v7-linux-uclibceabi/lib:/opt/imxrt1064/expat-2.2.9/lib] (下略) # 這時我們就已經把 avahi-daemon build 好了，可以直接丟到 機器上run 6.疑難排解avahi error: ‘O_CLOEXEC’ undeclared$gedit avahi-daemon/main.c #define O_CLOEXEC 0 //= 2.4.0 ) were not met: No package 'glib-2.0' found $sudo apt-get install libglib2.0-dev /libcap.so: undefined reference to XXXX/opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `removexattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `fremovexattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `getxattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `setxattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `fsetxattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `fgetxattr@ATTR_1.0' #./configure 時LDFLAGS 補上 -lattr，本文沒用到 undefined reference to `fork’/home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dfork.c:178: undefined reference to `fork' /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dfork.c:245: undefined reference to `fork' /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dexec.c:62: undefined reference to `fork' collect2: error: ld returned 1 exit status Makefile:270: recipe for target 'testd' failed make[2]: *** [testd] Error 1 make[2]: Leaving directory '/home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/examples' Makefile:382: recipe for target 'all-recursive' failed make[1]: *** [all-recursive] Error 1 make[1]: Leaving directory '/home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14' Makefile:287: recipe for target 'all' failed make: *** [all] Error 2 將這三個文件內的 fork 全部替換成 vfork $vim /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dfork.c $vim /home/yuyan/Desktop/avahi-daemon-imxrt1064/libdaemon-0.14/libdaemon/dexec.c uclinux gdb 疑難排解fatal error: curses.h: No such file or directoryIn file included from scripts/kconfig/mconf.c:23:0:scripts/kconfig/lxdialog/dialog.h:38:20: fatal error: curses.h: No such file or directory sudo apt-get install libncurses5-dev libncursesw5-dev 遇到 undefined symbol: pyunicodeucs4_fromencodedobjectLD_PRELOAD=/usr/lib/libpython2.7.so arm-v7-linux-uclibceabi-gdb -ex ‘set environ LD_PRELOAD’ –args my-program-to-debug target remote 172.16.28.129:10000 BASECFLAGS=-m32 LDFLAGS=-m32 CFLAGS=-m32 ./configure –prefix=/usr –enable-shared –enable-unicode=ucs4 運行環境底下必需建置Folder: mkdir -p /run/avahi/ mkdir -p /etc/avahi/services/ File cp /mnt/nfs/avahi-daemon /sbin/avahi-daemon &lt;= 執行檔 vi /etc/avahi/avahi-daemon.conf # This file is part of avahi. # # avahi is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as # published by the Free Software Foundation; either version 2 of the # License, or (at your option) any later version. # # avahi is distributed in the hope that it will be useful, but WITHOUT # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY # or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public # License for more details. # # You should have received a copy of the GNU Lesser General Public # License along with avahi; if not, write to the Free Software # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 # USA. # See avahi-daemon.conf(5) for more information on this configuration # file! [server] #host-name=foo #domain-name=local #browse-domains=0pointer.de, zeroconf.org use-ipv4=yes use-ipv6=no #allow-interfaces=eth0 #deny-interfaces=eth1 #check-response-ttl=no #use-iff-running=no #enable-dbus=yes #disallow-other-stacks=no #allow-point-to-point=no #cache-entries-max=4096 #clients-max=4096 #objects-per-client-max=1024 #entries-per-entry-group-max=32 ratelimit-interval-usec=1000000 ratelimit-burst=1000 [wide-area] enable-wide-area=yes [publish] #disable-publishing=no #disable-user-service-publishing=no #add-service-cookie=no #publish-addresses=yes publish-hinfo=no publish-workstation=no #publish-domain=yes #publish-dns-servers=192.168.50.1, 192.168.50.2 #publish-resolv-conf-dns-servers=yes #publish-aaaa-on-ipv4=yes #publish-a-on-ipv6=no [reflector] #enable-reflector=no #reflect-ipv=no [rlimits] #rlimit-as= #rlimit-core=0 #rlimit-data=8388608 #rlimit-fsize=0 #rlimit-nofile=768 #rlimit-stack=8388608 #rlimit-nproc=3 vi /etc/avahi/services/lxi.service &lt;=lxi 服務設定檔 &lt;?xml version=\"1.0\" standalone='no'?> &lt;!DOCTYPE service-group SYSTEM \"avahi-service.dtd\"> &lt;service-group> &lt;name replace-wildcards=\"yes\">%h-yuyan123&lt;/name> &lt;service protocol=\"ipv4\"> &lt;type>_lxi._tcp&lt;/type> &lt;port>80&lt;/port> &lt;txt-record>txtvers=1&lt;/txt-record> &lt;txt-record>Model=A-1234&lt;/txt-record> &lt;txt-record>SerialNumber=GWT123456&lt;/txt-record> &lt;txt-record>FirmwareVersion=V1.0.0.1.&lt;/txt-record> &lt;txt-record>Manufacturer=GWINSTEK&lt;/txt-record> &lt;/service> &lt;service> &lt;type>_http._tcp&lt;/type> &lt;port>80&lt;/port> &lt;/service> &lt;service> &lt;type>_scpi-raw._tcp&lt;/type> &lt;port>5025&lt;/port> &lt;/service> &lt;service> &lt;type>_scpi-telnet._tcp&lt;/type> &lt;port>5024&lt;/port> &lt;/service> &lt;service> &lt;type>_vxi-11._tcp&lt;/type> &lt;port>111&lt;/port> &lt;/service> &lt;service> &lt;type>_hislip._tcp&lt;/type> &lt;port>4880&lt;/port> &lt;/service> &lt;/service-group> 簡易測試在嵌入式系統端開啟服務 (root 帳號為例)$avahi-daemon 在 PC 端使用 avahi-unitls 測試，Ubuntu 為例# install $sudo apt-get install avahi-untils # test $avahi-browse -a | grep _lxi._tcp","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"avahi","slug":"avahi","permalink":"https://tsaiyuyan.github.io/tags/avahi/"},{"name":"mDNS","slug":"mDNS","permalink":"https://tsaiyuyan.github.io/tags/mDNS/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"cross-compiler","slug":"cross-compiler","permalink":"https://tsaiyuyan.github.io/tags/cross-compiler/"},{"name":"expat","slug":"expat","permalink":"https://tsaiyuyan.github.io/tags/expat/"},{"name":"uclinux","slug":"uclinux","permalink":"https://tsaiyuyan.github.io/tags/uclinux/"},{"name":"attr","slug":"attr","permalink":"https://tsaiyuyan.github.io/tags/attr/"}]},{"title":"TI-RTOS vxi11 儀器服務的實現_part1","slug":"TI-RTOS/TI-RTOS vxi11 儀器服務的實現_part1","date":"2020-04-10T02:00:00.000Z","updated":"2020-06-20T08:12:41.249Z","comments":true,"path":"2020/04/10/ti-rtos/ti-rtos-vxi11-yi-qi-fu-wu-de-shi-xian-part1/","link":"","permalink":"https://tsaiyuyan.github.io/2020/04/10/ti-rtos/ti-rtos-vxi11-yi-qi-fu-wu-de-shi-xian-part1/","excerpt":"","text":"參考連結: http://bbs.eeworld.com.cn/thread-526055-1-1.html 前言(垃圾話)LXI 設備: 符合 LXI 規範的儀器設備，我的理解是用網口通信的儀器設備就是 LXI 設備VXI-11：控制器和設備通過 TCP/IP 網絡通信的網絡儀器協儀RPC：遠程調用，基於 C/S 模型，一台計算機上的程序調用另一台計算機上的程序XDR：外部數據表示，就是在不同的計算機系統中轉換數據的格式，避免出現類似大小端的問題TI: 德州儀器 (Texas Instruments) 德州儀器是一家位於美國德克薩斯州達拉斯的跨國公司，以開發、製造、銷售半導體和計算機技術聞名於世，主要從事數位訊號處理與類比電路方面的研究、製造和銷售。它在 25 個國家有製造、設計或者銷售機構。 國家儀器股份有限公司（英語：National Instruments，縮寫 NI，NASDAQ：NATI）是一家美國公司，從事與測試、控制、設計領域相關的，包括虛擬儀器和電子測試設備等工程軟體的開發。著名產品有圖形開發環境 LabVIEW、C 語言虛擬儀器應用系統 LabWindows/CVI、集成電路分析程序 NI Multisim 等等；硬體產品包括 VXI 匯流排、PXI 匯流排、VME 匯流排的框架與模塊，IEEE-488 接口以及內部整合電路和其他自動化技術的標準 Issue:Implementing VXI-11 protocol in existing serial to ethernet for LXI compatibilityTI 的客戶曾經請求官方提供 vxi11 功能，但官方回應不支援，並鎖定討論串，有夠 777777，最後一篇原 PO 者還貼了一堆資訊然後就討論串被鎖了，當然我也是笑不出來啦，因為換我要開發這鬼咚咚。 回到正題，簡單來說 VXI-11 實現需要執行兩個服務，一個是 portmap service (port:111)，vxi11 service(port: range~range，range 根據 rpc code 是根據程式 pid 隨機產生出來的，所以就隨便定)。去 ni-visa 官網下載 ni-MAX， 相關文件 文件部分請參考我的 github vxi11.x typedef long Device_Link; enum Device_AddrFamily { DEVICE_TCP, DEVICE_UDP }; typedef long Device_Flags; typedef long Device_ErrorCode; struct Device_Error { Device_ErrorCode error; }; struct Create_LinkParms { long clientId; /* implementation specific value */ bool lockDevice; /* attempt to lock the device */ unsigned long lock_timeout; /* time to wait for lock */ string device&lt;>; /* name of device */ }; struct Create_LinkResp { Device_ErrorCode error; Device_Link lid; unsigned short abortPort; /* for the abort RPC */ unsigned long maxRecvSize; /* max # of bytes accepted on write */ }; struct Device_WriteParms { Device_Link lid; /* link id from create_link */ unsigned long io_timeout; /* time to wait for I/O */ unsigned long lock_timeout; /* time to wait for lock */ Device_Flags flags; /* flags with options */ opaque data&lt;>; /* the data length and the data itself */ }; struct Device_WriteResp { Device_ErrorCode error; unsigned long size; /* # of bytes written */ }; struct Device_ReadParms { Device_Link lid; /* link id from create_link */ unsigned long requestSize; /* # of bytes requested */ unsigned long io_timeout; /* time to wait for I/O */ unsigned long lock_timeout; /* time to wait for lock */ Device_Flags flags; /* flags with options */ char termChar; /* valid if flags &amp; termchrset */ }; struct Device_ReadResp { Device_ErrorCode error; long reason; /* why read completed */ opaque data&lt;>; /* the data length and the data itself */ }; struct Device_ReadStbResp { Device_ErrorCode error; unsigned char stb; /* the returned status byte */ }; struct Device_GenericParms { Device_Link lid; /* link id from create_link */ Device_Flags flags; /* flags with options */ unsigned long lock_timeout; /* time to wait for lock */ unsigned long io_timeout; /* time to wait for I/O */ }; struct Device_RemoteFunc { unsigned long hostAddr; /* host servicing interrupt */ unsigned long hostPort; /* valid port # on client */ unsigned long progNum; /* DEVICE_INTR */ unsigned long progVers; /* DEVICE_INTR_VERSION */ Device_AddrFamily progFamily; /* DEVICE_UDP | DEVICE_TCP */ }; struct Device_EnableSrqParms { Device_Link lid; /* link id from create_link */ bool enable; /* enable or disable intr's */ opaque handle&lt;40>; /* host specific data */ }; struct Device_LockParms { Device_Link lid; /* link id from create_link */ Device_Flags flags; /* contains the waitlock flag */ unsigned long lock_timeout; /* time to wait for lock */ }; struct Device_DocmdParms { Device_Link lid; /* link id from create_link */ Device_Flags flags; /* flags with options */ unsigned long io_timeout; /* time to wait for I/O */ unsigned long lock_timeout; /* time to wait for lock */ long cmd; /* which command to execute */ bool network_order; /* client's byte order */ long datasize; /* size of individual data elements */ opaque data_in&lt;>; /* docmd data parameters */ }; struct Device_DocmdResp { Device_ErrorCode error; opaque data_out&lt;>; /* returned data parameters */ }; program DEVICE_ASYNC { version DEVICE_ASYNC_VERSION { Device_Error device_abort (Device_Link) = 1; } = 1; } = 0x0607B0; program DEVICE_CORE { version DEVICE_CORE_VERSION { Create_LinkResp create_link (Create_LinkParms) = 10; Device_WriteResp device_write (Device_WriteParms) = 11; Device_ReadResp device_read (Device_ReadParms) = 12; Device_ReadStbResp device_readstb (Device_GenericParms) = 13; Device_Error device_trigger (Device_GenericParms) = 14; Device_Error device_clear (Device_GenericParms) = 15; Device_Error device_remote (Device_GenericParms) = 16; Device_Error device_local (Device_GenericParms) = 17; Device_Error device_lock (Device_LockParms) = 18; Device_Error device_unlock (Device_Link) = 19; Device_Error device_enable_srq (Device_EnableSrqParms) = 20; Device_DocmdResp device_docmd (Device_DocmdParms) = 22; Device_Error destroy_link (Device_Link) = 23; Device_Error create_intr_chan (Device_RemoteFunc) = 25; Device_Error destroy_intr_chan (void) = 26; } = 1; } = 0x0607AF; /****************************************************************************** * * vxi11intr.rpcl * * This file is best viewed with a tabwidth of 4 * ****************************************************************************** * * TODO: * ****************************************************************************** * * Original Author: someone from VXIbus Consortium * Current Author: Benjamin Franksen * Date: 03-06-97 * * RPCL description of the intr-channel of the TCP/IP Instrument Protocol * Specification. * * * Modification Log: * ----------------- * .00 03-06-97 bfr created this file * ****************************************************************************** * * Notes: * * This stuff is literally from * * \"VXI-11, Ref 1.0 : TCP/IP Instrument Protocol Specification\" * */ struct Device_SrqParms { opaque handle&lt;>; }; program DEVICE_INTR { version DEVICE_INTR_VERSION { void device_intr_srq (Device_SrqParms) = 30; } = 1; } = 0x0607B1; clone 示範代碼$git clone http://172.16.5.187:10080/tsaiyuyan/oncrpc_project.git $tree ├─oncrpc_ti-rtos_gw (被tsaiyuyan 移植到 TI-RTOS) │ ├─include rpc header files (被tsaiyuyan 修改過) │ │ └─rpc │ ├─portmap rpc source code (被tsaiyuyan 修改過) │ ├─src rpc source code (被tsaiyuyan 修改過) │ └─vxi11 vxi11 source code (被tsaiyuyan 修改過) └─oncrpc_win_gw (原始碼) ├─include rpc header files │ └─rpc ├─portmap rpc source code ├─src rpc source code ├─vxi11 vxi11 source code └─vxi11_x 有個 vxi11.x 為官網提供的模板搭配 rpcgen.exe 使用， vxi11 這個folder 的檔案就是靠 rpcgen 產生的。 如何使用 rpcgen for vxi11.x請參閱影片: https://youtu.be/haqsQjkJ90M vxi11 在 windows 示範請參閱影片: https://youtu.be/HD1JY9mEhRI 移植 vxi11 到 TI-RTOS 上 請參考下篇文章 vxi11 儀器服務的實現_part2 用 winmerge 比較 oncrpc_ti-rtos_gw 跟 oncrpc_win_gw 這兩個資料夾","categories":[{"name":"TI-RTOS","slug":"TI-RTOS","permalink":"https://tsaiyuyan.github.io/categories/TI-RTOS/"}],"tags":[]},{"title":"Vmware Windows虛擬機減肥筆記","slug":"Windows/Vmware Windows虛擬機減肥筆記","date":"2020-04-07T02:00:00.000Z","updated":"2020-05-11T07:35:19.227Z","comments":true,"path":"2020/04/07/windows/vmware-windows-xu-ni-ji-jian-fei-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2020/04/07/windows/vmware-windows-xu-ni-ji-jian-fei-bi-ji/","excerpt":"","text":"經過: 事情是這樣的，某天我想在 win10 開共用資料夾傳 60G 的檔案，但發現一直不能共用，公司給的 win10 好像有鎖住，於是我就把邪念用到我的 win7 虛擬機上，我在外部直接延伸了原本的系統碟到 120G，然後在虛擬機裡面，將配置的空間獨立成一顆硬碟。當我傳完檔案，也將檔案拉出來後，悲劇就發生了。我那虛擬機空間不管怎麼用都沒辦法 free 掉。 反省 下次如果還想掛硬碟傳檔案，就不要用 extend 的方法，直接對虛擬機加一顆 hard disk 就不會有這種悲劇問題了。 開始減肥虛擬機環境 Windows 7 Pro hard disk (MBR) 硬碟做過重組，清理，未使用空間填 0(但沒啥效果) 修復流程 準備 MiniTool Partition Wizard(google 搜尋即可找到官方載點)。 將虛擬機 掛上新的 Hard disk。 在虛擬機 內打開 MiniTool -&gt; Migrate OS -&gt; 然後選擇新硬碟-&gt;調整目標硬碟大小-&gt;finish-&gt;點左上打的 Apply，軟體會重新開機把系統整顆拷貝過去。 拷貝完成後，關閉虛擬機，將原本那個肥胖硬碟移除，開啟虛擬機。 然後你就會發現”autochk not found skipping autocheck“，然後一直重新開機。 先使用建議修復，會失敗，先別離開，然後選擇使用其他系統工具-&gt;點選命令提示字元。 照著以下命令 會發現你在 x: 碟底下 x:\\windows\\system32&gt;先確定有沒有 autochk.exe 這個檔案 x:\\windows\\system32&gt;dir C:\\windows\\system32如果沒有 x:\\windows\\system32&gt;copy .\\autochk.exe C:\\windows\\system32這時還沒做完 x:\\windows\\system32&gt;bcdboot c:\\windows等跑完 x:\\windows\\system32&gt;bootsect /nt60 all /mbr等跑完 重開機後會發現可以選擇安全模式，這時候選倒數第幾個(後面有括號的選項)，這時會成功進入 windows，成功進入後再重新開機會自動以一般模式進入，就成功登入了。 最後就是去虛擬機的資料夾把硬碟.vmdk 檔砍掉了(注意別砍到新的硬碟檔)。 ex: Windows 7 x64-0.vmdk Windows 7 x64-0-s001.vmdk Windows 7 x64-0-s002.vmdk Windows 7 x64-0-s003.vmdk Windows 7 x64-0-s004.vmdk Windows 7 x64-0-s005.vmdk Windows 7 x64-0-s006.vmdk Windows 7 x64-0-s007.vmdk Windows 7 x64-0-s008.vmdk Windows 7 x64-0-s009.vmdk Windows 7 x64-0-s010.vmdk Windows 7 x64-0-s011.vmdk以上是隨手筆記。 參考連結https://superuser.com/questions/499468/windows-7-boot-fails-autochk-not-found-skipping-autocheck","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[{"name":"note","slug":"note","permalink":"https://tsaiyuyan.github.io/tags/note/"},{"name":"vmware","slug":"vmware","permalink":"https://tsaiyuyan.github.io/tags/vmware/"}]},{"title":"1342. Number of Steps to Reduce a Number to Zero","slug":"Leetcode/1342_Number of Steps to Reduce a Number to Zero","date":"2020-04-06T03:00:00.000Z","updated":"2020-09-28T07:49:56.717Z","comments":true,"path":"2020/04/06/leetcode/1342-number-of-steps-to-reduce-a-number-to-zero/","link":"","permalink":"https://tsaiyuyan.github.io/2020/04/06/leetcode/1342-number-of-steps-to-reduce-a-number-to-zero/","excerpt":"","text":"Link: https://leetcode.com/problems/number-of-steps-to-reduce-a-number-to-zero/ Given a non-negative integer num, return the number of steps to reduce it to zero. If the current number is even, you have to divide it by 2, otherwise, you have to subtract 1 from it. Example 1: Input: num = 14 Output: 6 Explanation: Step 1) 14 is even; divide by 2 and obtain 7. Step 2) 7 is odd; subtract 1 and obtain 6. Step 3) 6 is even; divide by 2 and obtain 3. Step 4) 3 is odd; subtract 1 and obtain 2. Step 5) 2 is even; divide by 2 and obtain 1. Step 6) 1 is odd; subtract 1 and obtain 0. Example 2: Input: num = 8 Output: 4 Explanation: Step 1) 8 is even; divide by 2 and obtain 4. Step 2) 4 is even; divide by 2 and obtain 2. Step 3) 2 is even; divide by 2 and obtain 1. Step 4) 1 is odd; subtract 1 and obtain 0. Example 3: Input: num = 123 Output: 12 Constraints: 0 &lt;= num &lt;= 10^6 題目翻譯: X 程式思路: 直接硬幹 class Solution { public: int numberOfSteps (int num) { int output = 0; while(num != 0) { if(num%2 == 1) num--; else num >>= 1; output ++; } return output; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1108. Defanging an IP Address","slug":"Leetcode/1108_Defanging an IP Address","date":"2020-04-06T02:00:00.000Z","updated":"2020-09-28T07:49:57.821Z","comments":true,"path":"2020/04/06/leetcode/1108-defanging-an-ip-address/","link":"","permalink":"https://tsaiyuyan.github.io/2020/04/06/leetcode/1108-defanging-an-ip-address/","excerpt":"","text":"Link: https://leetcode.com/problems/defanging-an-ip-address/ Given a valid (IPv4) IP address, return a defanged version of that IP address. A defanged IP address replaces every period “.” with “[.]”. Example 1: Input: address = \"1.1.1.1\" Output: \"1[.]1[.]1[.]1\" Example 2: Input: address = \"255.100.50.0\" Output: \"255[.]100[.]50[.]0\" Constraints: The given address is a valid IPv4 address. 題目翻譯: X 程式思路: 直接硬幹 class Solution { public: string defangIPaddr(string address) { string output; for(auto ptr : address) { if(ptr!='.') output+=ptr; else output+=\"[.]\"; } return output; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"Python - Signal Recovery","slug":"Python/Python - Signal Recovery","date":"2020-03-23T02:00:00.000Z","updated":"2020-07-02T01:34:04.420Z","comments":true,"path":"2020/03/23/python/python-signal-recovery/","link":"","permalink":"https://tsaiyuyan.github.io/2020/03/23/python/python-signal-recovery/","excerpt":"","text":"以前在做天空偵測的時候也類似目前的 case，也就是呢，我們要先分析客戶給的信號圖，在進行必要的裁剪、銳化細節、canny 邊緣檢測，在跟據最後 canny 的圖將信號畫好，(至於說為啥我要做那些步驟，阿就試出來的，我最愛做的就是 try error 這種繁瑣的事情) 設計流程以這張圖為例，我們可以看到上下方約 1/3 都是我們不需要的東西，所以我們進行 crop image 的動作 。再來就是那些該死的示波器背景，等等我們就用 blur 把它濾掉，因為輸入屬於中型圖片，所以 blur 我們使用[5,5]的強度。 後面畫細節是由上到下，取最高最低兩個點，如果沒有發現像素點就會沿用前一條線高低點。當然這還是有改善空間，模糊不知道用高斯模糊效果好不好，還有很多可以試試看。但因為這件事貌似沒那麼急，就暫時先告一段落，如果有後續發展，會再繼續更新本篇。 調整出來步驟為 step1: crop image 裁剪原圖 step2: floodfill image 嘗試塗掉背景 &lt;== 強度應該可以再調整 step3: kernel image 銳化留下來的部分,’[[0, -1, 0], [-1, 5, -1], [0, -1, 0]’ step4: blur image 抹掉細節(模糊),’[5,5]’ &lt;== 或許可以用高斯模糊 step5: canny image 100,200 邊緣檢測 &lt;== sobel 展現的效果不好，所以還是用canny step6: result image 畫線 0QD8imz4.pngoriginal(已移除) (20200702移除) canny result folder Tree$tree D:. └─gw_signal_recovery ├─input ├─output └─tmp codefrom os.path import isfile, join from os import listdir import matplotlib.pyplot as plt import numpy as np from PIL import Image from PIL import ImageFilter import cv2 # if not found,try pip install opencv-python import os print(\"Change the current working directory to path:\", os.path.dirname(__file__)) os.chdir(os.path.dirname(__file__)) onlyfiles = [f for f in listdir(\"./input\") if isfile(join(\"./input\", f))] print(onlyfiles) ''' 3YljKfLQ.png 4B2Dcn2o.png 8dJosPug.png 8uS7qspI.png buY6cs6U.png Clqh9OD0.png DH1QeME4.png jyicdNJM.png KsJUDLN0.png m-GNRpbw.png TO5-rs9o.png u4J8dZ7o.png VvCGeC4o.png ''' # 將波形以外的背景填成白色 def floodfill_image(image, power): copyImage = image.copy() # 複製原圖像 h, w = image.shape[:2] # 讀取圖像的寬和高 mask = np.zeros([h+2, w+2], np.uint8) # 新建圖像矩陣 +2是官方函數要求 cv2.floodFill(copyImage, mask, (517, 260), (255, 255, 255), (power, power, power), (power, power, power), cv2.FLOODFILL_FIXED_RANGE) #cv.imshow(\"floodFill\", copyImage) return copyImage # 將canny最後結果填上白色 def result_image(image): copyImage = image.copy() rows, cols = copyImage.shape tmp_top = 0 tmp_down = 0 # 圖片大小 # print(str(rows),\",\",str(cols)) for i in range(cols): top = 0 down = rows for j in range(rows): k = copyImage[j, i] if(k > 100): if (j > top): top = j if (j &lt; down): down = j if(down - top > rows/2): cv2.line(copyImage, (i, tmp_top), (i, tmp_down), (255, 255, 255), 1) #print(\"top =\" + str(tmp_top) +\",down =\"+str(tmp_down)) else: cv2.line(copyImage, (i, top), (i, down), (255, 255, 255), 1) tmp_top = top tmp_down = down return copyImage def cv2_show_img(title, img, is_save): cv2.imshow(title, img) if(is_save): cv2.imwrite(\"output\\\\\" + title, img) index = 0 #方便檔案總管排序 # === main === for file in onlyfiles: src = cv2.imread(\"input\\\\\" + file) H, W, channels = src.shape # 裁切區域的 x 與 y 座標（左上角） x = 10 y = 90 # （右下角） x1 = W-30 y1 = 545 crop_img = src[y:y1, x:x1] cv2_show_img(str(index) + \"_1_original_\" + file , src, True) #cv2.imshow(\"crop_img\", crop_img) # flood fill 邊緣偵測 ff_img = floodfill_image(crop_img, 35) #cv2.imshow(\"floodfill\", ff_img) # blur 模糊 blur = cv2.blur(ff_img, (5, 5)) # 中型圖片 #cv2.imshow(\"blur\", blur) # kernel 銳化 kernel = np.array([[0, -1, 0], [-1, 5, -1], [0, -1, 0]], np.float32) kernel_img = cv2.filter2D(blur, -1, kernel=kernel) #cv2.imshow(\"kernel\", kernel_img) # canny 邊緣偵測 canny = cv2.Canny(kernel_img, 100, 200) cv2_show_img(str(index) + \"_2_canny_\" + file, canny, True) # sobel 邊緣偵測(未使用) ''' Gx = cv2.Sobel(blur,cv2cv.CV_16S,1,0) Gy = cv2.Sobel(blur,cv2.CV_16S,0,1) absX = cv2.convertScaleAbs(Gx) absY = cv2.convertScaleAbs(Gy) dst = cv2.addWeighted(absX,0.5,absY,0.5,0) cv2.imshow(\"absX\", absX) cv2.imshow(\"absY\", absY) cv2.imshow(\"sobel\", dst) ''' result_img = result_image(canny) cv2_show_img(str(index) + \"_3_result_\" + file, result_img, True) # 按任一鍵繼續下一張 cv2.waitKey(0) cv2.destroyAllWindows() index += 1 Result3YljKfLQ.png 4B2Dcn2o.png 8dJosPug.png 8uS7qspI.png buY6cs6U.png Clqh9OD0.png DH1QeME4.png jyicdNJM.png KsJUDLN0.png m-GNRpbw.png TO5-rs9o.png u4J8dZ7o.png VvCGeC4o.png","categories":[{"name":"Python","slug":"Python","permalink":"https://tsaiyuyan.github.io/categories/Python/"}],"tags":[{"name":"side-project","slug":"side-project","permalink":"https://tsaiyuyan.github.io/tags/side-project/"}]},{"title":"About Yu-Yan Tsai (Yuyan) - CV","slug":"About Yu-Yan Tsai (Yuyan) - CV","date":"2020-03-18T02:00:00.000Z","updated":"2021-12-27T03:16:45.904Z","comments":true,"path":"2020/03/18/about-yu-yan-tsai-yuyan-cv/","link":"","permalink":"https://tsaiyuyan.github.io/2020/03/18/about-yu-yan-tsai-yuyan-cv/","excerpt":"","text":"Yu-Yan Tsai(Ezio)Email: st3265987410@gmail.com Phone: +886-923-XXX-XXX Blog: https://tsaiyuyan.github.io/ EDUCATIONFebruary 2014 – June 2015 (Taipei, Taiwan) National Taipei University of TechnologyMaster of Science in Electrical EngineeringRank in Department: (5/107) September 2010 – January 2014 (Taipei, Taiwan) National Taipei University of TechnologyBachelor of Science in Electrical EngineeringRank in Department: (2/147) WORK EXPERIENCEAdvantech. (New Taipei, Taiwan) Backend Engineer(May 2020 – Present) Linux kernel development and debug Windows/Linux driver development, and debug. Linux utility design, development and maintenance. IoT device SDK development. Edge Device service porting. (OpenWrt or Buildroot) Modbus slave/master test tool development. GW INSTEK INC. (New Taipei, Taiwan) Backend Engineer(November 2017 – May 2020) Developed LXI service on TI-RTOS(embedded system) to get the LXI license and improve instrument product competitiveness. Developed Touch CC(UI application) and integrate different types of alarms, RESTful API, Monitoring and customization function etc for Thai MRT Red Line. BRONCI TECHNOLOGY INC.(Taipei, Taiwan) Backend Engineer(July 2015 – August 2016) Designed a Monitor system to detect cloud server error, and instantly notify MIS and principal. In addition, improved Server stability and efficiency. Code Guys Case Job Team/Freelancer (Taipei, Taiwan) Backend Engineer(February 2014 – September 2015) Engineered the next generation powder divider system for Taipei City Hospital Assited the development of gene data analysis system for Hepatic cancer, Cheng Hsin General Hospital that allowed the use of SVM to classify mRNA/RNA and predict potential genetic problems RESEARCH AND PUBLICATIONSNational Taipei University of Technology THESIS : The Research and Implementation of Advance DNS(February 2014 – July 2015) This paper presents Advanced Domain Name System (ADNS), processing each IP protocol network transport protocol in the transport layer application layer Transmission Control Protocol (TCP) is transferred between the User Datagram Protocol (UDP), and the method aims to achieve P2P peer spirit Teaching and Research Assistant(September 2014 - January 2015) Provided technical support for Object-oriented programming and relevant lesson. Improve portable network modules for National Taiwan University Computer and Information Networking Center Ankeng Project(July 2013 – January 2014) Advisor: Prof. Shaw-Hwa Hwang National Central University Foresight Technology Research Center’s 102-year Project Research Project High-speed Password Recovery integrated central control system. Password recovery, brute force cracking, dictionary file comparison, and distributed computing. AWARDS AND COMPETITIONSTeam leader of Hewlett-Packard 2013 Codewars Taiwan Algorithm program trainer. Recipient of: Electrical Engineering Conference Student Representative 2015 National Taipei University of Science and Technology Elite Scholarship 2014~2015 Lin Hsiung Chen Foundation Scholarship 2013 Outstanding College Youth from Department of Electrical Engineering 2012 Holy Stone Foundation Scholarship 2012 and 2013 Mr. Jiang Jianbo Memorial Scholarship 2011 TECHNICAL SKILLS A problem-solver,strong analytical and problem-solving skills Software development experience on Windows, Linux, TI-RTOS. Expertise in C programming, Multi-threaded programming, socket programming Experience with Open Source software development Design/implement for performance, modularity, and portability Excellent team communication, and interpersonal skills Blogging","categories":[{"name":"interview","slug":"interview","permalink":"https://tsaiyuyan.github.io/categories/interview/"}],"tags":[]},{"title":"Python - Download all pdf files from a website","slug":"Python/Python - Download all pdf files from a website","date":"2020-03-13T02:06:00.000Z","updated":"2020-06-20T09:50:49.310Z","comments":true,"path":"2020/03/13/python/python-download-all-pdf-files-from-a-website/","link":"","permalink":"https://tsaiyuyan.github.io/2020/03/13/python/python-download-all-pdf-files-from-a-website/","excerpt":"","text":"本篇算是我第一次寫的 python，所以是筆記不是教學，如果有建議或疑問，歡迎下方留言討論。 1.目標希望能下載此頁面，所有的 pdf 檔 用 chrome 打開後，右鍵檢視原始碼，會發現裡面其實看不到任何.pdf 檔的連結，所以我猜想是這頁面利用載入其他的頁面將其他連結內的.pdf 嵌入近來。所以我會先開啟主頁然後檢查主頁裡面的連結，在深入訪問連結看裡面是否有.pdf 的連結，如果有就下載。 2.設計思路 分析網頁元素。 =&gt; 右鍵檢視原始碼 確認目標檔案連結。 =&gt; &lt;href&gt; coding &amp; debug。 流程檢驗、改善、例外處理。 3.function網頁連線 def try_web_connect (url ) : tries = 5 while (tries): try: page = requests.get(url,headers={'Connection':'close'}) if(page.status_code == 200): return page else : raise 'error' except: print(\"Connection refused by the server..,sleep for 3 seconds\") time.sleep(3) tries -=1 continue return None 下載檔案 save_folder = 'I:\\\\py_downloads\\\\' def download(url): #獲取檔名 filename = url[url.rfind(\"/\")+1:] full_path = save_folder + filename if os.path.isfile(full_path): print (\"File exist :\" + full_path ) return r = try_web_connect(url) if r is None : return if(r.status_code == 200): print(full_path) return open(full_path, 'wb').write(r.content) else: return -1 4.程式碼import requests import os.path from bs4 import BeautifulSoup import time host_url='https://tmi.yokogawa.com/cn/library/search/#/t=5' save_folder = 'I:\\\\py_downloads\\\\' keywords = '.pdf' exclude_web = set() f = open(save_folder + \"finish_url\",'r') finish_url = f.readlines() f.close() def real_time_update_finish_url(want_url): exclude_web.add(want_url) #做完的網頁加入已完成url 並且存檔 # 網頁完成的條件為 1.回應為200 或是 2.無效url 或是 3.原本就排除的網頁finish_url with open(save_folder + \"finish_url\", 'w') as f: for item in exclude_web: f.write(\"%s\\n\" % item) def try_web_connect (url ) : tries = 5 while (tries): try: page = requests.get(url,headers={'Connection':'close'}) if(page.status_code == 200): return page else : raise 'error' except: print(\"Connection refused by the server..,sleep for 5 seconds\") time.sleep(3) tries -=1 continue return None def download(url): filename = url[url.rfind(\"/\")+1:] full_path = save_folder + filename if os.path.isfile(full_path): print (\"File exist :\" + full_path ) return r = try_web_connect(url) if r is None : return if(r.status_code == 200): print(full_path) return open(full_path, 'wb').write(r.content) else: return -1 def enter_download_page(url): r = try_web_connect(url) # https://tmi.yokogawa.com/industries/motors-drives/ if r is None : return print(r.status_code) # print(type(r)) # print(type(html_str)) s = set() if(r.status_code == 200): html_str = r.text soup = BeautifulSoup(html_str, 'html.parser') a_tags = soup.find_all('a') for tag in a_tags: url = str(tag.get('href')) if url.find(keywords) != -1: s.add(url) real_time_update_finish_url(want_url) else: print('enter_download_page http request error!') for ss in s: print('downloading:' + ss) if ss.find('http') == 0: print('invalid address!') return else : download('https:' + ss) # https://tmi.yokogawa.com/industries/motors-drives/ r = try_web_connect(host_url) if(r.status_code == 200): url_sets = set() html_str = r.text print(r.status_code) soup = BeautifulSoup(html_str, 'html.parser') a_tags = soup.find_all('a') # 加入網頁中所有超連結元素到 url_sets for tag in a_tags: url = str(tag.get('href')) # 原本想過濾超連結 #if url.find('industries') != -1: url_sets.add(url) for item in url_sets: want_url = 'https://tmi.yokogawa.com' + item print(want_url) if any(want_url in y for y in finish_url): print('had finished download!') real_time_update_finish_url(want_url) else : if item.find('http') != -1: print('invalid address!') real_time_update_finish_url(want_url) else : enter_download_page(want_url) else: print('http request error!')","categories":[{"name":"Python","slug":"Python","permalink":"https://tsaiyuyan.github.io/categories/Python/"}],"tags":[{"name":"side-project","slug":"side-project","permalink":"https://tsaiyuyan.github.io/tags/side-project/"}]},{"title":"About Yu-Yan Tsai (Yuyan) - Resume","slug":"About Yu-Yan Tsai (Yuyan) - Resume","date":"2020-03-12T02:06:00.000Z","updated":"2021-12-14T06:07:01.248Z","comments":true,"path":"2020/03/12/about-yu-yan-tsai-yuyan-resume/","link":"","permalink":"https://tsaiyuyan.github.io/2020/03/12/about-yu-yan-tsai-yuyan-resume/","excerpt":"","text":"自我介紹Hello ! I’m Yuyan, A problem-solver, strong analytical and problem-solving skills Software development experience on Windows, Linux, TI-RTOS. Expertise in C programming, Multi-threaded programming, socket programming Experience with Open Source software development within an embedded system. Design/implement for performance, modularity, and portability Excellent team communication, and interpersonal skills Blogging 我使用 C 語言的經驗長達 6~7 年，現在主要在幫公司的儀器開發 LXI (儀器擴展乙太網路標準)。通過 LXI 認證，儀器就相較於其他品牌更有競爭力。另外也善於 Socket 網路程式開發。閒暇時間喜歡幫同事做一些程式流程、效能盲點檢查，彼此交流提升程式品質。 對於除錯這件事情有獨鍾，因為找到錯誤，就能吸取更多經驗，在未來碰到問題，可以更有效率的解決。所以我非常喜歡跟別人一起組隊開發和除錯。 另外我也有寫部落格的習慣，希望藉由寫部落格記錄當下的情境、解題思維、流程和注意事項，以便日後交流更能有效傳達給對方。 個人資料Email st3265987410@gmail.com Blog https://tsaiyuyan.github.io/ 常用工具back-end gcc/g++/gdb (complier tool) git/github/gitlab (Version control tool) VS2017/MFC (VC++ IDE) socket API mantis (Bug Tracker) wireshark (Packet analyzer) uniflash / CCS (TI-RTOS development) Inno Setup (free installer for Windows programs) 經歷研華有限股份公司(202005 – 至今)Backend Engineer Linux kernel development and debug. Windows/Linux driver development and debug. Linux utility design, development and maintenance. IoT device SDK development. Edge Device service porting. (OpenWrt) 固緯有限股份公司電源軟體部 (201904-202005) Backend Engineer 開發 LXI 儀器擴展乙太網路標準，提升產品競爭力。 開發設備搜尋服務(mDNS)，讓儀器可以在乙太網路自動定址，簡化測試系統整合流程，降低測試系統設計與維護的相關成本。 成功實作 vxi11 功能到 TI-RTOS(without OS) 嵌入式系統。 (TI 的客戶曾經請求官方提供 vxi11 功能，但官方回應不支援，並鎖定討論串(Link)。 所以即使官方不支援這協定，我也能成功進行客製化，將該功能實作出來。 重構儀器的網頁伺服器代碼，減少技術債，優化記憶體使用率，並解決長久以來記憶體不足的死當 bug，也提升程式碼可讀性，以利後續維護。(重構儀器代碼是我主動跟主管提出，因為經歷了 2 任工程師約 3 年多的時間，都沒有解決網頁伺服器致命 bug) 影像安防部 (201711-201904) Backend Engineer 泰國捷運紅線 800 萬專案，在公司要求必須 cost-down 低階車載機種下(CPU為Intel® Atom® E3827 2C @1.75 GHz, TDP: 8W)，開發車載監控軟體。環境規格 撰寫 NVR 自動排程產生健康報表工具，讓產品數據化。 協助 Player Team 的 RD 改善浮水印運算所花費的時間，效能提升將近 4 倍。 優化公司軟體升級流程，縮短產線跟 QA 檢驗時間，效率提升約 2 倍。 維護影像管理軟體 協助 QA 撰寫網卡不相容轉換腳本(shell script)，減少人工手動轉換流程，以利自動化，不用每次到現場協助客戶使用，省下外縣市出差時間。 長問有限股份公司(201507-201608)Server Team Backend Engineer 從無到有開發公司的雲伺服器監控系統，大幅提升伺服器故障維修效率。 撰寫平台網路測試工具，伺服器服務效能數據化，在推銷公司產品時，客戶有數據參考。 撰寫各種自動化測試腳本，網頁異常、DB 檢測、傳輸速率、硬體容量偵測檢查等…腳本或是應用程式小工具，上傳監控系統後，可自動驗證各項伺服器功能是否正常，也讓 MIS 跟 R&amp;D 能即時了解伺服器狀況。 改善並維護可攜帶式網路模組，並加入 SSL 協定，滿足客戶需求加密規格。 監控系統負責人，維護各項雲伺服器。 安坑專案，平行運算系統維護與支援。 Side-Project 國澤有限公司 委託開發聯合醫院(中興院區、仁愛院區、婦幼院區、忠孝院區) 分包機軟體，直至今日。本軟體每年依舊服務上萬人次(各院區)。 協助振興醫院盧凱熙醫生，開發基因演算法巨量資料匯入 excel 腳本，限定使用 VB 開發。 協助改善實驗室學姊的語音辨識光束演算法辨識率，辨識率 38% -&gt; 81%， 撰寫自動打卡 (C# + 按鍵精靈)，減少同仁對學校的行政雜事，增加更多開發時間。 用 javascript 撰寫自動登入填寫搶票腳本並且掛入 chrome 擴充功能，成功搶到林宥嘉跟五月天)腳本。 主管要求，寫一隻 python 爬蟲，下載大量檔案，減少手動時間，以利自動化。連結。 主管指派，協助 MIS 處理網頁伺服器外包導致舊網域無效問題。 協助同事撰寫 shell-script 腳本,開機建置和 xml 轉換腳本，優化系統開機流程，減少手動安裝時間。 主管要求，問我能不能將客戶給的波形圖片，將波形取出來，以便訊號產生器做匯入，我用 python+opencv，運用以前做數位影像處理做天空偵測的概念，進行實作。連結 其他補充Team leader of Hewlett-Packard 2013 Codewars Taiwan Algorithm program trainer. 學歷 台北科技大學 日間部 電機工程系(201402-201506) 碩論: Adavance Domain Name System 台北科技大學 日間部 電機工程所(201306-201401) 專題: 雲端平行運算系統，安坑專案。 National Central University Foresight Technology Research Center’s 102-year Project Research Project High-speed Password Recovery integrated central control system. Password recovery, brute force cracking, dictionary file comparison, and distributed computing. Honor/Award Name of Honor/Award Qualification for the Honor/Award Prize Year 個人書卷獎 全班級 2 2013/9 個人書卷獎 全班級 2 2011/3 個人書卷獎 全班級 1 2013/2 個人書卷獎 全班級 3 2012/9 最終畢業名次 全系 2 2016/5 Recipient of: Electrical Engineering Conference Student Representative 2015 National Taipei University of Science and Technology Elite Scholarship 2014~2015 Lin Hsiung Chen Foundation Scholarship 2013 Outstanding College Youth from Department of Electrical Engineering 2012 Holy Stone Foundation Scholarship 2012 and 2013 Mr. Jiang Jianbo Memorial Scholarship 2011","categories":[{"name":"interview","slug":"interview","permalink":"https://tsaiyuyan.github.io/categories/interview/"}],"tags":[]},{"title":"Apache Rewrite with Htaccess","slug":"Apache Rewrite with Htaccess","date":"2020-03-06T02:00:00.000Z","updated":"2020-05-11T07:35:19.082Z","comments":true,"path":"2020/03/06/apache-rewrite-with-htaccess/","link":"","permalink":"https://tsaiyuyan.github.io/2020/03/06/apache-rewrite-with-htaccess/","excerpt":"","text":"參考網址:Apache Rewrite with Htaccess 理解與技巧 .htaccess (YuYan’s example):#開啟 Rewrite RewriteEngine On #http://www.gwinstek.com.tw/tw/faq/faqquestionlist.aspx?bid=33 #to #https://www.gwinstek.com/en-global/faq/index?cate=55&subcate=92&ser=82&key= RewriteCond ${REQUEST_URI} ^/tw/faq/faqquestionlist.aspx RewriteCond ${QUERY_STRING} bid=33 RewriteRule ^tw/faq/faqquestionlist.aspx(.*) en-global/faq/index?cate=55&subcate=92&ser=82&key= [R=301,L] #http://www.gwinstek.com/en-global/FaqSearch/faqs #to #https://www.gwinstek.com/en-global/faq/index RewriteCond ${REQUEST_URI} ^/en-global/FaqSearch/faqs RewriteRule ^en-global/FaqSearch/faqs(.*) /en-global/faq/index$1 [R=301,L] (下略) Note OS為Centos Apache 2.2，利用 .htaccess 進行轉址。 多個RewriteCon 配一個RewriteRule(也可以多個) ^ 表示前段匹配 -f 表示文件是否存在flag -d 表示資料夾是否存在 [R=301,L] R表示回應的HTTP code 通常為301 or 302， L表示如果做完就不會再進行Rewrite 動作(類似 C 語言的return) RewriteCond [test_string] [match_string] [flags] RewriteRule … - test_string：要比對的條件 - match_string：符合的條件 %{REQUEST_URI}：Domain 後面完整的 URI Path，Rule 其實會拿到不完整的 URI，詳情可以參考「五、一些小特性」段落 %{QUERY_STRING}：後面 GET 帶的參數 %{HTTP_HOST}：Domain %{HTTP_COOKIE}：Cookie %{HTTPS}：判斷是否用 https 或 http，如果是 https 就等於「on」，否則為&quot;off&quot; %{HTTP_USER_AGENT}：User Agent %{REQUEST_FILENAME}：訪問的檔案名稱實際案例(許願清單) Old New http://www.gwinstek.com/en-global/FaqSearch/faqs https://www.gwinstek.com/en-global/faq/index http://www.gwinstek.com/en-global/Form/contact_us_form https://www.gwinstek.com/en-global/contact_us/index http://www.gwinstek.com/en-global/Support/download https://www.gwinstek.com/en-global/download/index http://www.gwinstek.com.tw/tw/index.aspx http://www.gwinstek.com http://www.gwinstek.com.tw/tw/faq/faqquestionlist.aspx?bid=106 https://www.gwinstek.com/en-global/faq/index?cate=105&amp;subcate=248&amp;ser=562&amp;key= http://www.gwinstek.com.tw/tw/salescontact.aspx https://www.gwinstek.com/en-global/contact_us/index http://www.gwinstek.com.tw/tw/faq/faqquestionlist.aspx?bid=33 https://www.gwinstek.com/en-global/faq/index?cate=55&amp;subcate=92&amp;ser=82&amp;key=","categories":[{"name":"ezio_worklog","slug":"ezio-worklog","permalink":"https://tsaiyuyan.github.io/categories/ezio-worklog/"}],"tags":[{"name":"side-project","slug":"side-project","permalink":"https://tsaiyuyan.github.io/tags/side-project/"}]},{"title":"LXI 檢測mdns服務方法","slug":"LXI 檢測mdns服務方法","date":"2019-12-02T06:00:00.000Z","updated":"2020-05-11T07:35:19.113Z","comments":true,"path":"2019/12/02/lxi-jian-ce-mdns-fu-wu-fang-fa/","link":"","permalink":"https://tsaiyuyan.github.io/2019/12/02/lxi-jian-ce-mdns-fu-wu-fang-fa/","excerpt":"","text":"使用 LXI Discovery Tool (Windows 平台)官網簡單介紹: LXI Discovery Tool About 1.下載前先去蘋果官網下載 Bonjour 服務，在搜尋欄填上”Bonjour download”，下載後並執行安裝。 Apple Support 2.接著在 LXI 的官網下載 LXI Discovery Tool LXI Discovery Tool Resource 下面有載點:To download the LXI Discovery Tool 使用 avahi-browser (Ubuntu 平台)#終端機安裝 avahi-utils $sudo apt-get install avahi-utils #執行測試 $avahi-browse -a or $avahi-browse -a |grep _lxi._tcp 使用 Bonjour Browser(Windows 平台)前往Bonjour Browser for Windows然後點選下載，安裝即可使用。","categories":[{"name":"LXI","slug":"LXI","permalink":"https://tsaiyuyan.github.io/categories/LXI/"}],"tags":[{"name":"avahi","slug":"avahi","permalink":"https://tsaiyuyan.github.io/tags/avahi/"},{"name":"mDNS","slug":"mDNS","permalink":"https://tsaiyuyan.github.io/tags/mDNS/"}]},{"title":"Ubuntu avahi-daemon 移植 ADSP-BF531(bfin-uclinux)","slug":"Linux/Ubuntu avahi-daemon 移植 ADSP-BF531(bfin-uclinux)","date":"2019-11-29T06:00:00.000Z","updated":"2022-07-18T01:55:22.171Z","comments":true,"path":"2019/11/29/linux/ubuntu-avahi-daemon-yi-zhi-adsp-bf531-bfin-uclinux/","link":"","permalink":"https://tsaiyuyan.github.io/2019/11/29/linux/ubuntu-avahi-daemon-yi-zhi-adsp-bf531-bfin-uclinux/","excerpt":"","text":"mDNS 協議介紹mDNS 原理的簡單理解——每個進入局域網的主機，如果開啟了 mDNS 服務的話，都會向局域網內的所有主機組播一個消息，我是誰，和我的 IP 地址是多少。然後其他也有該服務的主機就會響應，也會告訴你，它是誰，它的 IP 地址是多少。 mDNS multicast DNS , 使用 5353 端口，組播地址 224.0.0.251。在一個沒有常規 DNS 服務器的小型網絡內，可以使用 mDNS 來實現類似 DNS 的編程接口、包格式和操作語義。 MDNS 協議的報文與 DNS 的報文結構相同，但有些字段對於 MDNS 來說有新的含義。 每個進入局域網的主機，如果開啟了 mDNS 服務的話，都會向局域網內的所有主機組播一個消息，我是誰，和我的 IP 地址是多少。然後其他也有該服務的主機就會響應，也會告訴你，它是誰，它的 IP 地址是多少。 mDNS 的域名與普通 DNS 的域名是通過後綴.local 區分開來的。如果一台終端需要訪問一個 mDNS 域名，他就會向局域網內發送組播，詢問該域名的 IP 是多少。 例如： 一個設備接入網絡，首先查詢名稱是否衝突，並通告當前服務器信息 衝突檢測結束後，發送 MDNS 通告，通知其它設備更新 DNS 緩存 其它設備對該域名訪問時，會發起 MDNS 查詢。 avahi-daemon 移植 ADSP-BF531(bfin-uclinux)1.下載 4 個 tar 包 libdaemon-0.14.tar.gz avahi-0.7.tar.gz expat-2.2.9.tar.bzip attr-2.5.1.tar.gz 自行解壓縮到指定資料夾，本文示範如下 $ tree -L 1 ~/Desktop/avahi-daemon-XXXXX/ /home/yuyan/Desktop/avahi-daemon-XXXXX/ ├── avahi-0.7 ├── expat-2.2.9 ├── libdaemon-0.14 └── attr-2.5.1 4 directories, 0 files 2.編譯 libdaemon#因為產生再/opt底下，所以切至root權限 $sudo -s #讓root帳號辨別toolchain位置 $export PATH=$PATH:/opt/uClinux/bfin-uclinux/bin #設置 $./configure --host=bfin-uclinux \\ --prefix=/opt/ADSP-BF531/libdaemon \\ CC=bfin-uclinux-gcc \\ --config-cache #錯誤訊息: configure: error: cannot check setpgrp when cross compiling #訂正方法: $echo \"ac_cv_func_setpgrp_void=yes\" > config.cache # 再次執行 $./configure --host=bfin-uclinux \\ --prefix=/opt/ADSP-BF531/libdaemon \\ CC=bfin-uclinux-gcc \\ --config-cache $make $make install 3.編譯 libexpat (如果 toolchain 沒有的話)#解壓縮 $bzip2 -d expat-2.2.9.tar.bz2ls $tar xvf expat-2.2.9.tar./ #因為要產生在/opt底下，所以切至root權限 $sudo -s #讓root帳號辨別toolchain位置 $export PATH=$PATH:/opt/uClinux/bfin-uclinux/bin $./configure --host=bfin-uclinux --prefix=/opt/ADSP-BF531/expat-2.2.9 CC=bfin-uclinux-gcc $make $make install 4.編譯 libattr (如果 toolchain 沒有的話) (20220718 補充) 編譯流程跟expat差不多 &lt;= 有需要調整請自行修正 #解壓縮 $tar zxvf attr-2.5.1.tar.gz #讓root帳號辨別toolchain位置 $sudo -s $export PATH=$PATH:/opt/uClinux/bfin-uclinux/bin $./configure --host=bfin-uclinux --prefix=/opt/ADSP-BF531/attr CC=bfin-uclinux-gcc $make $make install 5.編譯 avahi 這邊目的只在於編譯 avahi-daemon，所以其他的工具都會 disable。 Optional Features: opertion description –disable-option-checking ignore unrecognized –enable/–with options –disable-FEATURE do not include FEATURE (same as –enable-FEATURE=no) –enable-FEATURE[=ARG] include FEATURE [ARG=yes] –enable-silent-rules less verbose build output (undo: “make V=1”) –disable-silent-rules verbose build output (undo: “make V=0”) –enable-dependency-tracking do not reject slow dependency extractors –disable-dependency-tracking speeds up one-time build –disable-stack-protector Disable GCC’s/libc’s stack-smashing protection –enable-shared[=PKGS] build shared libraries [default=yes] –enable-static[=PKGS] build static libraries [default=yes] –enable-fast-install[=PKGS] optimize for fast installation [default=yes] –disable-libtool-lock avoid locking (might break parallel builds) –disable-nls do not use Native Language Support –disable-rpath do not hardcode runtime library paths –disable-glib Disable use of GLib –disable-gobject Disable use of GLib GObject –enable-introspection=[no/auto/yes] Enable introspection for this build –disable-libevent Disable use of libevent –enable-qt3 Enable building of Qt3 mainloop integration –disable-qt4 Disable building of Qt4Core mainloop integration –disable-qt5 Disable building of Qt5Core mainloop integration –disable-gtk Disable use of GTK+ 2 –disable-gtk3 Disable use of GTK+ 3 –disable-dbus Disable use of D-Bus –enable-dbm Enable use of DBM –disable-gdbm Disable use of GDBM –disable-libdaemon Disable use of libdaemon –disable-python Disable scripts that depends on python –disable-pygobject Disable use of Python GObject –disable-python-dbus Disable use of D-Bus in Python –disable-mono Disable mono bindings –disable-monodoc Disable documentation for mono bindings –disable-autoipd Disable building of avahi-autoipd –disable-doxygen-doc don’t generate any doxygen documentation –disable-doxygen-dot don’t generate graphics for doxygen documentation –enable-doxygen-man generate doxygen manual pages –enable-doxygen-rtf generate doxygen RTF documentation –disable-doxygen-xml don’t generate doxygen XML documentation –enable-doxygen-chm generate doxygen compressed HTML help documentation –enable-doxygen-chi generate doxygen seperate compressed HTML help index file –disable-doxygen-html don’t generate doxygen plain HTML documentation –enable-doxygen-ps generate doxygen PostScript documentation –enable-doxygen-pdf generate doxygen PDF documentation –enable-core-docs Enable building of documentation for avahi-core –disable-manpages Disable building and installation of man pages –disable-xmltoman Disable rebuilding of man pages with xmltoman –enable-tests Enable building of tests and examples –enable-compat-libdns_sd Enable compatibility layer for libdns_sd –enable-compat-howl Enable compatibility layer for HOWL 開始編譯: #直接root編譯 $sudo -s $export PATH=$PATH:/opt/uClinux/bfin-uclinux/bin #build avahi $./configure --host=bfin-uclinux \\ --prefix=/opt/ADSP-BF531/avahi/ \\ --with-distro=none \\ --sysconfdir=/etc \\ --with-xml=expat \\ --with-avahi-user=\"root\" \\ --with-avahi-group=\"root\" \\ --localstatedir=/var \\ -enable-libdaemon \\ -disable-dbus \\ -disable-gdbm \\ -disable-autoipd \\ -disable-qt3 \\ -disable-qt4 \\ -disable-gtk \\ -disable-gtk3 \\ -disable-python \\ -disable-mono \\ -disable-monodoc \\ -disable-doxygen-html \\ -disable-xmltoman \\ -disable-manpages \\ CC=bfin-uclinux-gcc \\ CFLAGS=\"-I/opt/ADSP-BF531/avahi/include -I/opt/ADSP-BF531/expat-2.2.9/include -I/opt/ADSP-BF531/attr/include\" \\ LDFLAGS=\"-L/opt/ADSP-BF531/expat-2.2.9/lib -L/opt/ADSP-BF531/avahi/lib -I/opt/ADSP-BF531/attr/lib -lattr\" \\ LIBDAEMON_CFLAGS=\"-I/opt/ADSP-BF531/libdaemon/include\" \\ LIBDAEMON_LIBS=\"-L/opt/ADSP-BF531/libdaemon/lib/ -ldaemon\" #之前遇到的問題 #configure: error: *** neither libexpat not libbsdxml could be found *** #CFLAGS add \"-I/opt/ADSP-BF531/expat-2.2.9/include -L/opt/ADSP-BF531/expat-2.2.9/lib\" $make $make install 6.疑難排解avahi error: ‘O_CLOEXEC’ undeclared$gedit avahi-daemon/main.c #define O_CLOEXEC 0 //= 2.4.0 ) were not met: No package 'glib-2.0' found $sudo apt-get install libglib2.0-dev /libcap.so: undefined reference to XXXX/opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `removexattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `fremovexattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `getxattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `setxattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `fsetxattr@ATTR_1.0' /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/libcap.so: undefined reference to `fgetxattr@ATTR_1.0' #./configure 時LDFLAGS 補上 -lattr，本文已加上 運行環境底下必需建置 Folder: mkdir -p /run/avahi/ mkdir -p /etc/avahi/services/ File cp /mnt/nfs/avahi-daemon /sbin/avahi-daemon &lt;= 執行檔 vi /etc/avahi/avahi-daemon.conf # This file is part of avahi. # # avahi is free software; you can redistribute it and/or modify it # under the terms of the GNU Lesser General Public License as # published by the Free Software Foundation; either version 2 of the # License, or (at your option) any later version. # # avahi is distributed in the hope that it will be useful, but WITHOUT # ANY WARRANTY; without even the implied warranty of MERCHANTABILITY # or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public # License for more details. # # You should have received a copy of the GNU Lesser General Public # License along with avahi; if not, write to the Free Software # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 # USA. # See avahi-daemon.conf(5) for more information on this configuration # file! [server] #host-name=foo #domain-name=local #browse-domains=0pointer.de, zeroconf.org use-ipv4=yes use-ipv6=no #allow-interfaces=eth0 #deny-interfaces=eth1 #check-response-ttl=no #use-iff-running=no #enable-dbus=yes #disallow-other-stacks=no #allow-point-to-point=no #cache-entries-max=4096 #clients-max=4096 #objects-per-client-max=1024 #entries-per-entry-group-max=32 ratelimit-interval-usec=1000000 ratelimit-burst=1000 [wide-area] enable-wide-area=yes [publish] #disable-publishing=no #disable-user-service-publishing=no #add-service-cookie=no #publish-addresses=yes publish-hinfo=no publish-workstation=no #publish-domain=yes #publish-dns-servers=192.168.50.1, 192.168.50.2 #publish-resolv-conf-dns-servers=yes #publish-aaaa-on-ipv4=yes #publish-a-on-ipv6=no [reflector] #enable-reflector=no #reflect-ipv=no [rlimits] #rlimit-as= #rlimit-core=0 #rlimit-data=8388608 #rlimit-fsize=0 #rlimit-nofile=768 #rlimit-stack=8388608 #rlimit-nproc=3 vi /etc/avahi/services/lxi.service &lt;=lxi 服務設定檔 &lt;?xml version=\"1.0\" standalone='no'?> &lt;!DOCTYPE service-group SYSTEM \"avahi-service.dtd\"> &lt;service-group> &lt;name replace-wildcards=\"yes\">%h-yuyan123&lt;/name> &lt;service protocol=\"ipv4\"> &lt;type>_lxi._tcp&lt;/type> &lt;port>80&lt;/port> &lt;txt-record>txtvers=1&lt;/txt-record> &lt;txt-record>Model=A-1234&lt;/txt-record> &lt;txt-record>SerialNumber=GWT123456&lt;/txt-record> &lt;txt-record>FirmwareVersion=V1.0.0.1.&lt;/txt-record> &lt;txt-record>Manufacturer=GWINSTEK&lt;/txt-record> &lt;/service> &lt;service> &lt;type>_http._tcp&lt;/type> &lt;port>80&lt;/port> &lt;/service> &lt;service> &lt;type>_scpi-raw._tcp&lt;/type> &lt;port>5025&lt;/port> &lt;/service> &lt;service> &lt;type>_scpi-telnet._tcp&lt;/type> &lt;port>5024&lt;/port> &lt;/service> &lt;service> &lt;type>_vxi-11._tcp&lt;/type> &lt;port>111&lt;/port> &lt;/service> &lt;service> &lt;type>_hislip._tcp&lt;/type> &lt;port>4880&lt;/port> &lt;/service> &lt;/service-group> 簡易測試在嵌入式系統端開啟服務 (root 帳號為例)$avahi-daemon 在 PC 端使用 avahi-unitls 測試，Ubuntu 為例# install $sudo apt-get install avahi-untils # test $avahi-browse -a | grep _lxi._tcp","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"avahi","slug":"avahi","permalink":"https://tsaiyuyan.github.io/tags/avahi/"},{"name":"mDNS","slug":"mDNS","permalink":"https://tsaiyuyan.github.io/tags/mDNS/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"cross-compiler","slug":"cross-compiler","permalink":"https://tsaiyuyan.github.io/tags/cross-compiler/"},{"name":"expat","slug":"expat","permalink":"https://tsaiyuyan.github.io/tags/expat/"},{"name":"attr","slug":"attr","permalink":"https://tsaiyuyan.github.io/tags/attr/"}]},{"title":"Ubuntu avahi-daemon 移植 arm-linux(arm-linux-gnueabihf)","slug":"Linux/Ubuntu avahi-daemon 移植 arm-linux(arm-linux-gnueabihf)","date":"2019-08-16T06:00:00.000Z","updated":"2022-07-18T01:54:21.801Z","comments":true,"path":"2019/08/16/linux/ubuntu-avahi-daemon-yi-zhi-arm-linux-arm-linux-gnueabihf/","link":"","permalink":"https://tsaiyuyan.github.io/2019/08/16/linux/ubuntu-avahi-daemon-yi-zhi-arm-linux-arm-linux-gnueabihf/","excerpt":"","text":"mDNS 協議介紹 mDNS 原理的簡單理解——每個進入局域網的主機，如果開啟了 mDNS 服務的話，都會向局域網內的所有主機組播一個消息，我是誰，和我的 IP 地址是多少。然後其他也有該服務的主機就會響應，也會告訴你，它是誰，它的 IP 地址是多少。 mDNS multicast DNS , 使用 5353 端口，組播地址 224.0.0.251。在一個沒有常規 DNS 服務器的小型網絡內，可以使用 mDNS 來實現類似 DNS 的編程接口、包格式和操作語義。 MDNS 協議的報文與 DNS 的報文結構相同，但有些字段對於 MDNS 來說有新的含義。 每個進入局域網的主機，如果開啟了 mDNS 服務的話，都會向局域網內的所有主機組播一個消息，我是誰，和我的 IP 地址是多少。然後其他也有該服務的主機就會響應，也會告訴你，它是誰，它的 IP 地址是多少。 mDNS 的域名與普通 DNS 的域名是通過後綴.local 區分開來的。如果一台終端需要訪問一個 mDNS 域名，他就會向局域網內發送組播，詢問該域名的 IP 是多少。 例如： 一個設備接入網絡，首先查詢名稱是否衝突，並通告當前服務器信息 衝突檢測結束後，發送 MDNS 通告，通知其它設備更新 DNS 緩存 其它設備對該域名訪問時，會發起 MDNS 查詢 移植 avahi 到 arm-linux 準備好要使用的 toolchain 1.下載 3 個 tar 包 libdaemon-0.14.tar.gz avahi-0.7.tar.gz expat-2.2.9.tar.bzip attr-2.5.1.tar.gz 自行解壓縮到指定資料夾，本文示範如下 $ tree -L 1 ~/Desktop/avahi-daemon-XXXXX/ /home/yuyan/Desktop/avahi-daemon-XXXXX/ ├── avahi-0.7 ├── expat-2.2.9 ├── libdaemon-0.14 └── attr-2.5.1 4 directories, 0 files 2.編譯 libdaemon#unpackge libdaemon $tar zxvf libdaemon-0.14.tar.gz $cd libdaemon #切換至管理員 $sudo -s #連接toolchain $export PATH=$PATH:/opt/toolchains/ti335x/i686-arago-linux/usr/bin #build libdaemon $./configure \\ --host=arm-linux-gnueabihf \\ --prefix=/opt/ARMv7_ti335x/libdaemon \\ --disable-shared \\ CC=arm-linux-gnueabihf-gcc \\ --config-cache (...) # 發生錯誤 checking whether setpgrp takes no argument... configure: error: cannot check setpgrp when cross compiling ... #修正錯誤 $echo \"ac_cv_func_setpgrp_void=yes\" > config.cache $./configure \\ --host=arm-linux-gnueabihf \\ --prefix=/opt/ARMv7_ti335x/libdaemon \\ --disable-shared \\ CC=arm-linux-gnueabihf-gcc \\ CFLAGS=\"-I/opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/usr/include -L/opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib\" \\ --config-cache $make $sudo make install 3.編譯 expat (如果 toolchain 沒有的話)#解壓縮 $bzip2 -d expat-2.2.9.tar.bz2ls $tar xvf expat-2.2.9.tar./ #切換至管理員 $sudo -s #連接toolchain $export PATH=$PATH:/opt/toolchains/ti335x/i686-arago-linux/usr/bin $./configure \\ --host=arm-linux-gnueabihf \\ --prefix=/opt/ARMv7_ti335x/expat-2.2.9 \\ --enable-shared=no \\ CC=arm-linux-gnueabihf-gcc \\ CFLAGS=\"-I/opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/usr/include -L/opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib\" $make $make install 4.編譯 libattr (如果 toolchain 沒有的話) (20220718 補充) 編譯流程跟expat差不多 &lt;= 有需要調整請自行修正 #解壓縮 $tar zxvf attr-2.5.1.tar.gz #讓root帳號辨別toolchain位置 $sudo -s $export PATH=$PATH:/opt/toolchains/ti335x/i686-arago-linux/usr/bin $./configure --host=arm-linux-gnueabihf --prefix=/opt/ARMv7_ti335x/attr CC=arm-linux-gnueabihf-gcc $make $make install 5.編譯 avahi 這邊目的只在於編譯 avahi-daemon，所以其他的工具都會 disable。 Optional Features: opertion description –disable-option-checking ignore unrecognized –enable/–with options –disable-FEATURE do not include FEATURE (same as –enable-FEATURE=no) –enable-FEATURE[=ARG] include FEATURE [ARG=yes] –enable-silent-rules less verbose build output (undo: “make V=1”) –disable-silent-rules verbose build output (undo: “make V=0”) –enable-dependency-tracking do not reject slow dependency extractors –disable-dependency-tracking speeds up one-time build –disable-stack-protector Disable GCC’s/libc’s stack-smashing protection –enable-shared[=PKGS] build shared libraries [default=yes] –enable-static[=PKGS] build static libraries [default=yes] –enable-fast-install[=PKGS] optimize for fast installation [default=yes] –disable-libtool-lock avoid locking (might break parallel builds) –disable-nls do not use Native Language Support –disable-rpath do not hardcode runtime library paths –disable-glib Disable use of GLib –disable-gobject Disable use of GLib GObject –enable-introspection=[no/auto/yes] Enable introspection for this build –disable-libevent Disable use of libevent –enable-qt3 Enable building of Qt3 mainloop integration –disable-qt4 Disable building of Qt4Core mainloop integration –disable-qt5 Disable building of Qt5Core mainloop integration –disable-gtk Disable use of GTK+ 2 –disable-gtk3 Disable use of GTK+ 3 –disable-dbus Disable use of D-Bus –enable-dbm Enable use of DBM –disable-gdbm Disable use of GDBM –disable-libdaemon Disable use of libdaemon –disable-python Disable scripts that depends on python –disable-pygobject Disable use of Python GObject –disable-python-dbus Disable use of D-Bus in Python –disable-mono Disable mono bindings –disable-monodoc Disable documentation for mono bindings –disable-autoipd Disable building of avahi-autoipd –disable-doxygen-doc don’t generate any doxygen documentation –disable-doxygen-dot don’t generate graphics for doxygen documentation –enable-doxygen-man generate doxygen manual pages –enable-doxygen-rtf generate doxygen RTF documentation –disable-doxygen-xml don’t generate doxygen XML documentation –enable-doxygen-chm generate doxygen compressed HTML help documentation –enable-doxygen-chi generate doxygen seperate compressed HTML help index file –disable-doxygen-html don’t generate doxygen plain HTML documentation –enable-doxygen-ps generate doxygen PostScript documentation –enable-doxygen-pdf generate doxygen PDF documentation –enable-core-docs Enable building of documentation for avahi-core –disable-manpages Disable building and installation of man pages –disable-xmltoman Disable rebuilding of man pages with xmltoman –enable-tests Enable building of tests and examples –enable-compat-libdns_sd Enable compatibility layer for libdns_sd –enable-compat-howl Enable compatibility layer for HOWL 開始編譯: $sudo -s #build avahi $./configure --host=arm-linux-gnueabihf \\ --prefix=/opt/ARMv7_ti335x/avahi/ \\ --with-distro=none \\ --sysconfdir=/etc \\ --with-xml=expat \\ --with-avahi-user=\"root\" \\ --with-avahi-group=\"root\" \\ --localstatedir=/var \\ -enable-libdaemon \\ -disable-shared \\ -disable-dbus \\ -disable-gdbm \\ -disable-autoipd \\ -disable-qt3 \\ -disable-qt4 \\ -disable-gtk \\ -disable-gtk3 \\ -disable-python \\ -disable-mono \\ -disable-monodoc \\ -disable-doxygen-html \\ -disable-xmltoman \\ -disable-manpages \\ CC=arm-linux-gnueabihf-gcc \\ CFLAGS=\"-I/opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/usr/include -I/opt/ARMv7_ti335x/avahi/include -L/opt/ARMv7_ti335x/avahi/lib -I/opt/ARMv7_ti335x/expat-2.2.9/include -I/opt/ARMv7_ti335x/attr/include\" \\ LDFLAGS=\"-L/opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib -L/opt/ARMv7_ti335x/expat-2.2.9/lib /opt/ARMv7_ti335x/expat-2.2.9/lib/libexpat.a -L/opt/ARMv7_ti335x/attr/lib -lattr\" \\ LIBDAEMON_CFLAGS=\"-I/opt/ARMv7_ti335x/libdaemon/include\" \\ LIBDAEMON_LIBS=\"-L/opt/ARMv7_ti335x/libdaemon/lib/ -ldaemon\" # 註 /opt/ARMv7_ti335x/expat-2.2.9/lib/libexpat.a &lt;!DOCTYPE service-group SYSTEM \"avahi-service.dtd\"> &lt;service-group> &lt;name replace-wildcards=\"yes\">%h-yuyan123&lt;/name> &lt;service protocol=\"ipv4\"> &lt;type>_lxi._tcp&lt;/type> &lt;port>80&lt;/port> &lt;txt-record>txtvers=1&lt;/txt-record> &lt;txt-record>Model=A-1234&lt;/txt-record> &lt;txt-record>SerialNumber=GWT123456&lt;/txt-record> &lt;txt-record>FirmwareVersion=V1.0.0.1.&lt;/txt-record> &lt;txt-record>Manufacturer=GWINSTEK&lt;/txt-record> &lt;/service> &lt;service> &lt;type>_http._tcp&lt;/type> &lt;port>80&lt;/port> &lt;/service> &lt;service> &lt;type>_scpi-raw._tcp&lt;/type> &lt;port>5025&lt;/port> &lt;/service> &lt;service> &lt;type>_scpi-telnet._tcp&lt;/type> &lt;port>5024&lt;/port> &lt;/service> &lt;service> &lt;type>_vxi-11._tcp&lt;/type> &lt;port>111&lt;/port> &lt;/service> &lt;service> &lt;type>_hislip._tcp&lt;/type> &lt;port>4880&lt;/port> &lt;/service> &lt;/service-group> 簡易測試在嵌入式系統端開啟服務 (root 帳號為例)$avahi-daemon 在 PC 端使用 avahi-unitls 測試，Ubuntu 為例# install $sudo apt-get install avahi-untils # test $avahi-browse -a | grep _lxi._tcp","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"avahi","slug":"avahi","permalink":"https://tsaiyuyan.github.io/tags/avahi/"},{"name":"mDNS","slug":"mDNS","permalink":"https://tsaiyuyan.github.io/tags/mDNS/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"cross-compiler","slug":"cross-compiler","permalink":"https://tsaiyuyan.github.io/tags/cross-compiler/"},{"name":"attr","slug":"attr","permalink":"https://tsaiyuyan.github.io/tags/attr/"}]},{"title":"Ubuntu 編譯 cJSON","slug":"Linux/Ubuntu 編譯 cJSON","date":"2019-06-17T06:00:00.000Z","updated":"2020-09-28T07:48:37.875Z","comments":true,"path":"2019/06/17/linux/ubuntu-bian-yi-cjson/","link":"","permalink":"https://tsaiyuyan.github.io/2019/06/17/linux/ubuntu-bian-yi-cjson/","excerpt":"","text":"reference: https://github.com/DaveGamble/cJSON Configuration$git clone https://github.com/soniah/gosnmp.git $cd cJSON $mkdir build $cd build $cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local/cjson $make $sudo make install Example CodeParser JSON string#include&lt;stdio.h> #include&lt;json-c/json.h> #define EXAMPLE_JSON \"./example.json\" #define NULL_NULL \"NULL\" #define BOOL_BOOLEAN \"BOOLEAN\" #define STR_STRING \"STRING\" #define NUM_INTEGER \"NUMBER\" #define NUM_DOUBLE \"DOUBLE\" #define ARR_ARRAY \"ARRAY\" #define OBJ_OBJECT \"OBJECT\" #define NULL_MEMBER_NULL \"MEMBER_NULL\" #define BOOL_MEMBER_BOOLEAN \"MEMBER_BOOLEAN\" #define STR_MEMBER_STRING \"MEMBER_STRING\" #define NUM_MEMBER_INTEGER \"MEMBER_NUMBER\" #define NUM_MEMBER_DOUBLE \"MEMBER_DOUBLE\" #define ARR_MEMBER_ARRAY \"MEMBER_ARRAY\" int write_to_json_file(char* filename) { int ret = 0; json_object *json_obj = NULL; json_object *array_obj = NULL; json_object *new_obj = NULL; json_object *tmp_obj = NULL; json_object *tmp1_obj = NULL; //new a base object json_obj = json_object_new_object(); if (!json_obj) { printf(\"Cannot create object\\n\"); ret = -1; goto error; } //new a null json_object_object_add(json_obj, NULL_NULL, NULL); //new a boolean tmp_obj = json_object_new_boolean(1); if (!tmp_obj) { printf(\"Cannot create boolean object for %s\\n\", BOOL_BOOLEAN); ret = -1; goto error; } json_object_object_add(json_obj, BOOL_BOOLEAN, tmp_obj); tmp_obj = NULL; //new a string tmp_obj = json_object_new_string(\"string\"); if (!tmp_obj) { printf(\"Cannot create string object for %s\\n\", STR_STRING); ret = -1; goto error; } json_object_object_add(json_obj, STR_STRING, tmp_obj); tmp_obj = NULL; //new a integer tmp_obj = json_object_new_int(100); if (!tmp_obj) { printf(\"Cannot create number object for %s\\n\", NUM_INTEGER); ret = -1; goto error; } json_object_object_add(json_obj, NUM_INTEGER, tmp_obj); tmp_obj = NULL; //new a double tmp_obj = json_object_new_double(3.1415926); if (!tmp_obj) { printf(\"Cannot create double object for %s\\n\", NUM_DOUBLE); ret = -1; goto error; } json_object_object_add(json_obj, NUM_DOUBLE, tmp_obj); tmp_obj = NULL; //new a array array_obj = json_object_new_array(); if (!array_obj) { printf(\"Cannot create array object\\n\"); ret = -1; goto error; } //new a string and add to the array new_obj = json_object_new_string(\"str1\"); if (!new_obj) { printf(\"Cannot create string object for %s\\n\", ARR_ARRAY); ret = -1; goto error; } json_object_array_add(array_obj, new_obj); new_obj = NULL; //new a string and add to the array new_obj = json_object_new_string(\"str2\"); if (!new_obj) { printf(\"Cannot create string object for %s\\n\", ARR_ARRAY); ret = -1; goto error; } json_object_array_add(array_obj, new_obj); new_obj = NULL; //new a string and add to the array new_obj = json_object_new_string(\"str3\"); if (!new_obj) { printf(\"Cannot create string object for %s\\n\", ARR_ARRAY); ret = -1; goto error; } json_object_array_add(array_obj, new_obj); new_obj = NULL; //add array to the base object json_object_object_add(json_obj, ARR_ARRAY, array_obj); array_obj = NULL; //new an object tmp_obj = json_object_new_object(); if (!tmp_obj) { printf(\"Cannot create object\\n\"); ret = -1; goto error; } //add a null to the object json_object_object_add(tmp_obj, NULL_MEMBER_NULL, NULL); //new a boolean and add to the object tmp1_obj = json_object_new_boolean(0); if (!tmp1_obj) { printf(\"Cannot create boolean object for %s\\n\", BOOL_MEMBER_BOOLEAN); ret = -1; goto error; } json_object_object_add(tmp_obj, BOOL_MEMBER_BOOLEAN, tmp1_obj); tmp1_obj = NULL; //new a string and add to the object tmp1_obj = json_object_new_string(\"string\"); if (!tmp1_obj) { printf(\"Cannot create string object for %s\\n\", STR_MEMBER_STRING); ret = -1; goto error; } json_object_object_add(tmp_obj, STR_MEMBER_STRING, tmp1_obj); tmp1_obj = NULL; //new a integer and add to the object tmp1_obj = json_object_new_int(200); if (!tmp1_obj) { printf(\"Cannot create number object for %s\\n\", NUM_MEMBER_INTEGER); ret = -1; goto error; } json_object_object_add(tmp_obj, NUM_MEMBER_INTEGER, tmp1_obj); tmp1_obj = NULL; //new a double and add to the object tmp1_obj = json_object_new_double(0.123456789); if (!tmp1_obj) { printf(\"Cannot create double object for %s\\n\", NUM_MEMBER_DOUBLE); ret = -1; goto error; } json_object_object_add(tmp_obj, NUM_MEMBER_DOUBLE, tmp1_obj); tmp1_obj = NULL; //new a array array_obj = json_object_new_array(); if (!array_obj) { printf(\"Cannot create array object\\n\"); ret = -1; goto error; } //new a integer and add to array new_obj = json_object_new_int(1); if (!new_obj) { printf(\"Cannot create string object for %s\\n\", ARR_MEMBER_ARRAY); ret = -1; goto error; } json_object_array_add(array_obj, new_obj); new_obj = NULL; //new a integer and add to array new_obj = json_object_new_int(2); if (!new_obj) { printf(\"Cannot create string object for %s\\n\", ARR_MEMBER_ARRAY); ret = -1; goto error; } json_object_array_add(array_obj, new_obj); new_obj = NULL; //new a integer and add to array new_obj = json_object_new_int(3); if (!new_obj) { printf(\"Cannot create string object for %s\\n\", ARR_MEMBER_ARRAY); ret = -1; goto error; } json_object_array_add(array_obj, new_obj); new_obj = NULL; //add array to the object json_object_object_add(tmp_obj, ARR_MEMBER_ARRAY, array_obj); array_obj = NULL; //add the object to base object json_object_object_add(json_obj, OBJ_OBJECT, tmp_obj); tmp_obj = NULL; //write the base object to write.json json_object_to_file(filename, json_obj); error: json_object_put(tmp1_obj); json_object_put(tmp_obj); json_object_put(new_obj); json_object_put(array_obj); json_object_put(json_obj); return ret; } int read_from_json_file(char *filename) { int ret = 0; json_object *test_obj = NULL; json_object *tmp_obj = NULL; json_object *tmp1_obj = NULL; json_object *tmp2_obj = NULL; //get json object from file test_obj = json_object_from_file(filename); if (!test_obj) { printf(\"Cannot open %s\\n\", filename); ret = -1; goto error; } //get null tmp_obj = json_object_object_get(test_obj, NULL_NULL); if (tmp_obj) { printf(\"Cannot get %s object\\n\", NULL_NULL); ret = -1; goto error; } printf(\"%s = %s\\n\", NULL_NULL, \"null\"); //get boolean tmp_obj = json_object_object_get(test_obj, BOOL_BOOLEAN); if (!tmp_obj) { printf(\"Cannot get %s object\\n\", BOOL_BOOLEAN); ret = -1; goto error; } printf(\"%s = %s\\n\", BOOL_BOOLEAN, ((json_object_get_boolean(tmp_obj))?(\"TRUE\"):(\"FALSE\"))); //get string tmp_obj = json_object_object_get(test_obj, STR_STRING); if (!tmp_obj) { printf(\"Cannot get %s object\\n\", STR_STRING); ret = -1; goto error; } printf(\"%s = %s\\n\", STR_STRING, json_object_get_string(tmp_obj)); //get integer tmp_obj = json_object_object_get(test_obj, NUM_INTEGER); if (!tmp_obj) { printf(\"Cannot get %s object\\n\", NUM_INTEGER); ret = -1; goto error; } printf(\"%s = %d\\n\", NUM_INTEGER, json_object_get_int(tmp_obj)); //get double tmp_obj = json_object_object_get(test_obj, NUM_DOUBLE); if (!tmp_obj) { printf(\"Cannot get %s object\\n\", NUM_DOUBLE); ret = -1; goto error; } printf(\"%s = %F\\n\", NUM_DOUBLE, json_object_get_double(tmp_obj)); //get array tmp_obj = json_object_object_get(test_obj, ARR_ARRAY); if (!tmp_obj) { printf(\"Cannot get %s object\\n\", ARR_ARRAY); ret = -1; goto error; } //get the length of the array printf(\"%s size = %d\\n\", ARR_ARRAY, json_object_array_length(tmp_obj)); //get the value of array[0] tmp1_obj = json_object_array_get_idx(tmp_obj, 0); printf(\"%s[0] = %s\\n\", ARR_ARRAY, json_object_get_string(tmp1_obj)); //get the value of array[1] tmp1_obj = json_object_array_get_idx(tmp_obj, 1); printf(\"%s[1] = %s\\n\", ARR_ARRAY, json_object_get_string(tmp1_obj)); //get the value of array[2] tmp1_obj = json_object_array_get_idx(tmp_obj, 2); printf(\"%s[2] = %s\\n\", ARR_ARRAY, json_object_get_string(tmp1_obj)); //get object tmp_obj = json_object_object_get(test_obj, OBJ_OBJECT); if (!tmp_obj) { printf(\"Cannot get %s object\\n\", OBJ_OBJECT); ret = -1; goto error; } //get null within a object tmp1_obj = json_object_object_get(tmp_obj, NULL_MEMBER_NULL); if (tmp1_obj) { printf(\"Cannot get %s object\\n\", NULL_MEMBER_NULL); ret = -1; goto error; } printf(\"%s = %s\\n\", NULL_MEMBER_NULL, \"null\"); //get boolean within a object tmp1_obj = json_object_object_get(tmp_obj, BOOL_MEMBER_BOOLEAN); if (!tmp1_obj) { printf(\"Cannot get %s object\\n\", BOOL_MEMBER_BOOLEAN); ret = -1; goto error; } printf(\"%s = %s\\n\", BOOL_MEMBER_BOOLEAN, ((json_object_get_boolean(tmp1_obj))?(\"TRUE\"):(\"FALSE\"))); //get string within a object tmp1_obj = json_object_object_get(tmp_obj, STR_MEMBER_STRING); if (!tmp1_obj) { printf(\"Cannot get %s object\\n\", STR_MEMBER_STRING); ret = -1; goto error; } printf(\"%s = %s\\n\", STR_MEMBER_STRING, json_object_get_string(tmp1_obj)); //get integer within a object tmp1_obj = json_object_object_get(tmp_obj, NUM_MEMBER_INTEGER); if (!tmp1_obj) { printf(\"Cannot get %s object\\n\", NUM_MEMBER_INTEGER); ret = -1; goto error; } printf(\"%s = %d\\n\", NUM_MEMBER_INTEGER, json_object_get_int(tmp1_obj)); //get double within a object tmp1_obj = json_object_object_get(tmp_obj, NUM_MEMBER_DOUBLE); if (!tmp1_obj) { printf(\"Cannot get %s object\\n\", NUM_MEMBER_DOUBLE); ret = -1; goto error; } printf(\"%s = %F\\n\", NUM_MEMBER_DOUBLE, json_object_get_double(tmp1_obj)); //get array within a object tmp1_obj = json_object_object_get(tmp_obj, ARR_MEMBER_ARRAY); if (!tmp1_obj) { printf(\"Cannot get %s object\\n\", ARR_MEMBER_ARRAY); ret = -1; goto error; } //get the length of the array within a object printf(\"%s size = %d\\n\", ARR_MEMBER_ARRAY, json_object_array_length(tmp1_obj)); //get the value of array[0] within a object tmp2_obj = json_object_array_get_idx(tmp1_obj, 0); printf(\"%s[0] = %d\\n\", ARR_MEMBER_ARRAY, json_object_get_int(tmp2_obj)); //get the value of array[0] within a object tmp2_obj = json_object_array_get_idx(tmp1_obj, 1); printf(\"%s[1] = %d\\n\", ARR_MEMBER_ARRAY, json_object_get_int(tmp2_obj)); //get the value of array[0] within a object tmp2_obj = json_object_array_get_idx(tmp1_obj, 2); printf(\"%s[2] = %d\\n\", ARR_MEMBER_ARRAY, json_object_get_int(tmp2_obj)); error: json_object_put(test_obj); return ret; } int main(int argc, char *argv[]) { int ret = 0; ret = write_to_json_file(EXAMPLE_JSON); if (ret != 0) printf(\"Fail to write a json file\\n\"); ret = read_from_json_file(EXAMPLE_JSON); if (ret != 0) printf(\"Fail to read a json file\\n\"); return 0; } Composer JSON string Build and ExecuteCMakelists File//CMakelists.txt cmake_minimum_required(VERSION 2.8) # use folder name as project name get_filename_component(ProjectId ${CMAKE_CURRENT_SOURCE_DIR} NAME) string(REPLACE \" \" \"_\" ProjectId ${ProjectId}) project(${ProjectId}) set(CMAKE_BUILE_TYPE DEBUG) set(CMAKE_C_FLAGS_DEBUG \"-O0 -g -Wall\" ) # Debug not optimize set(CMAKE_C_FLAGS_RELEASE \"-O2 -DNDEBUG \" ) # release optimeze set(CMAKE_CXX_FLAGS_DEBUG \"-O0 -g -Wall\" ) # Debug not optimize set(CMAKE_CXX_FLAGS_RELEASE \"-O2 -DNDEBUG \" ) # release optimeze #set(EXECUTABLE_OUTPUT_PATH \"${CMAKE_CURRENT_LIST_DIR}\") set(EXECUTABLE_OUTPUT_PATH \"${CMAKE_CURRENT_BINARY_DIR}\") message(STATUS \"Project: ${ProjectId}\") message(STATUS \"Project Directory: ${PROJECT_SOURCE_DIR}\") message(STATUS \"Source Directory: ${CMAKE_CURRENT_LIST_DIR}/src\") message(STATUS \"Output Directory: ${CMAKE_CURRENT_BINARY_DIR}\") # source code aux_source_directory(${CMAKE_CURRENT_LIST_DIR}/src DIR_SRC) # include include_directories(${CMAKE_CURRENT_LIST_DIR}/include /usr/local/cjson/include) # library ${CMAKE_CURRENT_LIST_DIR}/lib link_directories(/usr/local/cjson/lib) # build message(STATUS \"Source Files: ${DIR_SRC}\") add_executable(${PROJECT_NAME}.out ${DIR_SRC}) target_link_libraries(${PROJECT_NAME}.out -lcjson) build and run$mkdir build $cd build $cmake .. $make $./a.out","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"cJSON","slug":"cJSON","permalink":"https://tsaiyuyan.github.io/tags/cJSON/"}]},{"title":"933. Number of Recent Calls","slug":"Leetcode/933_Number of Recent Calls","date":"2019-05-22T06:15:00.000Z","updated":"2020-09-28T07:49:33.821Z","comments":true,"path":"2019/05/22/leetcode/933-number-of-recent-calls/","link":"","permalink":"https://tsaiyuyan.github.io/2019/05/22/leetcode/933-number-of-recent-calls/","excerpt":"","text":"Link: https://leetcode.com/problems/number-of-recent-calls/ Write a class RecentCounter to count recent requests. It has only one method: ping(int t), where t represents some time in milliseconds. Return the number of pings that have been made from 3000 milliseconds ago until now. Any ping with time in [t - 3000, t] will count, including the current ping. It is guaranteed that every call to ping uses a strictly larger value of t than before. Example 1: Input: inputs = [\"RecentCounter\",\"ping\",\"ping\",\"ping\",\"ping\"], inputs = [[],[1],[100],[3001],[3002]] Output: [null,1,2,3,3] Note: Each test case will have at most 10000 calls to ping. Each test case will call ping with strictly increasing values of t. Each call to ping will have 1 &lt;= t &lt;= 10^9. 題目翻譯: 共享寫一個類 RecentCounter 來計算最近的請求。 它只有一個方法：ping（int t），其中 t 代表一些時間（以毫秒為單位）。 返回從 3000 毫秒前到現在為止的 ping 數。 在[t-3000，t]中任何時間 ping 都將計數，包括當前 ping。 保證每次調用 ping 都使用比之前嚴格更大的 t 值。 程式思路:用一個 deque 容器將時間存起來，為了方便查找所以每次都會從第一個元素開始判斷是否有在 t-3000 時間以內，如果沒有就刪除元素，最後返回容器的總元素量就是答案。 class RecentCounter { public: deque &lt;int> pings; RecentCounter() { } int ping(int t) { pings.emplace_back(t); for(auto it = pings.begin();it != pings.end();it++) { if((*it >= t - 3000)) { pings.erase(pings.begin(),it); break; } } return pings.size(); } }; /** * Your RecentCounter object will be instantiated and called as such: * RecentCounter* obj = new RecentCounter(); * int param_1 = obj->ping(t); */","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1046. Last Stone Weight","slug":"Leetcode/1046_Last Stone Weight","date":"2019-05-22T05:41:00.000Z","updated":"2020-09-28T07:50:00.117Z","comments":true,"path":"2019/05/22/leetcode/1046-last-stone-weight/","link":"","permalink":"https://tsaiyuyan.github.io/2019/05/22/leetcode/1046-last-stone-weight/","excerpt":"","text":"Link: https://leetcode.com/problems/last-stone-weight/ We have a collection of rocks, each rock has a positive integer weight. Each turn, we choose the two heaviest rocks and smash them together. Suppose the stones have weights x and y with x &lt;= y. The result of this smash is: If x == y, both stones are totally destroyed; If x != y, the stone of weight x is totally destroyed, and the stone of weight y has new weight y-x. At the end, there is at most 1 stone left. Return the weight of this stone (or 0 if there are no stones left.) Example 1: Input: [2,7,4,1,8,1] Output: 1 Explanation: We combine 7 and 8 to get 1 so the array converts to [2,4,1,1,1] then, we combine 2 and 4 to get 2 so the array converts to [2,1,1,1] then, we combine 2 and 1 to get 1 so the array converts to [1,1,1] then, we combine 1 and 1 to get 0 so the array converts to [1] then that's the value of last stone. Note: 1 &lt;= stones.length &lt;= 30 1 &lt;= stones[i] &lt;= 1000 題目翻譯: 我們有一個岩石集合，每個岩石都有一個正整數權重。 每轉一圈，我們選擇兩塊最重的岩石並將它們粉碎在一起。 假設寶石的權重為 x 和 y，x &lt;= y。 這次粉碎的結果是： 如果 x == y，兩塊石頭都被徹底摧毀;如果 x！= y，重量 x 的石頭被完全破壞，重量 y 的石頭具有新的重量 y-x。 最後，剩下最多 1 塊石頭。 返回這塊石頭的重量（如果沒有留下石塊，則返回 0） 程式思路:每次從 vector 取出兩個最大的數字，將其碰撞留下較大的，將其塞回去 class Solution { public: int lastStoneWeight(vector&lt;int>&amp; stones) { while(stones.size() > 0) { //Find the first weight stone. auto it1 = max_element(std::begin(stones), std::end(stones)); int stone1 = *it1; //Find the second weight stone. *it1 = 0; auto it2 = max_element(std::begin(stones), std::end(stones)); if(*it2 == 0) return stone1; //Smash stones *it1 = stone1 - *it2; *it2 = 0; } return 0; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"Ubuntu 建立 net-snmp cross-complier 開發環境","slug":"Linux/Ubuntu 建立 net-snmp cross-complier 開發環境","date":"2019-05-20T02:00:00.000Z","updated":"2020-05-11T07:35:19.175Z","comments":true,"path":"2019/05/20/linux/ubuntu-jian-li-net-snmp-cross-complier-kai-fa-huan-jing/","link":"","permalink":"https://tsaiyuyan.github.io/2019/05/20/linux/ubuntu-jian-li-net-snmp-cross-complier-kai-fa-huan-jing/","excerpt":"","text":"以下文章參考 (net-snmp5.7.3 移植到 arm-linux 平台)https://www.cnblogs.com/quliuliu2013/p/7520241.html ，在跟自己專有的交叉編譯工具相結合。 本篇紀錄編譯配置的部分，如果想要後續開發的像是配置 config 請參考之前的開發&amp;編譯 net-snmp 文章(用 tag 尋找 net-snmp!)。 一、準備 下載原始碼 http://www.net-snmp.org/download.html 準備 Toolchain (廠商提供或是 arm-linux-gnueabi-gcc ，使用命令 sudo apt-get install gcc-arm-linux-gnueabi 安裝即可。 二、編譯配置解壓 net-snmp 壓縮包，進入原始碼包目錄 使用 ./configure –help ，查看以下配置有哪些。 選項 說明 –host=arm-linux 運行平台 –target=arm-linux 目標平台 –build=i686-linux 編譯平台 –with-cc=arm-linux-gcc 交叉編譯工具 –with-ar=arm-linux-ar 打包工具 –prefix=/usr/local/net-snmp 安裝目錄 –disable-shared 不編譯共享庫 –disable-scripts 不要安裝 mib2c 等腳本 –with-endianness=little 指定小端模式 -enable-mini-agent 最小化構建 agent –disable-deprecated 不編譯棄用的功能 –without-logfile 指定 snmpd 不輸出日誌文件(可以使用–with-logfile 指定默認日誌文件位置) –disable-minimalist 刪除所有非基本的代碼功能 –enable-debugging 打開調試信息 –disable-testing-code 不使用測試代碼(某些代碼不被使用) –with-openssl=/opt/hardhat openssl 庫路徑(用於支持加密等) –disable-ipv6 不使用 IPv6 –disable-manuals 不安裝 manpage 說明頁 –disable-ucd-snmp-compatibility 不需要兼容 ucd-snmp –disable-snmptrapd-subagent 不用支持 snmptrapd 的子代理 –disable-embedded-perl 在 SNMP 代理和 snmptrapd 禁用嵌入式 Perl。默認啟用 –disable-applications 是否關閉 snmpget 等功能，根據自己的需要選擇 –with-default-snmp-version=”3” 指定默認協議版本 –enable-as-needed 僅鏈接需要庫，不鏈接不必要的庫（如果只使用其他方法行不通,鏈接 libperl 針對應用而非 Net-SNMP 庫。） 1. 我使用的配置$./configure --target=arm-linux-gnueabihf --host=arm-linux-gnueabihf --prefix=/opt/net-snmp-5.7.3-arm CC=arm-linux-gnueabihf-gcc CFLAGS=\"-I /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/usr/include/\" --disable-embedded-perl --disable-shared --enable-mini-agent # --disable-scripts 這個經測試後會無法使用subagent的功能，所以筆者在這邊不使用。 (略)... Default version of SNMP to use (3): (Enter) (略)... System Contact Information (@@no.where): XXXXXXXXXXX@gmail.com (略)... System Location (Unknown): Taiwan (略)... --------------------------------------------------------- Net-SNMP configuration summary: --------------------------------------------------------- SNMP Versions Supported: 1 2c 3 Building for: linux Net-SNMP Version: 5.7.3 Network transport support: Callback Unix Alias TCP UDP IPv4Base SocketBase TCPBase UDPIPv4Base UDPBase SNMPv3 Security Modules: usm Agent MIB code: default_modules => snmpv3mibs mibII ucd_snmp notification notification-log-mib target agent_mibs agentx disman/event disman/schedule utilities host MYSQL Trap Logging: unavailable Embedded Perl support: disabled SNMP Perl modules: disabled SNMP Python modules: disabled Crypto support from: internal Authentication support: MD5 SHA1 Encryption support: DES AES Local DNSSEC validation: disabled --------------------------------------------------------- 2. 參考網站的配置$./configure --host=arm-linux --build=i686-linux --with-cc=arm-linux-gnueabihf-gcc --with-ar=arm-linux-gnueabihf-ar --prefix=/usr/local/net-snmp --disable-shared --with-endianness=little --with-openssl=/usr/local/openssl --with-mib-modules=examples/example --------------------------------------------------------- Net-SNMP configuration summary: --------------------------------------------------------- SNMP Versions Supported: 1 2c 3 Building for: linux Net-SNMP Version: 5.7.3 Network transport support: Callback Unix Alias TCP UDP IPv4Base SocketBase TCPBase UDPIPv4Base UDPBase SNMPv3 Security Modules: usm Agent MIB code: default_modules => snmpv3mibs mibII/snmp_mib mibII/system_mib mibII/sysORTable mibII/vacm_vars mibII/vacm_conf MYSQL Trap Logging: unavailable Embedded Perl support: disabled SNMP Perl modules: building -- not embeddable SNMP Python modules: disabled Crypto support from: internal Authentication support: MD5 SHA1 Encryption support: DES AES Local DNSSEC validation: disabled --------------------------------------------------------- 三、編譯# make -j (核心數)，可以根據你電腦有多少CPU 來加快編譯。 $ make -j 2 (略，如果有遇到別問題請參考前篇文章)... $ make install 四、疑難排解1. 沒有 perl 庫的問題編譯的時候出現找不到 perl 庫的問題，這個問題其實也好解決，編譯一個就是嘛。但是呢，沒有這個必要，麻煩。 /usr/lib/gcc-cross/arm-linux-gnueabi/4.9/../../../../arm-linux-gnueabi/bin/ld: cannot find -lperl collect2: error: ld returned 1 exit status Makefile:484: recipe for target 'libnetsnmpagent.la' failed make[1]: *** [libnetsnmpagent.la] Error 1 make[1]: Leaving directory '/home/o/snmp/net-snmp-5.7.3/agent' Makefile:656: recipe for target 'subdirs' failed make: *** [subdirs] Error 1 解決辦法 其實很簡單，將之前 configure 配置的時候加上一個參數--disable-embedded-perl，然後再次 make 就可以了。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"net-snmp","slug":"net-snmp","permalink":"https://tsaiyuyan.github.io/tags/net-snmp/"},{"name":"snmp","slug":"snmp","permalink":"https://tsaiyuyan.github.io/tags/snmp/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"cross-compiler","slug":"cross-compiler","permalink":"https://tsaiyuyan.github.io/tags/cross-compiler/"}]},{"title":"Ubuntu 建立 qt cross-complier 開發環境","slug":"Linux/Ubuntu 建立 qt cross-complier 開發環境","date":"2019-05-17T05:00:00.000Z","updated":"2020-05-11T07:35:19.194Z","comments":true,"path":"2019/05/17/linux/ubuntu-jian-li-qt-cross-complier-kai-fa-huan-jing/","link":"","permalink":"https://tsaiyuyan.github.io/2019/05/17/linux/ubuntu-jian-li-qt-cross-complier-kai-fa-huan-jing/","excerpt":"","text":"類似文章請參考 “Ubuntu 建立 gdb cross-complier 開發環境”。如果有任何建議或疑問，歡迎在下方留言讓我知道。 一、環境 vmware 模擬 Ubuntu 16.04 LTS 64bit 二、事先準備 toolchain (arm 開發板廠商提供 or “sudo apt-get install gcc-arm-linux-gnueabi”) qt source code qt-everywhere-opensource-src-4.8.6.tar.gz tslib-1.4.tar.gz qt-creator qt-everywhere-opensource 三、qt creator 安裝$wget $sudo chmod +x qt-opensource-linux-x64-5.9.7.run","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"cross-compiler","slug":"cross-compiler","permalink":"https://tsaiyuyan.github.io/tags/cross-compiler/"},{"name":"qt","slug":"qt","permalink":"https://tsaiyuyan.github.io/tags/qt/"}]},{"title":"Ubuntu 建立 gdb cross-complier 開發環境","slug":"Linux/Ubuntu 建立 gdb cross-complier 開發環境","date":"2019-05-17T02:00:00.000Z","updated":"2020-05-11T07:35:19.171Z","comments":true,"path":"2019/05/17/linux/ubuntu-jian-li-gdb-cross-complier-kai-fa-huan-jing/","link":"","permalink":"https://tsaiyuyan.github.io/2019/05/17/linux/ubuntu-jian-li-gdb-cross-complier-kai-fa-huan-jing/","excerpt":"","text":"一、系統配置 gdb run on PC (test on Ubuntu LTS 16.04 64 bit ) gdbserver(cross complier) run on embede system(PEL3KS) arm-app(cross complier) run on ebede system(PEL3KS) 二、Download GDB Source Code gdb - https://ftp.gnu.org/gnu/gdb/gdb-7.9.tar.gz termcap - https://ftp.gnu.org/gnu/termcap/termcap-1.3.1.tar.gz expat - https://sourceforge.net/projects/expat/ sudo apt install textinfo (注意:此處不是用apt-get) 三、Prepare//這一步可以放在 ~/.profile最尾端，以方便登入後呼叫 arm-linux-gnueabihf-XXX(cross complier) $ export PATH=$PATH:/opt/toolchains/ti335x/i686-arago-linux/usr/bin $ cd ~/Desktop //解壓縮 gdb $ tar zxvf gdb-7.9.tar.gz //解壓縮 termcap $ tar zxvf termcap-1.3.1.tar.gz //解壓縮expat $ bzip2 -d expat-2.2.6.tar.bz2 $ tar xvf expat-2.2.6.tar 四、Build Build gdb -&gt; build gdbserver -&gt; build arm-app，過程中會遇到一些問題，所以會安裝 termcap、expat、textinfo 1.gdb$ cd gdb-7.9 $ ./configure --target=arm-linux-gnueabihf --program-prefix=arm-linux-gnueabihf- --prefix=/home/yuyan/Desktop/gdb-7.9-build // tips: -j2 表示指定cpu數量，可以加快編譯 $ make -j2 $ make install 2.gdbserver$ cd ~/Desktop/gdb-7.9/gdb/gdbserver //CC=為指定編譯器，CFLAGS式如果編譯器不是灌在系統裡的話，記得要指定不然make 基本上會失敗。 $ ./configure --target=arm-linux-gnueabihf --host=arm-linux-gnueabihf --prefix=/home/yuyan/Desktop/gdb-7.9-build CC=arm-linux-gnueabihf-gcc CFLAGS=\"-I /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/usr/include/\" 3.arm-app$ mkdir arm-app $ cd arm-app $ vim main.c //main.c #include &lt;stdio.h> int main(int argc,char *argv[]) { printf(\"Hello arm-app\\n\"); return 0; } $ vim Makefile // Makefile CXX=arm-linux-gnueabihf-gcc CXXFLAGS:=-g -I /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/usr/include/ BIN=main.out LDLIBS= CFLAGS=-g SRC=$(wildcard *.c) OBJ=$(SRC:%.c=%.o) all: $(OBJ) $(CXX) -o $(BIN) $^ %.o: %.c $(CXX) -c $&lt; $(CXXFLAGS) .PHONY:clean clean: rm -rf *.o rm $(BIN) $ make //將.out 傳至embede system，本文是用nfs 的方式。 $ cp main.out /var/nfsshare 五、疑難排解(編譯或程式執行時)1. gdb make (makeinfo: command not found )http://stackoverflow.com/questions/338317/what-is-makeinfo-and-how-do-i-get-it 提示錯誤:/home/gdb-7.9/missing: line 81: makeinfo: command not found WARNING: 'makeinfo' is missing on your system. You should only need it if you modified a '.texi' file, or any other file indirectly affecting the aspect of the manual. You might want to install the Texinfo package: The spurious makeinfo call might also be the consequence of using a buggy 'make' (AIX, DU, IRIX), in which case you might want to install GNU make: 安裝庫:sudo apt-get install textinfo即可 2. gdb make (error: no termcap library found)configure: error: no termcap library found make[1]: *** [configure-gdb] Error 1 make: *** [all] Error 2 //https://ftp.gnu.org/gnu/termcap/ $cd ./termcap-1.3.1 $./configure --target=arm-none-linux-gnueabi --prefix=/tmp/termcap $make $sudo make install $sudo cp /tmp/termcap/include/termcap.h /usr/include $sudo cp /tmp/termcap/lib/libtermcap.a /usr/lib $sudo rm -rf /tmp/termcap 3. gdbserver: linux-x86-low.cerror: sys/reg.h: No such file or directory 找到config.h裡HAVE_SYS_REG_H 將其註釋掉． 重新make(記得先make clean) 4. gdb run Remote ‘g’ packet reply is too long//修改gdb/remote.c文件中的static void process_g_packet (struct regcache *regcache) $ vim gdb/remote.c //由 if (buf_len > 2 * rsa->sizeof_g_packet) error (_(\"Remote 'g' packet reply is too long: %s\"), rs->buf); //改成 if (buf_len > 2 * rsa->sizeof_g_packet) { rsa->sizeof_g_packet = buf_len ; for (i = 0; i &lt; gdbarch_num_regs (gdbarch); i++) { if (rsa->regs->pnum == -1) continue; if (rsa->regs->offset >= rsa->sizeof_g_packet) rsa->regs->in_g_packet = 0; else rsa->regs->in_g_packet = 1; } } 5. gdb run (一執行就 Segment fault)如果gdb調試時經常崩潰不能運行gdb指令，且gdb加載調試程序時出現如下警告： \"warning: Can not parse XML target description; XML support was disabled at compile time\" 原因：gdb編譯時缺少XML的解析庫expat， 這個庫對gdb是可選項，但是我編譯gdb7.9的時候如果沒有這個庫卻不行，所以編譯的時候加入了這個庫。方法如下： 1 下載expat，跟解壓縮 http://sourceforge.net/projects/expat/ 2 配置和編譯expat $ cd expat-2.2.6 $ ./configure $ make &amp;&amp; make install 3.rebuild and re-complier gdb (記得先用 make distclean) 六、Use gdb 、gdbserver debug arm-appembede system:(啟動 gdbserver)$ cd /mnt/yuyan_nfs $./arm-linux-gnueabihf-gdbserver :10000 ./main.out PC:(使用 gdb 調適 arm-app)$ cd /var/nfsshare $ ls arm-linux-gnueabihf-gdb arm-linux-gnueabihf-gdbserver main.out $ ./arm-linux-gnueabihf-gdb arm-app.out GNU gdb (GDB) 7.9 Copyright (C) 2015 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html> This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type \"show copying\" and \"show warranty\" for details. This GDB was configured as \"--host=x86_64-unknown-linux-gnu --target=arm-linux-gnueabihf\". Type \"show configuration\" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/>. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/>. For help, type \"help\". Type \"apropos word\" to search for commands related to \"word\"... Reading symbols from main.out...done. (gdb) target remote 172.16.27.130:10000 Remote debugging using 172.16.27.130:10000 warning: Unable to find dynamic linker breakpoint function. GDB will be unable to debug shared library initializers and track explicitly loaded dynamic code. 0xb6fe0c80 in ?? () (gdb) b main Breakpoint 1 at 0x8430: file main.c, line 12. (gdb) bt #0 0xb6fe0c80 in ?? () #1 0x00000000 in ?? () Backtrace stopped: previous frame identical to this frame (corrupt stack?) (gdb) set solib-search-path /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib Reading symbols from /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/ld-2.15.so...(no debugging symbols found)...done. (gdb) bt #0 0xb6fe0c80 in ?? () from /opt/toolchains/ti335x/cortexa8t2hf-vfp-neon-linux-gnueabi/lib/ld-2.15.so #1 0x00000000 in ?? () Backtrace stopped: previous frame identical to this frame (corrupt stack?) (gdb) r The \"remote\" target does not support \"run\". Try \"help target\" or \"continue\". (gdb) continue Continuing. Breakpoint 1, main () at main.c:12 12 printf(\"Hello World!\\n\"); (gdb) bt #0 main () at main.c:12 (gdb) continue Continuing. [Inferior 1 (process 835) exited normally] (gdb) q","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"cross-compiler","slug":"cross-compiler","permalink":"https://tsaiyuyan.github.io/tags/cross-compiler/"},{"name":"gdb","slug":"gdb","permalink":"https://tsaiyuyan.github.io/tags/gdb/"},{"name":"gdbserver","slug":"gdbserver","permalink":"https://tsaiyuyan.github.io/tags/gdbserver/"}]},{"title":"Ubuntu 使用 docker 筆記","slug":"Linux/Ubuntu 使用 docker 筆記","date":"2019-05-15T02:00:00.000Z","updated":"2020-07-29T09:38:17.769Z","comments":true,"path":"2019/05/15/linux/ubuntu-shi-yong-docker-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2019/05/15/linux/ubuntu-shi-yong-docker-bi-ji/","excerpt":"","text":"Agenda Foreword Introduction Concept Run Docker Foreword研究 Docker 的起因 虛擬機每次要重新建置一樣的環境，需要很長的時間 虛擬機比較難模擬真實環境，因資源需求較高 承上，虛擬機執行的數量會受限於本機資源 環境一旦複雜，設定會很困難。 Introduction Docker 能做什麼事 Docker 怎麼辦到的 虛擬機能做的幾乎都能做得到 隔離應用 儲存在發布 具備可攜性 環境即程式碼 Concept 映像檔 - Image (git log/Vagrant Box) 容器 - Container (Staging / Running VM) 倉庫 - Repository (GitHub /VagrantCloud) 使用 Docker Container 很像虛擬機 虛擬 IP、Port Forwarding… 管理 Docker Image 的觀念很像 Git commit、pull、push… Run DockerInstallation Linux 懶人安裝指令 $curl -sSL https://get.docker.com/ | sudo sh Windowss 10 和 Mac 也都能直接裝(since 1.12) Commands Command Note docker pull 下載映像檔 docker images 看目前有哪些映像檔 docker rmi 刪除映像檔 docker run 建立容器並執行指令 docker start/stop/restart 操作容器 docker ps 看目前有哪些容器正在執行 docker rm 刪除容器 Command - Hello world$docker run -d nginx $docker run -d nginx:1.11-alpine $docker images $docker ps $docker stop $docker rm Command - Port forwarding$docker run -d --name my-nginx -p 0.0.0.0:8080:80 nginx # --name: 容器名稱 # -p: 設定連接port，格式[hostIP]:[hostPort]L[ContainerPort] $docker stop my-nginx $docker rm -f my-nginx # 加入 -f 才能把正在執行的容器刪除 Command - Run PHP command$docker -run --rm -it php php -v --rm: 執行完指令就把容器刪除 -it: 開啟互動和終端機輸出，執行過程中有輸入就需要這兩個選項 php: 映像檔，沒有tag的話，預設會用 latest 版本 php -v: 要在容器執行的命令 Command - Run local programn$echo \"\" > hw.php $docker run -v `pwd`:/var/www/html php php /var/www/html/hw.php # -v: 掛載檔案到容器，參數格式 [/host]:[/container] # php /var/www/html/hw.php: 執行 php # -w path 更改工作目錄 Command - Environment$docker run -d -p 0.0.0.0:3306:3306 -e MYSQL_ROOT_PASSWORD=passwrod mariadb:5.5 # -d: 背景執行 # -e: 設定環境變數 $docker logs # 即可看到背景執行時的 狀況 Command - Link$docker run -d --name cache -d memcached $docker run -d --name my-nginx --link cache:c nginx $docker exec -it my-nginx bash # apt-get install telnet # telnet c 11211 # --Link: 連接到某個容器，格式 [容器名]:[別名] Conclusion Docker 可快入建立一個以定義好的環境 開發與測試非常適合使用 Troubleshooting How can I use docker without sudo ? # Add the docker group if it doesn't already exist: $sudo groupadd docker groupadd: group 'docker' already exists # Add the connected user \"[USER]\" to the docker group. # Change the user name to match your preferred user if you do not want to use your current user: $sudo gpasswd -a [USER] docker Adding user [USER] to group docker $newgrp docker $docker run hello-world","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"note","slug":"note","permalink":"https://tsaiyuyan.github.io/tags/note/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"docker","slug":"docker","permalink":"https://tsaiyuyan.github.io/tags/docker/"}]},{"title":"Ubuntu 開發 net-snmp","slug":"Linux/Ubuntu 開發 net-snmp","date":"2019-05-14T09:00:00.000Z","updated":"2020-09-30T03:33:17.368Z","comments":true,"path":"2019/05/14/linux/ubuntu-kai-fa-net-snmp/","link":"","permalink":"https://tsaiyuyan.github.io/2019/05/14/linux/ubuntu-kai-fa-net-snmp/","excerpt":"","text":"繼上篇文章 “Ubuntu 編譯 net-snmp”，我們將 net-snmp 建立在/usr/local/net-snmp，本篇將介紹如何撰寫 subagent、snmpget、snmpset 的 code，以及如何利用 broadcast 詢問到支援 snmp 的設備。 另外因為我們是自己 build 一個環境，所以我們並沒有將 snmpd 掛載成一個服務，所以本篇全部都是以執行檔的方式使用 net-snmp 的程式 一、 snmpd service1. snmpd.conf 配置不囉嗦，直接建立好 v1、v2 的 rocomunity、rwcomunity， v3 之後出現 user 的存在一樣是 rwuser、rouser。 ########################################################################### # # snmpd.conf # # - created by the snmpconf configuration program # ########################################################################## # SECTION: System Information Setup # # This section defines some of the information reported in # the \"system\" mib group in the mibII tree. # syslocation: The [typically physical] location of the system. # Note that setting this value here means that when trying to # perform an snmp SET operation to the sysLocation.0 variable will make # the agent return the \"notWritable\" error code. IE, including # this token in the snmpd.conf file will disable write access to # the variable. # arguments: location_string syslocation Taiwan # syscontact: The contact information for the administrator # Note that setting this value here means that when trying to # perform an snmp SET operation to the sysContact.0 variable will make # the agent return the \"notWritable\" error code. IE, including # this token in the snmpd.conf file will disable write access to # the variable. # arguments: contact_string syscontact XXXXXXXXXXX@gmail.com ########################################################################### # SECTION: Access Control Setup # # This section defines who is allowed to talk to your running # snmp agent. # rouser: a SNMPv3 read-only user # arguments: user [noauth|auth|priv] [restriction_oid] createUser yuyan MD5 \"987654321\" DES \"123456789\" createUser wyuyan MD5 \"987654321\" DES \"123456789\" rouser yuyan rwuser wyuyan # rocommunity: a SNMPv1/SNMPv2c read-only access community name # arguments: community [default|hostname|network/bits] [oid] rocommunity ezio rwcommunity wezio # 可以指定你的 agent 要開甚麼 port，監聽哪張網卡的IP選0.0.0.0就是都監聽。 agentAddress udp:0.0.0.0:1611 # extend 作用就是當管理端用snmpget 詢問到你指定的 oid 你可以做一些script 的動作 extend .1.3.6.1.4.1.2021.999 ezio \"echo 123456\" 78910 # exec exec .1.3.6.1.4.1.2021.51 ps /bin/ps exec .1.3.6.1.4.1.2021.52 script /bin/sh /tmp/ca_check.sh #表示本服務是master，要讓 subagent 連線，我們將port開在1610並且用tcp的方式 master agentx agentxsocket tcp:localhost:1610 2. snmpd 執行Finish configure and save, then start the snmpd. Ex: #at /usr/local/net-snmp/sbin $sudo ./snmpd -c ../share/snmp/snmpd.conf #or $sudo ./snmpd -c ../share/snmp/snmpd.conf -f -Le -d #or $sudo ./snmpd -c ../share/snmp/snmpd.conf -f -Le -Dread_config #snmpd 會掛在背景，用netstat -aunt 檢查udp:1611 跟 tcp:1610 port有沒有監聽成功 '小技巧：可以使用snmpd -f -Le -Dread_config 命令來查看日誌文件信息，排錯。 snmpd命令的有用選項： -c FILE 指定文件為配置文件 -C 不讀取默認的配置文件 -d dump接收和發送SNMP數據包 -D TOKEN 對於給定的TOKEN（標誌）打開調試信息 （ -Dmib_init） -I [-]INITLIST 對於要初始化的MIB列表顯示 -M DIRLIST 指定MIB庫的路徑 -V 顯示詳細信息 -Le 把錯誤信息輸出到日誌中 -Lf FILE 把錯誤信息輸出到指定文件中 -m MIBLIST use MIBLIST instead of the default MIB list' $ netstat -aunt Active Internet connections (servers and established) Proto Recv-Q Send-Q Local Address Foreign Address State (略)... tcp 0 0 127.0.0.1:1610 0.0.0.0:* LISTEN (略)... udp 0 0 0.0.0.0:1611 0.0.0.0:* #用 snmpget 測試 snmpd $ 二、SNMP 應用程式開發0. Folder Structure$tree -d ├── build (建置PC程式) ├── arm-build (建置arm程式) ├── include(header) ├── lib(library) ├── ref(參考範例、內有makefile參考) └── src(source code) CMakeLists.txt toolchain.cmake 1. CMakeLists.txt 撰寫Source Link: https://github.com/tsaiyuyan/netsnmpProjects/blob/master/snmp-command/CMakeLists.txt https://github.com/tsaiyuyan/netsnmpProjects/blob/master/snmp-subagent/CMakeLists.txt # CMakeLists.txt cmake_minimum_required(VERSION 2.8) # use folder name as project name get_filename_component(ProjectId ${CMAKE_CURRENT_SOURCE_DIR} NAME) string(REPLACE \" \" \"_\" ProjectId ${ProjectId}) project(${ProjectId}) set(CMAKE_BUILE_TYPE DEBUG) set(CMAKE_C_FLAGS_DEBUG \"-O0 -g -Wall\" ) # Debug not optimize set(CMAKE_C_FLAGS_RELEASE \"-O2 -DNDEBUG \" ) # release optimeze set(CMAKE_CXX_FLAGS_DEBUG \"-O0 -g -Wall\" ) # Debug not optimize set(CMAKE_CXX_FLAGS_RELEASE \"-O2 -DNDEBUG \" ) # release optimeze #set(EXECUTABLE_OUTPUT_PATH \"${CMAKE_CURRENT_LIST_DIR}\") set(EXECUTABLE_OUTPUT_PATH \"${CMAKE_CURRENT_BINARY_DIR}\") message(STATUS \"Project: ${ProjectId}\") message(STATUS \"Project Directory: ${PROJECT_SOURCE_DIR}\") message(STATUS \"Source Directory: ${CMAKE_CURRENT_LIST_DIR}/src\") message(STATUS \"Output Directory: ${CMAKE_CURRENT_BINARY_DIR}\") # source code aux_source_directory(${CMAKE_CURRENT_LIST_DIR}/src DIR_SRC) # include include_directories(${CMAKE_CURRENT_LIST_DIR}/include /usr/local/net-snmp/include) # library ${CMAKE_CURRENT_LIST_DIR}/lib link_directories(/usr/local/net-snmp/lib) # build message(STATUS \"Source Files: ${DIR_SRC}\") add_executable(${PROJECT_NAME}.out ${DIR_SRC}) target_link_libraries(${PROJECT_NAME}.out -lnetsnmpmibs -lnetsnmpagent -lnetsnmp -lnetsnmpmibs -lnetsnmpagent -lnetsnmp -ldl -lm) 2. toolchain.cmake 撰寫 這個檔案是方便做交叉編譯時使用。 Source Link: https://github.com/tsaiyuyan/netsnmpProjects/blob/master/toolchain.cmake 3. Makefile 撰寫(可選) 如果不想要使用 cmake 可以參考本 makefile 的範例，只是沒有 cmake 封裝的那麼好就是了，但也算寫的簡潔明瞭。撰寫 makefile 在於要知道 net-snmp 的 include 和 library 在哪些位置。和要鏈結哪些 lib。 TARGET=XXXXXXXXXXX.out CC=gcc SRCS=$(wildcard *.c) HEADS=$(shell find ./include -type f -name *.h) OBJS=$(SRCS:%.c=%.o) INCLUDES=/usr/local/net-snmp/include/ CFLAGS=-g -O2 -Wall -I$(INCLUDES) LDFLAGS=-lnetsnmpmibs -lnetsnmpagent -lnetsnmp -lnetsnmpmibs -ldl -lnetsnmpagent -lnetsnmp -lm LIBS=-L/usr/local/net-snmp/lib all: $(OBJS) $(CC) $(CFLAGS) -o $(TARGET) $(OBJS) $(LIBS) $(LDFLAGS) %.o: %.cpp $(CC) $(CFLAGS) -c $^ -o $@ .PHONY: clean clean: rm -rf *.o *.out run: ./$(TARGET) tags: ctags -R -f ./.tags --c++-kinds=+p --fields=+iaS --extra=+q $(INCLUDES) 4. subagent code subagent 的作用就是可以掛在你自己那端的程式，方便擴充 mibs，好處就是說程式不會跟 snmpd 綁在一起，也就是自己寫的程式 crash 還是能確保管理端能夠找到此設備。subagent 會內建 tcp 連線 snmpd。 Source link: https://github.com/tsaiyuyan/netsnmpProjects/tree/master/snmp-subagent 以上就是 only read oid(.1.3.6.1.4.1.16535.1.1.0)跟 write/read oid(.1.3.6.1.4.1.16536.1.1.0)被觸發時，會 call function 的基本代碼，另外官網也有提供，純量(scalar)的 oid 唯讀，詳情請洽官網教學頁面。 make 之後會產生 snmp-subagent.out，直接執行即可。如果想執行在背景可以將 main()裡面的 dont_fork 參數改成 0，他會以 daemon 的方式執行。 5. snmp-command code If the master agent and subagent get ready, we will write a code to try whether service is working. In addition, snmp-command includes snmpget、snmpset、finding snmp device by using broadcast functions. Source link: https://github.com/tsaiyuyan/netsnmpProjects/tree/master/snmp-command There are three following functions to mainly use. // file:snmp_tool.h int ysnmp_broadcast(struct snmp_session *ss, const char *intoid, char *host_ip); int ysnmp_setInt(struct snmp_session *ss, const char *intoid, char *val); int ysnmp_getInt(struct snmp_session *ss, const char *intoid, char *val);","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"net-snmp","slug":"net-snmp","permalink":"https://tsaiyuyan.github.io/tags/net-snmp/"},{"name":"snmp","slug":"snmp","permalink":"https://tsaiyuyan.github.io/tags/snmp/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"}]},{"title":"Pandora FMS 使用筆記","slug":"Pandora FMS 使用筆記","date":"2019-05-11T02:00:00.000Z","updated":"2020-05-11T07:35:19.116Z","comments":true,"path":"2019/05/11/pandora-fms-shi-yong-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2019/05/11/pandora-fms-shi-yong-bi-ji/","excerpt":"","text":"熟悉 snmp 協定應用，再來使用 Pandora FMS 做監控。 配置環境 Vmware 下載 .iso CentOS Appliance ISO 流程 將下載好的 iso 檔案用 VMware 裝上 將虛擬機打開 OS 是 centos 打開瀏覽器將虛擬機的 ip 打上去，預設是 80 port，也不用對 pandora 設定就可以使用。 Web Page Default account and password account : admin password : pandora Video Pandora FMS: the flexible monitoring software Network Maps in Pandora FMS 7.0 NG Port’s status check (TCP)","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"note","slug":"note","permalink":"https://tsaiyuyan.github.io/tags/note/"},{"name":"snmp","slug":"snmp","permalink":"https://tsaiyuyan.github.io/tags/snmp/"},{"name":"pondora FMS","slug":"pondora-FMS","permalink":"https://tsaiyuyan.github.io/tags/pondora-FMS/"}]},{"title":"Ubuntu 編譯 net-snmp","slug":"Linux/Ubuntu 編譯 net-snmp","date":"2019-04-25T02:00:00.000Z","updated":"2020-12-17T08:46:11.788Z","comments":true,"path":"2019/04/25/linux/ubuntu-bian-yi-net-snmp/","link":"","permalink":"https://tsaiyuyan.github.io/2019/04/25/linux/ubuntu-bian-yi-net-snmp/","excerpt":"","text":"一、前言目前最有影響的網絡管理協議是 SNMP 和 CMIS/CMIP在「網絡管理站-網管代理」的模型中，如果各個廠商提供的網絡管理站和網管代理之間的通信方式各不相同，將會大大影響網絡管理系統的通用性，影響不同廠商設備間的互連，因此需要制定一個網絡管理站和網管代理之間通信的標準。 網絡管理協議就是用於網絡管理站和網管代理之間傳遞信息，並能完成信息交換安全控制的通信規則。 網絡管理站通過網絡管理協議從網管代理那裡獲取被管設備的管理信息或向網管代理髮送命令；網管代理也可以通過網絡管理協議主動向管理站報告緊急信息。 目前最有影響的網絡管理協議是SNMP和CMIS/CMIP。它們代表了目前兩大網絡管理解決方案。 其中 SNMP 流傳最廣，應用最多，獲得的支持也最廣泛，已經成為事實上的工業標準。 原文網址：https://kknews.cc/news/zkyaz5a.html SNMP 與 CMIP/CMIS 的比較SNMP 採用無連接，不保證可靠的 UDP 傳輸服務，而 CMIP 採用 OSI/RM 鐘面向連接可靠的傳輸服務，SNMP 是個簡單、低成本和容易實現的解決方案，他的原則是:對被管理的系統帶來的影響要最小。CMIP 是一個資源耗費多的管理框架，管理功能強，但耗費時間多，相應軟體在管理和被管對象上運行的額外開銷大。 SNMP 的主要缺點是: 不能有效地傳送大塊數據 不能將網路管理的功能分散化 安全性不夠好(後面衍伸 V2、V3) PDU 協議數據單元在電信領域，協議數據單元（英語：Protocol Data Unit，縮寫為 PDU）有以下幾層意義： 網絡的對等實體傳送的信息單元，包括了控制信息，地址信息，或者數據。 在分層協議系統里，在指定的協議層上傳送的數據單元，包含了該層的協議控制信息和用戶信息。 在 OSI 模型系統里，PDU 和最底下四層相關。 物理層（一層）PDU 指數據位（Bit）。 數據鏈路層（二層）PDU 指數據幀（Frame）。 網絡層（三層）PDU 指數據包（Datagram）。 傳輸層（四層）PDU 指數據段（Segment）。 應用層（五層）PDU 指數據段（Packet）。 原文網址：https://zh.wikipedia.org/wiki/协议数据单元 原文網址：https://en.wikipedia.org/wiki/Protocol_data_unit 二、SNMP 介紹SNMP 中定義了五種消息類型：Get-Request、Get-Response、Get-Next-Request、Set-Request 和 Trap。SNMP 五種消息類型 (1)Get-Request 、Get-Next-Request 與 Get-ResponseSNMP 管理站用 Get-Request 消息從擁有 SNMP 代理的網絡設備中檢索信息，而 SNMP 代理則用 Get-Response 消息響應。Get-Next- Request 用於和 Get-Request 組合起來查詢特定的表對象中的列元素。 (2)Set-RequestSNMP 管理站用 Set-Request 可以對網絡設備進行遠程配置（包括設備名、設備屬性、刪除設備或使某一個設備屬性有效/無效等）。 (3)TrapSNMP 代理使用 Trap 向 SNMP 管理站發送非請求消息，一般用於描述某一事件的發生，如接口 UP/DOWN，IP 位址更改等。 原文網址：https://kknews.cc/zh-tw/entertainment/p4vv2mp.html Extend SNMP – Run bash scripts via SNMP1. Edit snmpd.conf$ vim /etc/snmp.conf # Extend SNMP extend script1 /etc/snmp/scripts/script1.sh extend script2 /etc/snmp/scripts/script2.sh 2. Restart SNMPD Service$ sudo service snmpd restart Stopping snmpd: [ OK ] Starting snmpd: [ OK ] 原文網址：https://geekpeek.net/extend-snmp-run-bash-scripts-via-snmp/ net-snmp 指令1.snmpwalk執行一系列 snmpgetnext 指令的集合。 snmpwalk的用法 snmpwalk -v 1或2(代表SNMP版本) -c SNMP讀密碼 IP地址 OID(對象標示符) (1) -v： 指定snmp的版本, 1或者2； (2) -c: 指定連接設備SNMP讀密碼； (3) IP: 指定要walk的設備的IP地址； (4) Oid：代表要獲取設備的指標oid； 用法舉例： 例如獲取cisco設備192.168.17.191的接口類型 snmpwalk –v 2c –c public 192.168.17.191 1.3.6.1.2.1.2.2.1.3 2.snmpget可從指定的主機擷取 MIB 資訊。 3.snmpgetnext循序存取沒有定義 index 的資訊。 4.snmpset將指定的資訊寫入定義好的 MIB 資料庫中。 5.snmptrap大部分 SNMP 流量都是由網管系統流向網路設備；而 snmptrap 是由網路設備主動發送相關必要資訊給網管系統。 6.snmptable將定義好的 table 格式資料印出在螢幕上。 三、建置 net-snmp 開發環境1.下載 net-snmp source codehttp://www.net-snmp.org/ 2.解壓縮$tar -zxvf net-snmp-5.7.3.tar.gz 3.建立 Makefile$./configure --prefix=/usr/local/net-snmp //依序填入相關設定 $sudo make $sudo make install $cd /usr/local/net-snmp/sbin $ ./snmpd -v NET-SNMP version: 5.7.3 Web: http://www.net-snmp.org/ Email: net-snmp-coders@lists.sourceforge.net 4.疑難排解1. cannot find -lperlcode: /usr/bin/ld: cannot find -lperl collect2: error: ld returned 1 exit status Makefile:976: recipe for target 'libnetsnmpagent.la' failed make[1]: *** [libnetsnmpagent.la] Error 1 make[1]: *** Waiting for unfinished jobs.... solution: $sudo apt-get install libperl-dev 四、請閱讀下一章節本篇先學習相關知識，以及創建開發環境，下一篇介紹，如何寫一個 subagent、跟如何做一個相同 snmpget、snmpset。以及如何利用 broadcast 尋找支援 snmp 的設備，算是一種 snmp network discovery 的應用吧。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"net-snmp","slug":"net-snmp","permalink":"https://tsaiyuyan.github.io/tags/net-snmp/"},{"name":"snmp","slug":"snmp","permalink":"https://tsaiyuyan.github.io/tags/snmp/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"}]},{"title":"VC++ emWin 使用 VS2015_2017 執行","slug":"Windows/VC++ emWin 使用 VS2015_2017 執行","date":"2019-04-15T03:00:00.000Z","updated":"2020-05-11T07:35:19.218Z","comments":true,"path":"2019/04/15/windows/vc-emwin-shi-yong-vs2015-2017-zhi-xing/","link":"","permalink":"https://tsaiyuyan.github.io/2019/04/15/windows/vc-emwin-shi-yong-vs2015-2017-zhi-xing/","excerpt":"","text":"emWin 測試版本ver-548 官方文件 HowTo_RunSimulationUnderVS2015_2017.txtMake sure the selected Windows SDK is installed: Properties -> Configuration Properties -> General -> Windows SDK Version. 1. Right-Click on the Project (e.g. SimulationTrial) -> Properties 2 Set Configuration to \"All Configurations\" 2. Goto Configuration Properties -> Linker -> Input. 3. Add under Additional Dependencies: \"legacy_stdio_definitions.lib\" 4. Set Ignore All Default Libraries: \"No\" 5. Set Ignore Specific Default Libraries: \"LIBC.lib;LIBCMTD.lib\" 6. Goto Configuration Properties -> Linker -> Advanced 7. Set Image Has Safe Exception Handlers:\"No (/SAFESEH:NO)\" 8. Click \"OK\"-Button. 參考 emWin 學習筆記 —— 用 VS2017 打開 emWin 仿真包","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[{"name":"visual-studio","slug":"visual-studio","permalink":"https://tsaiyuyan.github.io/tags/visual-studio/"},{"name":"emWin","slug":"emWin","permalink":"https://tsaiyuyan.github.io/tags/emWin/"}]},{"title":"Ubuntu 使用 PuTTY","slug":"Linux/Ubuntu 使用 PuTTY","date":"2019-04-15T02:00:00.000Z","updated":"2020-05-11T07:35:19.156Z","comments":true,"path":"2019/04/15/linux/ubuntu-shi-yong-putty/","link":"","permalink":"https://tsaiyuyan.github.io/2019/04/15/linux/ubuntu-shi-yong-putty/","excerpt":"","text":"一、參考 Ubuntu putty and serial port ubuntu 下 putty 的安装及使用 二、安裝$sudo apt-get install putty 三、Serial想要連接 USB 的設備，可用下面指令查詢。 $dmesg | grep tty 會有類似下面這些訊息 [ 0.004000] console [tty0] enabled [13717.128808] usb 2-2.1: pl2303 converter now attached to ttyUSB0 [14012.316511] pl2303 ttyUSB0: pl2303 converter now disconnected from ttyUSB0 [16342.257581] usb 2-2.1: pl2303 converter now attached to ttyUSB0 [16649.018181] pl2303 ttyUSB0: pl2303 converter now disconnected from ttyUSB0 [16664.494877] usb 2-2.1: pl2303 converter now attached to ttyUSB0 [16730.009623] pl2303 ttyUSB0: pl2303 converter now disconnected from ttyUSB0 [16736.683650] usb 2-2.2: pl2303 converter now attached to ttyUSB0 四、範例$sudo putty /dev/ttyUSB0 -serial -sercfg 115200,8,n,1,N or $sudo putty 五、注意事項 如果要連結 serial，記得要加 sudo 執行，不然會一直出現 unable to connect 訊息。","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"tools","slug":"tools","permalink":"https://tsaiyuyan.github.io/tags/tools/"},{"name":"PuTTY","slug":"PuTTY","permalink":"https://tsaiyuyan.github.io/tags/PuTTY/"}]},{"title":"Ubuntu 設定 Samba 分享檔案","slug":"Linux/Ubuntu 設定 Samba 分享檔案","date":"2019-04-09T05:00:00.000Z","updated":"2020-05-11T07:35:19.204Z","comments":true,"path":"2019/04/09/linux/ubuntu-she-ding-samba-fen-xiang-dang-an/","link":"","permalink":"https://tsaiyuyan.github.io/2019/04/09/linux/ubuntu-she-ding-samba-fen-xiang-dang-an/","excerpt":"","text":"Link: https://www.arthurtoday.com/2015/04/ubuntu-server-share-folder-samba.html 一、Samba Server安裝 Samba Server$sudo apt-get install samba設定不須登入/操作 Shell 的帳號$sudo adduser smbuser --shell /bin/false設定密碼$sudo smbpasswd -a smbuser移除使用者(可選)$smbpasswd -x smbuser $userdel -r smbuser調整 Samba 的設定檔/etc/samba/smb.conf，在檔案的尾巴加入下面這幾行後存檔離開。 [share] path = /home/smbuser # 這個是要分享的資料夾路徑 available = yes valid users = smbuser # 這個是可以使用這個分享資料夾的使用者，要具有 path 所指定的路徑的權限才行 read only = no browseable = yes public = yes writable = yes 重啟 Samba Server$sudo service smbd restart 二、Linux 連結 Samba Server$sudo apt-get install smbclient cifs-utils $sudo mkdir -p /mnt/share $sudo mount -t cifs //{Samba Server IP}/share /mnt/share -o username=smbuser,password=123456789 $df $sudo umount /mnt/share 三、Windows 連結 Samba Server Windows 功能開啟 (預設程式-&gt;開啟或關閉 windows 功能)-&gt;打勾 SMB 1.0/CIFS File Sharing Support 開啟檔案總管 key 上 \\\\{Samba Server IP}\\share 登入帳密即可","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"samba","slug":"samba","permalink":"https://tsaiyuyan.github.io/tags/samba/"}]},{"title":"Ubuntu 安裝 NFS Server","slug":"Linux/Ubuntu 安裝 NFS Server","date":"2019-04-09T03:00:00.000Z","updated":"2023-03-03T05:41:53.220Z","comments":true,"path":"2019/04/09/linux/ubuntu-an-zhuang-nfs-server/","link":"","permalink":"https://tsaiyuyan.github.io/2019/04/09/linux/ubuntu-an-zhuang-nfs-server/","excerpt":"","text":"Link: https://www.opencli.com/linux/debian-ubuntu-install-nfs-server NFS (Network File System) 是讓 Unix Like 的作業系統, 能用 mount 的方式來存取遠端伺服器分享出來的目錄, 讓操作起來像操作本機目錄一樣。以下會介紹在 Debian 及 Ubuntu 安裝及設定 NFS Server 的方法: 一、NFS Server 安裝安裝 NFS$sudo apt-get install nfs-kernel-server nfs-common設定分享的目錄, 以下是 /var/nfsshare$sudo mkdir -p /var/nfsshare $sudo chmod -R 777 /var/nfsshare/開啟 /etc/exports 檔案, 加入以下內容/var/nfsshare 172.16.26.*(rw,sync,no_root_squash,no_all_squash)啟動 NFS Server$/etc/init.d/nfs-kernel-server restart檢查有沒有啟動成功(可選)$ showmount -e Export list for ubuntu: /var/nfsshare 192.168.*.*,172.16.*.*檢查支援 (可選)在板子上檢查有無支援 NFS $cat /proc/filesystems nodev sysfs nodev tmpfs nodev bdev nodev proc nodev cgroup nodev cgroup2 nodev cpuset nodev devtmpfs nodev configfs nodev debugfs nodev tracefs nodev securityfs nodev sockfs nodev bpf nodev pipefs nodev ramfs nodev hugetlbfs nodev devpts ext3 ext2 ext4 squashfs vfat nodev ecryptfs fuseblk nodev fuse nodev fusectl nodev mqueue nodev pstore nodev autofs nodev rpc_pipefs nodev nfsd # &lt;=== 有支援 NFS nodev overlay nodev aufs nodev vboxsf iso9660 二、Linux 連結 NFS ServerNFS Client 安裝$sudo apt-get install nfs-common建立 NFS 目錄掛載點$sudo mkdir -p /mnt/nfs/var/nfsshareNFS Server 分享出來的目錄$sudo mount -t nfs {NFS Server IP}:/var/nfsshare /mnt/nfs/var/nfsshare/ -o nolock如果需要下次重新開機後就會自動掛載, 現在開啟 /etc/fstab, 加入以下內容{NFS_Server_IP}:/var/nfsshare /mnt/nfs/var/nfsshare nfs defaults 0 0三、Windows 連接 NFS Server Windows 功能開啟 (預設程式-&gt;開啟或關閉 windows 功能)-&gt;打勾 Service for NFS 開啟檔案總管 key 上 \\172.16.26.166\\var\\nfsshare 四、卸載設備列出掛載的設備: $mount或 $df -h卸載設備: $sudo unmount /mnt/nfs/var/nfsshare","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"nfs","slug":"nfs","permalink":"https://tsaiyuyan.github.io/tags/nfs/"}]},{"title":"Ubuntu Adding Eclipse to Launcher","slug":"Linux/Ubuntu Adding Eclipse to Launcher","date":"2019-04-09T02:30:00.000Z","updated":"2020-05-11T07:35:19.142Z","comments":true,"path":"2019/04/09/linux/ubuntu-adding-eclipse-to-launcher/","link":"","permalink":"https://tsaiyuyan.github.io/2019/04/09/linux/ubuntu-adding-eclipse-to-launcher/","excerpt":"","text":"Link: http://donovanbrown.com/post/Adding-Eclipse-to-Launcher-on-Ubuntu-1604 Open a text editor Copy and paste the following text into the editor: [Desktop Entry] Version = 1.0 Name=Eclipse Comment=Used to run C++ Terminal=false Type=Application Categories=Application Exec=/home/{username}/eclipse/cpp-2019-03/eclipse/eclipse Icon=/home/{username}/eclipse/cpp-2019-03/eclipse/icon.xpm Update any paths if you extracted Eclipse to a different location Save the file as eclipse.desktop in /home/{username}/.local/share/applications/ Reboot your machine Search for Eclipse Drag and drop the Eclipse icon to the launcher","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"}]},{"title":"YuYan's 電源軟體部工作筆記","slug":"ezio_worklog/YuYan's 電源軟體部工作筆記","date":"2019-04-01T05:00:00.000Z","updated":"2020-09-21T05:44:38.047Z","comments":true,"path":"2019/04/01/ezio-worklog/yuyan-s-dian-yuan-ruan-ti-bu-gong-zuo-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2019/04/01/ezio-worklog/yuyan-s-dian-yuan-ruan-ti-bu-gong-zuo-bi-ji/","excerpt":"","text":"20200417 已停更 一、一般資訊email ezio_tsai@goodwill.com.tw (我) yuanyu.tseng@gmail.co (YY) jadvil_chang@goodwill.com.tw (永和) allen_tseng@goodwill.com.tw (子倫) email SMTP Server webmail.goodwill.com.tw 分機 579 座位 253 資訊室 座位 中濱(和軒後面) 和宣(佩恩左前) 藍亮(佩恩正前) 德和(宇彥正前) 佩恩(左邊) 漢隆(右邊) 展燁(後方) 育緯(YY 後方) 永和(漢隆後方) 小新(在硬體部門) 淑吟(漢隆右邊) 婉英(佩恩左後) 子倫(永和對面) 傳藤 (很遠) 天劍 (硬體申請，買 SSD 的大大) 小新 (硬體部門，有點金髮，微壯) 金龍 (異位性皮膚炎患者，有月亮臉) 林谷鴻 (福委?) 張智傑 (漢隆對面，linux kernel 開發者) (Xlinux Zynq) 座位示意圖 中濱 何宣 藍亮 德和 張智傑 怡宏 佩恩 宇彥(離職) 漢隆 淑吟 育緯 婉英 法名(離職) 展燁 永和 子倫 YY 二、Physical MachineWindows 10軟體安裝 ACDSee Pro (圖片檢視器) Photoshop (影像處理) Chrome Vmware 12 Mircosoft Office Standard 2010(Word、Excel、Outlook、PowerPoint) Git for windows TortoiseGit (版控小烏龜) Visual Studio Code 7z 19.00 WinRAR 5.70 PotPlayer Line NodeJS (hexo會用到) Dexpot (多桌面軟體) notepad++ PuTTY release 0.71 VMware Workstation Pro Oracle VM VirtualBox Wireshark 3.0.0 MiniTool Partition Wizard Free 11 (硬碟分割) FileZilla (FTP 客戶端程式) VS2017 Pro VS2019 Community Windows 功能開啟 (預設程式-&gt;開啟或關閉 windows 功能) SMB 1.0/CIFS File Sharing Support (開啟後曾能跟 linux samba 連線) Telnet Client Service for NFS (開啟後曾能跟 linux NFS 連線，用於多種嵌入式系統) Regedit (註冊碼變更) Windows_Aero_Shake(視窗搖晃功能) Add Right Click menu - Force a program to run without administrator privileges or UAC(在右鍵菜單放入一般使用者開啟選項) 三、 Virtual MachineUnbuntu LTS 16.04 amd64 &amp;&amp; i386apt-get install ssh (putty 遠端連線用) g++ gcc htop (進間工作管理員) tmux (終端機分割成是) vim iftop (網路監控) curl gitk (版控 gui 陽春顯示) gdbserver tree 卸載老舊版本（若未安裝可以省略此步驟）： $ sudo apt-get remove docker docker-engine docker.io 安装最新的docker： $ curl -fsSL get.docker.com -o get-docker.sh $ sudo sh get-docker.sh apt-get update 一直 Failed to fetch$sudo vim /etc/resolv.conf #add nameserver 8.8.8.8 $sudo resolvconf -u $sudo apt-get update ... Reading package lists... Done","categories":[{"name":"ezio_worklog","slug":"ezio-worklog","permalink":"https://tsaiyuyan.github.io/categories/ezio-worklog/"}],"tags":[]},{"title":"419. Battleships in a Board","slug":"Leetcode/419_Battleships in a Board","date":"2019-03-28T07:41:00.000Z","updated":"2020-09-28T07:49:53.389Z","comments":true,"path":"2019/03/28/leetcode/419-battleships-in-a-board/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/28/leetcode/419-battleships-in-a-board/","excerpt":"","text":"Link: https://leetcode.com/problems/battleships-in-a-board/ Given an 2D board, count how many battleships are in it. The battleships are represented with ‘X’s, empty slots are represented with ‘.’s. You may assume the following rules: You receive a valid board, made of only battleships or empty slots. Battleships can only be placed horizontally or vertically. In other words, they can only be made of the shape 1xN (1 row, N columns) or Nx1 (N rows, 1 column), where N can be of any size. At least one horizontal or vertical cell separates between two battleships - there are no adjacent battleships. Example: X..X ...X ...X In the above board there are 2 battleships.Invalid Example: ...X XXXX ...X This is an invalid board that you will not receive - as battleships will always have a cell separating between them. Follow up: Could you do it in one-pass, using only O(1) extra memory and without modifying the value of the board? 題目翻譯: 給定 2D 板，計算其中有多少戰列艦。戰列艦用’X’表示，空位用’。’表示。您可以遵守以下規則： 您收到一個有效的板，僅由戰艦或空槽組成。 Battleships 只能水平放置或垂直放置。換句話說，它們只能由 1xN（1 行，N 列）或 Nx1（N 行，1 列）的形狀組成，其中 N 可以是任何大小。 至少有一個水平或垂直的單元格在兩艘戰列艦之間分開 - 沒有相鄰的戰列艦。 程式思路:遇到’X’時檢查它的上方跟左方是不是’X’，如果都不是表示這個點就是船頭。 class Solution { public: int countBattleships(vector&lt;vector&lt;char>>&amp; board) { int result = 0; auto IsExtandofBoard = [&amp;](int x ,int y) { if(0 &lt;= x &amp;&amp; x &lt; board.size() &amp;&amp; 0 &lt;= y &amp;&amp; y &lt; board[0].size() &amp;&amp; board[x][y] == 'X') { return true; } return false; }; for(int i = 0;i &lt; board.size();i++) { for(int j = 0;j &lt; board[0].size();j++) { if(board[i][j] == 'X') { if(!IsExtandofBoard(i,j-1) &amp;&amp; !IsExtandofBoard(i-1,j)) // left &amp; up result++; } } } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"617. Merge Two Binary Trees","slug":"Leetcode/617_Merge Two Binary Trees","date":"2019-03-27T06:00:00.000Z","updated":"2020-09-30T02:03:08.555Z","comments":true,"path":"2019/03/27/leetcode/617-merge-two-binary-trees/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/27/leetcode/617-merge-two-binary-trees/","excerpt":"","text":"Link: https://leetcode.com/problems/delete-columns-to-make-sorted/ Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1: Input: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output: Merged tree: 3 / \\ 4 5 / \\ \\ 5 4 7 Note: The merging process must start from the root nodes of both trees. 題目翻譯: 給出兩個二叉樹並想像當你把其中一個覆蓋另一個時，兩棵樹的一些節點重疊，而其他樹則不重疊。 您需要將它們合併到一個新的二叉樹中。合併規則是，如果兩個節點重疊，則將節點值加起來作為合併節點的新值。否則，NOT null 節點將用作新樹的節點。 程式思路: 用 dfs 來實作此題目，不過為了不破壞原本的 t1,t2,所以我自己用了一個新的樹，如果要解省空間的話就讓 t2 直接加在 t1 上。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* mergeTrees(TreeNode* t1, TreeNode* t2) { if(!t1 &amp;&amp; !t2) return nullptr; //merged_tree = tree1 + tree2 TreeNode* node = new TreeNode((t1 ? t1->val : 0) + (t2 ? t2->val : 0)); node->left = mergeTrees((t1)? t1->left : nullptr, (t2)? t2->left : nullptr); node->right = mergeTrees((t1)? t1->right : nullptr, (t2)? t2->right : nullptr); return node; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"944. Delete Columns to Make Sorted","slug":"Leetcode/944_Delete Columns to Make Sorted","date":"2019-03-27T03:00:00.000Z","updated":"2020-09-28T07:49:29.828Z","comments":true,"path":"2019/03/27/leetcode/944-delete-columns-to-make-sorted/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/27/leetcode/944-delete-columns-to-make-sorted/","excerpt":"","text":"Link: https://leetcode.com/problems/delete-columns-to-make-sorted/ We are given an array A of N lowercase letter strings, all of the same length. Now, we may choose any set of deletion indices, and for each string, we delete all the characters in those indices. For example, if we have an array A = [“abcdef”,”uvwxyz”] and deletion indices {0, 2, 3}, then the final array after deletions is [“bef”, “vyz”], and the remaining columns of A are [“b”,”v”], [“e”,”y”], and [“f”,”z”]. (Formally, the c-th column is [A[0][c], A[1][c], …, A[A.length-1][c]].) Suppose we chose a set of deletion indices D such that after deletions, each remaining column in A is in non-decreasing sorted order. Return the minimum possible value of D.length. Example 1: Input: [\"cba\",\"daf\",\"ghi\"] Output: 1 Explanation: After choosing D = {1}, each column [\"c\",\"d\",\"g\"] and [\"a\",\"f\",\"i\"] are in non-decreasing sorted order. If we chose D = {}, then a column [\"b\",\"a\",\"h\"] would not be in non-decreasing sorted order. Example 2: Input: [\"a\",\"b\"] Output: 0 Explanation: D = {} Example 3: Input: [\"zyx\",\"wvu\",\"tsr\"] Output: 3 Explanation: D = {0, 1, 2} Note: 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 1000 題目翻譯: 我們給出了一個 N 個小寫字母串的數組 A，它們的長度都相同。 現在，我們可以選擇任何一組刪除索引，對於每個字符串，我們刪除這些索引中的所有字符。 例如，如果我們有一個數組 A = [“abcdef”，”uvwxyz”]和刪除索引{0,2,3}，那麼刪除後的最後一個數組是[“bef”，”vyz”]，以及 A 的剩餘列是[“b”，”v”]，[“e”，”y”]和[“f”，”z”]。 （形式上，第 c 列是[A [0][c]，A [1][c]，…，A [A.length-1][c]]。） 假設我們選擇了一個一組刪除索引 D 使得在刪除之後，A 中的每個剩餘列處於非遞減排序順序。 返回 D.length 的最小可能值。 程式思路: 用 dfs 來實作此題目。 class Solution { public: int minDeletionSize(vector&lt;string>&amp; A) { int result = 0; for(int j = 0;j &lt; A[0].length();j++) { for(int i = 0; i &lt; A.size()-1 ;i++) { if(A[i][j] > A[i+1][j]) { result ++; break; } } } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"797. All Paths From Source to Target","slug":"Leetcode/797_All Paths From Source to Target","date":"2019-03-27T02:40:00.000Z","updated":"2020-09-28T07:49:37.997Z","comments":true,"path":"2019/03/27/leetcode/797-all-paths-from-source-to-target/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/27/leetcode/797-all-paths-from-source-to-target/","excerpt":"","text":"Link: https://leetcode.com/problems/all-paths-from-source-to-target/ Given a directed, acyclic graph of N nodes. Find all possible paths from node 0 to node N-1, and return them in any order. The graph is given as follows: the nodes are 0, 1, …, graph.length - 1. graph[i] is a list of all nodes j for which the edge (i, j) exists. Example: Input: [[1,2], [3], [3], []] Output: [[0,1,3],[0,2,3]] Explanation: The graph looks like this: 0--->1 | | v v 2--->3 There are two paths: 0 -> 1 -> 3 and 0 -> 2 -> 3. Note: The number of nodes in the graph will be in the range [2, 15]. You can print different paths in any order, but you should keep the order of nodes inside one path. 題目翻譯: 給定 N 個節點的有向非循環圖。查找從節點 0 到節點 N-1 的所有可能路徑，並以任何順序返回它們。 圖形給出如下：節點是 0,1，…，graph.length - 1. graph [i]是邊緣（i，j）存在的所有節點 j 的列表。 程式思路: 用 dfs 來實作此題目。 class Solution { public: void dfs(int cur,vector&lt;int> &amp;path,vector&lt;vector&lt;int>> &amp;paths,vector&lt;vector&lt;int>>&amp; graph) { path.emplace_back(cur); if (cur == graph.size()-1) { paths.emplace_back(path); }else for(auto next : graph[cur]) { dfs(next,path,paths,graph); } path.pop_back(); } vector&lt;vector&lt;int>> allPathsSourceTarget(vector&lt;vector&lt;int>>&amp; graph) { vector&lt;vector&lt;int>> paths; vector&lt;int> path; dfs(0,path,paths,graph); return paths; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"921. Minimum Add to Make Parentheses Valid","slug":"Leetcode/921_Minimum Add to Make Parentheses Valid","date":"2019-03-27T02:30:00.000Z","updated":"2020-09-28T07:49:21.662Z","comments":true,"path":"2019/03/27/leetcode/921-minimum-add-to-make-parentheses-valid/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/27/leetcode/921-minimum-add-to-make-parentheses-valid/","excerpt":"","text":"Link: https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/ Given a string S of ‘(‘ and ‘)’ parentheses, we add the minimum number of parentheses ( ‘(‘ or ‘)’, and in any positions ) so that the resulting parentheses string is valid. Formally, a parentheses string is valid if and only if: It is the empty string, or It can be written as AB (A concatenated with B), where A and B are valid strings, or It can be written as (A), where A is a valid string. Given a parentheses string, return the minimum number of parentheses we must add to make the resulting string valid. Example 1: Input: \"())\" Output: 1 Example 2: Input: \"(((\" Output: 3 Example 3: Input: \"()\" Output: 0 Example 4: Input: \"()))((\" Output: 4 Note: S.length &lt;= 1000 S only consists of ‘(‘ and ‘)’ characters. 題目翻譯: 給定一個’（’和’）’括號的字符串 S，我們添加最小數量的括號（’（’或’）’，並在任何位置），以便得到的括號字符串有效。 形式上，括號字符串是有效的，當且僅當： 它是空字符串，或者 它可以寫成 AB（與 B 連接），其中 A 和 B 是有效字符串，或 它可以是寫為（A），其中 A 是有效字符串。 給定一個括號字符串，返回我們必須添加的最小括號數，以使結果字符串有效。 程式思路: 蠻簡單的題目，不知道為甚麼分類在中等難度。 class Solution { public: int minAddToMakeValid(string S) { int p = 0,err = 0;; for(auto c : S) { if(c == '(') p++; else if(c == ')') p--; if(p &lt; 0) { err ++; p = 0; } } return p + err ; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"461. Hamming Distance","slug":"Leetcode/461_Hamming Distance","date":"2019-03-26T07:30:00.000Z","updated":"2020-09-28T07:49:51.437Z","comments":true,"path":"2019/03/26/leetcode/461-hamming-distance/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/26/leetcode/461-hamming-distance/","excerpt":"","text":"Link: https://leetcode.com/problems/di-string-match/ The Hamming distance between two integers is the number of positions at which the corresponding bits are different. Given two integers x and y, calculate the Hamming distance. Note:0 ≤ x, y &lt; 2^31. Example: Input: x = 1, y = 4 Output: 2 Explanation: 1 (0 0 0 1) 4 (0 1 0 0) ↑ ↑ The above arrows point to positions where the corresponding bits are different. 題目翻譯: 兩個整數之間的漢明距離是相應位不同的位置數。 給定兩個整數 x 和 y，計算漢明距離。 程式思路: 幾”個”位元不同就是漢名距離。 class Solution { public: int hammingDistance(int x, int y) { int ex = x ^ y; int result = 0; while(ex != 0) { if(ex %2 == 1) { result++; } ex = ex >> 1; } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"942. DI String Match","slug":"Leetcode/942_DI String Match","date":"2019-03-26T07:15:00.000Z","updated":"2020-09-28T07:49:32.216Z","comments":true,"path":"2019/03/26/leetcode/942-di-string-match/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/26/leetcode/942-di-string-match/","excerpt":"","text":"Link: https://leetcode.com/problems/di-string-match/ Given a string S that only contains “I” (increase) or “D” (decrease), let N = S.length. Return any permutation A of [0, 1, …, N] such that for all i = 0, …, N-1: If S[i] == “I”, then A[i] &lt; A[i+1]If S[i] == “D”, then A[i] &gt; A[i+1]Example 1: Input: \"IDID\" Output: [0,4,1,3,2] Example 2: Input: \"III\" Output: [0,1,2,3] Example 3: Input: \"DDI\" Output: [3,2,0,1] Note: 1 &lt;= S.length &lt;= 10000 S only contains characters “I” or “D”. 題目翻譯: 給定僅包含“I”（增加）或“D”（減少）的字符串 S，令 N = S.length。 返回[0,1，…，N]的任何排列 A，使得對於所有 i = 0，…，N-1： 程式思路: 遇到遞增就給他最小值的元素，遇到遞減就給他最大值素，有點類似貪心演算法的感覺。 class Solution { public: vector&lt;int> diStringMatch(string S) { std::vector&lt;int> result; int max = S.length(); int min = 0; for(auto c : S) { if(c == 'I') result.emplace_back(min++); else if(c == 'D') result.emplace_back(max--); } result.emplace_back(max); // min 也可以 return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"814. Binary Tree Pruning","slug":"Leetcode/814_Binary Tree Pruning","date":"2019-03-26T06:30:00.000Z","updated":"2020-09-28T07:49:40.342Z","comments":true,"path":"2019/03/26/leetcode/814-binary-tree-pruning/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/26/leetcode/814-binary-tree-pruning/","excerpt":"","text":"Link: https://leetcode.com/problems/binary-tree-pruning/ We are given the head node root of a binary tree, where additionally every node’s value is either a 0 or a 1. Return the same tree where every subtree (of the given tree) not containing a 1 has been removed. (Recall that the subtree of a node X is X, plus every node that is a descendant of X.) Example 1: Input: [1,null,0,0,1] Output: [1,null,0,null,1] Explanation: Only the red nodes satisfy the property \"every subtree not containing a 1\". The diagram on the right represents the answer. Example 2: Input: [1,0,1,0,0,0,1] Output: [1,null,1,null,1] Example 3: Input: [1,1,0,1,1,0,1,0] Output: [1,1,0,1,1,null,1] Note: The binary tree will have at most 100 nodes. The value of each node will only be 0 or 1. 題目翻譯: 檢查每個節點的左子樹和右子樹有無包含 1 的點，如果沒有就將其節點砍掉。 程式思路: 遞迴基本練習。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* pruneTree(TreeNode* root) { if(root == nullptr) return nullptr; root->left = pruneTree (root->left); root->right = pruneTree (root->right); if(!root->left &amp;&amp; !root->right &amp;&amp; root->val == 0) { delete root; return nullptr; } else return root; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"890. Find and Replace Pattern","slug":"Leetcode/890_Find and Replace Pattern","date":"2019-03-26T06:00:00.000Z","updated":"2020-09-28T07:49:36.271Z","comments":true,"path":"2019/03/26/leetcode/890-find-and-replace-pattern/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/26/leetcode/890-find-and-replace-pattern/","excerpt":"","text":"Link: https://leetcode.com/problems/find-and-replace-pattern/ You have a list of words and a pattern, and you want to know which words in words matches the pattern. A word matches the pattern if there exists a permutation of letters p so that after replacing every letter x in the pattern with p(x), we get the desired word. (Recall that a permutation of letters is a bijection from letters to letters: every letter maps to another letter, and no two letters map to the same letter.) Return a list of the words in words that match the given pattern. You may return the answer in any order. Example 1: Input: words = [\"abc\",\"deq\",\"mee\",\"aqq\",\"dkd\",\"ccc\"], pattern = \"abb\" Output: [\"mee\",\"aqq\"] Explanation: \"mee\" matches the pattern because there is a permutation {a -> m, b -> e, ...}. \"ccc\" does not match the pattern because {a -> c, b -> c, ...} is not a permutation, since a and b map to the same letter. Note: 1 &lt;= words.length &lt;= 50 1 &lt;= pattern.length = words[i].length &lt;= 20 題目翻譯: 你有一個單詞列表和一個模式，你想知道單詞中哪些單詞與模式匹配。 如果存在字母 p 的排列，則字符與模式匹配，以便在用 p（x）替換模式中的每個字母 x 後，我們得到所需的字。 （回想一下，字母的排列是從字母到字母的雙向排列：每個字母都映射到另一個字母，沒有兩個字母映射到同一個字母。）返回與給定模式匹配的單詞列表。 您可以按任何順序返回答案 程式思路: 建構一張 1 對 1 的表，不可多對 1,不可 1 對多。 有點線性函數的概念。用 map 檢查有沒有 1 對多，用 set 檢查有沒有多對 1。 class Solution { public: vector&lt;string> findAndReplacePattern(vector&lt;string>&amp; words, string pattern) { vector &lt;string > result; for(auto word : words) { int i = 0; unordered_map &lt;char, char> table; unordered_set &lt;char> mark; for(i = 0; i&lt; pattern.length(); i++) { auto ret = table.insert(std::pair &lt;char,char> (pattern[i],word[i])); if(ret.second == false) //already exist { if(table[pattern[i]] != word[i]) break; }else { auto ret = mark.insert(word[i]); if(ret.second == false) break; } } if(i == pattern.length()) result.emplace_back(word); } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"657. Robot Return to Origin","slug":"Leetcode/657_Robot Return to Origin","date":"2019-03-26T05:30:00.000Z","updated":"2020-09-28T07:49:49.436Z","comments":true,"path":"2019/03/26/leetcode/657-robot-return-to-origin/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/26/leetcode/657-robot-return-to-origin/","excerpt":"","text":"Link: https://leetcode.com/problems/robot-return-to-origin/ There is a robot starting at position (0, 0), the origin, on a 2D plane. Given a sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves. The move sequence is represented by a string, and the character moves[i] represents its ith move. Valid moves are R (right), L (left), U (up), and D (down). If the robot returns to the origin after it finishes all of its moves, return true. Otherwise, return false. Note: The way that the robot is “facing” is irrelevant. “R” will always make the robot move to the right once, “L” will always make it move left, etc. Also, assume that the magnitude of the robot’s movement is the same for each move. Example 1: Input: \"UD\" Output: true Explanation: The robot moves up once, and then down once. All moves have the same magnitude, so it ended up at the origin where it started. Therefore, we return true. Example 2: Input: \"LL\" Output: false Explanation: The robot moves left twice. It ends up two \"moves\" to the left of the origin. We return false because it is not at the origin at the end of its moves. 題目翻譯: 在 2D 平面上有一個從位置（0,0）開始的機器人。給定其移動序列，判斷該機器人在完成移動後是否在（0,0）處結束。 移動序列由字符串表示，字符 move [i]表示其第 i 個移動。有效移動是 R（右），L（左），U（上）和 D（下）。如果機器人在完成所有移動後返回原點，則返回 true。否則，返回 false。 注意：機器人“面對”的方式無關緊要。 “R”將始終使機器人向右移動一次，“L”將始終向左移動等。此外，假設每次移動機器人的移動幅度相同。 程式思路: 簡單的+1-1 的題目。 class Solution { public: bool judgeCircle(string moves) { int x = 0,y = 0; for(auto c : moves) { switch(c) { case 'R': x++; break; case 'L': x--; break; case 'U': y++; break; case 'D': y--; break; default: break; } } return (x == 0 &amp;&amp; y==0); } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"950. Reveal Cards In Increasing Order","slug":"Leetcode/950_Reveal Cards In Increasing Order","date":"2019-03-26T03:20:00.000Z","updated":"2020-09-28T07:49:24.242Z","comments":true,"path":"2019/03/26/leetcode/950-reveal-cards-in-increasing-order/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/26/leetcode/950-reveal-cards-in-increasing-order/","excerpt":"","text":"Link: https://leetcode.com/problems/reveal-cards-in-increasing-order/ In a deck of cards, every card has a unique integer. You can order the deck in any order you want. Initially, all the cards start face down (unrevealed) in one deck. Now, you do the following steps repeatedly, until all cards are revealed: Take the top card of the deck, reveal it, and take it out of the deck. If there are still cards in the deck, put the next top card of the deck at the bottom of the deck. If there are still unrevealed cards, go back to step 1. Otherwise, stop. Return an ordering of the deck that would reveal the cards in increasing order. The first entry in the answer is considered to be the top of the deck. Example 1: Input: [17,13,11,2,3,5,7] Output: [2,13,3,11,5,17,7] Explanation: We get the deck in the order [17,13,11,2,3,5,7] (this order doesn't matter), and reorder it. After reordering, the deck starts as [2,13,3,11,5,17,7], where 2 is the top of the deck. We reveal 2, and move 13 to the bottom. The deck is now [3,11,5,17,7,13]. We reveal 3, and move 11 to the bottom. The deck is now [5,17,7,13,11]. We reveal 5, and move 17 to the bottom. The deck is now [7,13,11,17]. We reveal 7, and move 13 to the bottom. The deck is now [11,17,13]. We reveal 11, and move 17 to the bottom. The deck is now [13,17]. We reveal 13, and move 17 to the bottom. The deck is now [17]. We reveal 17. Since all the cards revealed are in increasing order, the answer is correct. Note: 1 &lt;= A.length &lt;= 1000 1 &lt;= A[i] &lt;= 10^6 A[i] != A[j] for all i != j 題目翻譯: 在一副牌中，每張牌都有一個唯一的整數。您可以按照任何排序套牌。 最初，所有牌都在一個牌組中面朝下（未揭曉）。 現在，你反复執行以下步驟，直到所有牌都顯示出來： 拿到牌組的頂牌，揭開它，然後把它從牌組中拿出來。 如果牌組中仍有牌，則將牌組的下一張頂牌放在牌組底部。 如果仍有未顯示的卡，請返回步驟 1.否則，停止。 返回甲板的訂單，以便按遞增順序顯示卡片。 答案中的第一個條目被認為是套牌的頂部。 程式思路: 用容器 deque 做會比用 vector 稍微方便點。題目的意思就是說 你的 input 是上述動作所產生出來的”結果”，所以叫你把”原本”的排組個 output 出來，所以我們要把它做過的步驟反著做。而且要記得先把 input 做個遞減排列。 class Solution { public: vector&lt;int> deckRevealedIncreasing(vector&lt;int>&amp; deck) { deque &lt;int> deck_que; //sort deck decreasing sort(deck.begin(),deck.end(),[](int a,int b){return a > b;}); for(auto val : deck) { if(!deck_que.empty()) { deck_que.push_front(deck_que.back()); deck_que.pop_back(); } deck_que.push_front(val); } return vector (deck_que.begin(),deck_que.end()); } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"832. Flipping an Image","slug":"Leetcode/832_Flipping an Image","date":"2019-03-26T03:00:00.000Z","updated":"2020-09-28T07:49:37.061Z","comments":true,"path":"2019/03/26/leetcode/832-flipping-an-image/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/26/leetcode/832-flipping-an-image/","excerpt":"","text":"Link: https://leetcode.com/problems/flipping-an-image/ Given a binary matrix A, we want to flip the image horizontally, then invert it, and return the resulting image. To flip an image horizontally means that each row of the image is reversed. For example, flipping [1, 1, 0] horizontally results in [0, 1, 1]. To invert an image means that each 0 is replaced by 1, and each 1 is replaced by 0. For example, inverting [0, 1, 1] results in [1, 0, 0]. Example 1: Input: [[1,1,0],[1,0,1],[0,0,0]] Output: [[1,0,0],[0,1,0],[1,1,1]] Explanation: First reverse each row: [[0,1,1],[1,0,1],[0,0,0]]. Then, invert the image: [[1,0,0],[0,1,0],[1,1,1]] Example 2: Input: [[1,1,0,0],[1,0,0,1],[0,1,1,1],[1,0,1,0]] Output: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Explanation: First reverse each row: [[0,0,1,1],[1,0,0,1],[1,1,1,0],[0,1,0,1]]. Then invert the image: [[1,1,0,0],[0,1,1,0],[0,0,0,1],[1,0,1,0]] Notes: 1 &lt;= A.length = A[0].length &lt;= 20 0 &lt;= A[i][j] &lt;= 1 題目翻譯: 給定二進制矩陣 A，我們想要水平翻轉圖像，然後反轉它，並返回結果圖像。 水平翻轉圖像意味著圖像的每一行都是相反的。例如，水平翻轉[1,1,0]會產生[0,1,1]。 反轉圖像意味著每個 0 替換為 1，每個 1 替換為 0.例如，反轉[0,1,1]會產生[1,0,0]。 程式思路: 很基本二維陣列(圖像處理)題目，邊 reverse 邊 invert。 class Solution { public: vector&lt;vector&lt;int>> flipAndInvertImage(vector&lt;vector&lt;int>>&amp; A) { const int row = A.size(); const int col = A[0].size(); for(int i = 0; i &lt; row ; i++) { int fpos = 0; int lpos = col - 1; while(fpos &lt; lpos) { //invert A[i][fpos] = (A[i][fpos] == 0)? 1 : 0; A[i][lpos] = (A[i][lpos] == 0)? 1 : 0; //reverse swap(A[i][fpos++],A[i][lpos--]); } if(fpos == lpos) A[i][fpos] = (A[i][fpos] == 0)? 1 : 0; } return A; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"905. Sort Array By Parity","slug":"Leetcode/905_Sort Array By Parity","date":"2019-03-26T02:50:00.000Z","updated":"2020-09-28T07:49:35.083Z","comments":true,"path":"2019/03/26/leetcode/905-sort-array-by-parity/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/26/leetcode/905-sort-array-by-parity/","excerpt":"","text":"Link: https://leetcode.com/problems/sort-array-by-parity/ Given an array A of non-negative integers, return an array consisting of all the even elements of A, followed by all the odd elements of A. You may return any answer array that satisfies this condition. Example 1: Input: [3,1,2,4] Output: [2,4,3,1] The outputs [4,2,3,1], [2,4,1,3], and [4,2,1,3] would also be accepted. Note: 1 &lt;= A.length &lt;= 5000 0 &lt;= A[i] &lt;= 5000 題目翻譯: 給定一個非負整數數組 A，返回一個由 A 的所有偶數元素組成的數組，後跟 A 的所有奇數元素。 您可以返回滿足此條件的任何答案數組。 程式思路: 用雙指標一個跑前面一個跑後面。前指標偵測到奇數，後指標偵測偶數，兩兩交換數值，直到前指標越過後指標，停止偵測交換。 class Solution { public: vector&lt;int> sortArrayByParity(vector&lt;int>&amp; A) { int fpos = 0,lpos = A.size()-1; while(fpos &lt; lpos){ //cout &lt;&lt; A[fpos] &lt;&lt; \",\" &lt;&lt; A[lpos] &lt;&lt; endl; if(A[fpos]%2 == 1 &amp;&amp; A[lpos]%2 == 0) { swap(A[fpos++],A[lpos--]); } if(A[fpos] %2 == 0) //even fpos ++; if(A[lpos] %2 == 1) // odd lpos --; } return A; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"980. Unique Paths III","slug":"Leetcode/980_Unique Paths III","date":"2019-03-25T08:00:00.000Z","updated":"2020-09-28T07:49:17.646Z","comments":true,"path":"2019/03/25/leetcode/980-unique-paths-iii/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/25/leetcode/980-unique-paths-iii/","excerpt":"","text":"Link: https://leetcode.com/problems/squares-of-a-sorted-array/ On a 2-dimensional grid, there are 4 types of squares: 1 represents the starting square. There is exactly one starting square. 2 represents the ending square. There is exactly one ending square. 0 represents empty squares we can walk over. -1 represents obstacles that we cannot walk over. Return the number of 4-directional walks from the starting square to the ending square, that walk over every non-obstacle square exactly once. Example 1: Input: [[1,0,0,0],[0,0,0,0],[0,0,2,-1]] Output: 2 Explanation: We have the following two paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2) 2. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2) Example 2: Input: [[1,0,0,0],[0,0,0,0],[0,0,0,2]] Output: 4 Explanation: We have the following four paths: 1. (0,0),(0,1),(0,2),(0,3),(1,3),(1,2),(1,1),(1,0),(2,0),(2,1),(2,2),(2,3) 2. (0,0),(0,1),(1,1),(1,0),(2,0),(2,1),(2,2),(1,2),(0,2),(0,3),(1,3),(2,3) 3. (0,0),(1,0),(2,0),(2,1),(2,2),(1,2),(1,1),(0,1),(0,2),(0,3),(1,3),(2,3) 4. (0,0),(1,0),(2,0),(2,1),(1,1),(0,1),(0,2),(0,3),(1,3),(1,2),(2,2),(2,3) Example 3: Input: [[0,1],[2,0]] Output: 0 Explanation: There is no path that walks over every empty square exactly once. Note that the starting and ending square can be anywhere in the grid. Note: 1 &lt;= grid.length * grid[0].length &lt;= 20 題目翻譯: 在二維網格上，有四種類型的正方形： 1 表示起始正方形。只有一個起始廣場。 2 表示結束方塊。只有一個結束方塊。 0 表示我們可以走過的空方塊。 -1 表示我們無法走過的障礙。 返回從起始正方形到結束正方形的四向行走的數量，它在每個非障礙物正方形上行走一次。 程式思路: 到達 2 時 檢查路徑是否還有 0。 先往右，往下，往左，往上，使用遞迴，不算太難，但程式碼稍長。 class Solution { public: bool IsAllPassed(vector&lt;vector&lt;int>> grid) { for (int i = 0; i &lt; grid.size(); i++) { for (int j = 0; j &lt; grid[i].size(); j++) { if (grid[i][j] == 0) return false; } } return true; } bool IsValid(int x, int y, int x_max, int y_max) { if (x >= 0 &amp;&amp; x &lt; x_max &amp;&amp; y >= 0 &amp;&amp; y &lt; y_max) { return true; } return false; } void DFS(int &amp;paths_num, vector&lt;vector&lt;int>> grid, int x, int y) { const int steps[4][2] = { {1,0},{0,1},{-1,0},{0,-1} }; grid[x][y] = -1; for (int i = 0; i &lt; 4; i++) { int next_x = x + steps[i][0]; int next_y = y + steps[i][1]; if (IsValid(next_x, next_y, grid.size(), grid[0].size())) { //printf(\" (%d %d) -> (%d %d) = %d\\n\", x, y, next_x, next_y, grid[next_x][next_y]); if (grid[next_x][next_y] == -1) { //continue; } else if (grid[next_x][next_y] == 0) { DFS(paths_num, grid, next_x, next_y); } else if (grid[next_x][next_y] == 2) { if (IsAllPassed(grid)) paths_num++; } } } } int uniquePathsIII(vector&lt;vector&lt;int>>&amp; grid) { int start_x = 0; int start_y = 0; int paths_num = 0; //find start point for (int i = 0; i &lt; grid.size(); i++) { for (int j = 0; j &lt; grid[i].size(); j++) { if (grid[i][j] == 1) { start_x = i; start_y = j; break; } } } DFS(paths_num, grid, start_x, start_y); return paths_num; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Hard","slug":"Hard","permalink":"https://tsaiyuyan.github.io/tags/Hard/"}]},{"title":"977. Squares of a Sorted Array","slug":"Leetcode/977_Squares of a Sorted Array","date":"2019-03-25T07:00:00.000Z","updated":"2020-09-28T07:49:13.544Z","comments":true,"path":"2019/03/25/leetcode/977-squares-of-a-sorted-array/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/25/leetcode/977-squares-of-a-sorted-array/","excerpt":"","text":"Link: https://leetcode.com/problems/squares-of-a-sorted-array/ RGiven an array of integers A sorted in non-decreasing order, return an array of the squares of each number, also in sorted non-decreasing order. Example 1: Input: [-4,-1,0,3,10] Output: [0,1,9,16,100] Example 2: Input: [-7,-3,2,3,11] Output: [4,9,9,49,121] Note: 1","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"1008. Construct Binary Search Tree from Preorder Traversal","slug":"Leetcode/1008_Construct Binary Search Tree from Preorder Traversal","date":"2019-03-25T06:20:00.000Z","updated":"2020-09-28T07:49:58.972Z","comments":true,"path":"2019/03/25/leetcode/1008-construct-binary-search-tree-from-preorder-traversal/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/25/leetcode/1008-construct-binary-search-tree-from-preorder-traversal/","excerpt":"","text":"Link: https://leetcode.com/problems/construct-binary-search-tree-from-preorder-traversal/ Return the root node of a binary search tree that matches the given preorder traversal. (Recall that a binary search tree is a binary tree where for every node, any descendant of node.left has a value &lt; node.val, and any descendant of node.right has a value &gt; node.val. Also recall that a preorder traversal displays the value of the node first, then traverses node.left, then traverses node.right.) Example 1: Input: [8,5,1,7,10,12] Output: [8,5,10,1,7,null,12] Note: 1 &lt;= preorder.length &lt;= 100 The values of preorder are distinct. 題目翻譯: 返回與給定的前序遍歷匹配的二叉搜索樹的根節點。 （回想一下二進制搜索樹是一個二叉樹，對於每個節點，node.left 的任何後代都有一個值 node.val。還記得那個 preorder 遍歷首先顯示節點的值，然後遍歷 node.left，然後遍歷 node.right。） 程式思路:這題是用印出來的 preoder 去逆推原本樹的樣子。node 先，再來 left 再來 right，其實就只是把元素按照大小做簡單的插入分類就能解題了。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: void tree_insert(TreeNode **node,int val) { if(*node == nullptr ) { *node = new TreeNode(val); return; } TreeNode *pre,*cur = *node; while(cur) { pre = cur; cur = (val &lt; cur->val) ? cur->left : cur->right; } if(val > pre->val ) pre->right = new TreeNode(val); else if(val &lt; pre->val ) pre->left = new TreeNode(val); } TreeNode* bstFromPreorder(vector&lt;int>&amp; preorder) { TreeNode *root = nullptr; for(auto val : preorder) { tree_insert(&amp;root,val); } return root; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"961. N-Repeated Element in Size 2N Array","slug":"Leetcode/961_N-Repeated Element in Size 2N Array","date":"2019-03-25T06:10:00.000Z","updated":"2020-09-28T07:49:11.900Z","comments":true,"path":"2019/03/25/leetcode/961-n-repeated-element-in-size-2n-array/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/25/leetcode/961-n-repeated-element-in-size-2n-array/","excerpt":"","text":"Link: https://leetcode.com/problems/big-countries/ In a array A of size 2N, there are N+1 unique elements, and exactly one of these elements is repeated N times. Return the element repeated N times. Example 1: Input: [1,2,3,3] Output: 3 Example 2: Input: [2,1,2,5,3,2] Output: 2 Example 3: Input: [5,1,5,2,5,3,5,4] Output: 5 Note: 4 &lt;= A.length &lt;= 10000 0 &lt;= A[i] &lt; 10000 A.length is even 題目翻譯: 在大小為 2N 的陣列 A 中，存在 N + 1 個唯一元素，並且這些元素中的一個重複 N 次。 返回元素重複 N 次。 程式思路: 雖然題目有限制元素的大小，就可以使用 hash table 來做這題，但覺得還是寫成動態會比較好些，就使用 unordered_map 容器來寫。 class Solution { public: int repeatedNTimes(vector&lt;int>&amp; A) { unordered_map &lt;int,int> NTimes_map; int output = 0; for(auto element : A) { auto ret = NTimes_map.insert ( std::pair&lt;char,int>(element,0) ); if (ret.second == false) { // std::cout &lt;&lt; \"element already existed\"; //NTimes_map[element]++; output = element; break; } } return output; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"595. Big Countries","slug":"Leetcode/595_Big Countries","date":"2019-03-25T06:00:00.000Z","updated":"2020-09-21T03:52:27.850Z","comments":true,"path":"2019/03/25/leetcode/595-big-countries/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/25/leetcode/595-big-countries/","excerpt":"","text":"Link: https://leetcode.com/problems/big-countries/ There is a table World +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | Afghanistan | Asia | 652230 | 25500100 | 20343000 | | Albania | Europe | 28748 | 2831741 | 12960000 | | Algeria | Africa | 2381741 | 37100000 | 188681000 | | Andorra | Europe | 468 | 78115 | 3712000 | | Angola | Africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ A country is big if it has an area of bigger than 3 million square km or a population of more than 25 million. Write a SQL solution to output big countries’ name, population and area. For example, according to the above table, we should output: +--------------+-------------+--------------+ | name | population | area | +--------------+-------------+--------------+ | Afghanistan | 25500100 | 652230 | | Algeria | 37100000 | 2381741 | +--------------+-------------+--------------+ 題目翻譯: 這裡有一張表 World +-----------------+------------+------------+--------------+---------------+ | name | continent | area | population | gdp | +-----------------+------------+------------+--------------+---------------+ | Afghanistan | Asia | 652230 | 25500100 | 20343000 | | Albania | Europe | 28748 | 2831741 | 12960000 | | Algeria | Africa | 2381741 | 37100000 | 188681000 | | Andorra | Europe | 468 | 78115 | 3712000 | | Angola | Africa | 1246700 | 20609294 | 100990000 | +-----------------+------------+------------+--------------+---------------+ 如果一個國家面積超過 300 萬平方公里或人口超過 2500 萬，那麼這個國家就很大。 寫一個 SQL 解決方案來輸出大國的名字，人口和麵積。 例如，根據上表，我們應該輸出： +--------------+-------------+--------------+ | name | population | area | +--------------+-------------+--------------+ | Afghanistan | 25500100 | 652230 | | Algeria | 37100000 | 2381741 | +--------------+-------------+--------------+ 程式思路: 簡單的 SQL 語法複習沒啥難度。 select name,population,area from World where (area > 3000000 ) or (population > 25000000)","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"},{"name":"MySQL","slug":"MySQL","permalink":"https://tsaiyuyan.github.io/tags/MySQL/"}]},{"title":"804. Unique Morse Code Words","slug":"Leetcode/804_Unique Morse Code Words","date":"2019-03-25T05:20:00.000Z","updated":"2020-09-28T07:49:44.123Z","comments":true,"path":"2019/03/25/leetcode/804-unique-morse-code-words/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/25/leetcode/804-unique-morse-code-words/","excerpt":"","text":"Link: https://leetcode.com/problems/unique-morse-code-words/ International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cba” can be written as “-.-..–…”, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example: Input: words = [\"gin\", \"zen\", \"gig\", \"msg\"] Output: 2 Explanation: The transformation of each word is: \"gin\" -> \"--...-.\" \"zen\" -> \"--...-.\" \"gig\" -> \"--...--.\" \"msg\" -> \"--...--.\" There are 2 different transformations, “–…-.” and “–…–.”.Note: The length of words will be at most 100. Each words[i] will have length in range [1, 12]. words[i] will only consist of lowercase letters. 題目翻譯: 國際莫爾斯電碼定義了一種標準編碼，其中每個字母映射到一系列點和短劃線，如下所示：“a”映射到“.-”，“b”映射到“-…”，“c”映射到“-。-。“， 等等。 為方便起見，下面給出了 26 個英文字母的完整表格： [\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"] 現在，給定一個單詞列表，每個單詞可以寫成串聯每個字母的摩爾斯電碼。例如，“cba”可以寫成”-.-..–…”，（這是串聯”-.-.” + “-…” + “.-“）。我們稱之為串聯，即一個詞的轉換。 返回我們所有單詞中不同變換的數量。 程式思路: 利用 set 容器的特性，輕鬆就能做出此題 class Solution { public: int uniqueMorseRepresentations(vector&lt;string>&amp; words) { set &lt;string> transformations; vector &lt;string >Morse_table = {\".-\",\"-...\",\"-.-.\",\"-..\",\".\",\"..-.\",\"--.\",\"....\",\"..\",\".---\",\"-.-\",\".-..\",\"--\",\"-.\",\"---\",\".--.\",\"--.-\",\".-.\",\"...\",\"-\",\"..-\",\"...-\",\".--\",\"-..-\",\"-.--\",\"--..\"}; for(auto word : words) { string tmp; for (int i = 0; i &lt; word.length();i++) { auto offset = (word[i] - 'a'); if(offset &lt; Morse_table.size()) tmp += Morse_table[offset]; else break; //invalid char; } transformations.insert(tmp); } return transformations.size(); } }","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"701. Insert into a Binary Search Tree","slug":"Leetcode/701_Insert into a Binary Search Tree","date":"2019-03-25T03:03:00.000Z","updated":"2020-09-28T07:49:50.489Z","comments":true,"path":"2019/03/25/leetcode/701-insert-into-a-binary-search-tree/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/25/leetcode/701-insert-into-a-binary-search-tree/","excerpt":"","text":"Link: https://leetcode.com/problems/insert-into-a-binary-search-tree/ Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST. Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them. For example, Given the tree: 4 / \\ 2 7 / \\ 1 3 And the value to insert: 5You can return this binary search tree: 4 / \\ 2 7 / \\ / 1 3 5 This tree is also valid: 5 / \\ 2 7 / \\ 1 3 \\ 4 題目翻譯: 給定二叉搜索樹（BST）的根節點和要插入樹的值，將值插入 BST。插入後返回 BST 的根節點。保證原始 BST 中不存在新值。 請注意，只要樹在插入後仍為 BST，就可能存在多種有效的插入方式。你可以退回任何一個。 程式思路: 簡單的二元素搜索，插入值比較大就往右子樹，比較小就往左子樹，一樣的話就表示樹已有此值直接退出，沒的話就繼續直到，找到空指標時就做插入的動作。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* insertIntoBST(TreeNode* root, int val) { if(root == nullptr) { root = new TreeNode(val); return root; } TreeNode* node = root; while(node) { if(node->val &lt; val) { if(node->right == nullptr) { node->right= new TreeNode(val); break; }else node = node->right; } else if(node->val > val) { if(node->left == nullptr) { node->left= new TreeNode(val); break; }else node = node->left; } else break; } return root; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"929. Unique Email Addresses","slug":"Leetcode/929_Unique Email Addresses","date":"2019-03-25T02:03:00.000Z","updated":"2020-09-28T07:49:19.844Z","comments":true,"path":"2019/03/25/leetcode/929-unique-email-addresses/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/25/leetcode/929-unique-email-addresses/","excerpt":"","text":"Link: https://leetcode.com/problems/unique-email-addresses/ Every email consists of a local name and a domain name, separated by the @ sign. For example, in alice@leetcode.com, alice is the local name, and leetcode.com is the domain name. Besides lowercase letters, these emails may contain ‘.’s or ‘+’s. If you add periods (‘.’) between some characters in the local name part of an email address, mail sent there will be forwarded to the same address without dots in the local name. For example, “alice.z@leetcode.com“ and “alicez@leetcode.com“ forward to the same email address. (Note that this rule does not apply for domain names.) If you add a plus (‘+’) in the local name, everything after the first plus sign will be ignored. This allows certain emails to be filtered, for example m.y+name@email.com will be forwarded to my@email.com. (Again, this rule does not apply for domain names.) It is possible to use both of these rules at the same time. Given a list of emails, we send one email to each address in the list. How many different addresses actually receive mails? Example 1: Input: [\"test.email+alex@leetcode.com\",\"test.e.mail+bob.cathy@leetcode.com\",\"testemail+david@lee.tcode.com\"] Output: 2 Explanation: \"testemail@leetcode.com\" and \"testemail@lee.tcode.com\" actually receive mails Note: 1 &lt;= emails[i].length &lt;= 100 1 &lt;= emails.length &lt;= 100 Each emails[i] contains exactly one ‘@’ character. 題目翻譯: 每封電子郵件都包含本地名稱和域名，以@符號分隔。 例如，在 alice@leetcode.com 中，alice 是本地名稱，leetcode.com 是域名。 除了小寫字母，這些電子郵件可能包含’。’或’+’。 如果在電子郵件地址的本地名稱部分中的某些字符之間添加句點（’.’），則在那裡發送的郵件將被轉發到本地名稱中沒有點的同一地址。例如，“alice.z@leetcode.com”和“alicez@leetcode.com”轉發到同一個電子郵件地址。 （請注意，此規則不適用於域名。） 如果在本地名稱中添加加號（’+’），則會忽略第一個加號後面的所有內容。這允許過濾某些電子郵件，例如 m.y+nameemail.com 將轉發到 my@email.com。 （同樣，此規則不適用於域名。） 可以同時使用這兩個規則。 鑑於電子郵件列表，我們會向列表中的每個地址發送一封電子郵件。有多少不同的地址實際接收郵件？ 程式思路: 準備一個 set 的容器，每條 email 處理時，在遇到‘@’or’+’ 符號前，先判斷 account 的 id 並忽略’.’遇到’+’開始忽略直到遇到‘@’，一遇到‘@’ 直接複製至後段。 class Solution { public: int numUniqueEmails(vector&lt;string>&amp; emails) { set&lt;string> email_set; for(auto email : emails) { string tmp; bool ignore = false; for(int i = 0; i &lt; email.length(); i++) { if(email[i] == '@') { tmp+=email.substr(i,email.length()-i); break; } else if(email[i] == '+') { ignore = true; }else if( !ignore &amp;&amp; email[i] != '.') { tmp += email[i]; } } email_set.insert(tmp); } return email_set.size(); } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"654. Maximum Binary Tree","slug":"Leetcode/654_Maximum Binary Tree","date":"2019-03-22T08:03:00.000Z","updated":"2020-09-30T02:03:39.458Z","comments":true,"path":"2019/03/22/leetcode/654-maximum-binary-tree/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/22/leetcode/654-maximum-binary-tree/","excerpt":"","text":"Link: https://leetcode.com/problems/maximum-binary-tree/ Given an integer array with no duplicates. A maximum tree building on this array is defined as follow: The root is the maximum number in the array. The left subtree is the maximum tree constructed from left part subarray divided by the maximum number. The right subtree is the maximum tree constructed from right part subarray divided by the maximum number. Construct the maximum tree by the given array and output the root node of this tree. Example 1: Input: [3,2,1,6,0,5] Output: return the tree root node representing the following tree: 6 / \\ 3 5 \\ / 2 0 \\ 1 Note: The size of the given array will be in the range [1,1000]. 題目翻譯: 給定一個沒有重複的整數數組。此陣列上的最大樹構建定義如下： root 是數組中的最大數字。 左子樹是從左側子陣列構造的最大樹數除以最大數量。 右子樹是從右部分子陣列構造的最大樹數除以最大數量。 按給定數組構造最大樹，並輸出該樹的根節點。 程式思路:準備一個 stack 容器，每一個新元素加入時檢查 stack 最上面的元素是否大於新元素，如果不是的話將其元素 pop 出來為 child。也就是新元素的左子樹會得到容器內的最大的元素(如果新元素值夠大的話)。 /** * Definition for a binary tree node. * struct TreeNode { * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) {} * }; */ class Solution { public: TreeNode* constructMaximumBinaryTree(vector&lt;int>&amp; nums) { stack&lt;TreeNode *> s; const auto up = [&amp;](int x) { TreeNode *child = nullptr; while(!s.empty() &amp;&amp; (s.top()->val &lt;= x)) { s.top()->right = child; child = s.top(); s.pop(); } return child; }; for(const auto x :nums) { const auto node = new TreeNode(x); node->left = up(x); s.push(node); } return up(numeric_limits&lt;int>::max()); } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"807. Max Increase to Keep City Skyline","slug":"Leetcode/807_Max Increase to Keep City Skyline","date":"2019-03-21T07:03:00.000Z","updated":"2020-09-28T07:49:41.869Z","comments":true,"path":"2019/03/21/leetcode/807-max-increase-to-keep-city-skyline/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/21/leetcode/807-max-increase-to-keep-city-skyline/","excerpt":"","text":"Link: https://leetcode.com/problems/max-increase-to-keep-city-skyline/ In a 2 dimensional array grid, each value grid[i][j] represents the height of a building located there. We are allowed to increase the height of any number of buildings, by any amount (the amounts can be different for different buildings). Height 0 is considered to be a building as well. At the end, the “skyline” when viewed from all four directions of the grid, i.e. top, bottom, left, and right, must be the same as the skyline of the original grid. A city’s skyline is the outer contour of the rectangles formed by all the buildings when viewed from a distance. See the following example. What is the maximum total sum that the height of the buildings can be increased? Example: Input: grid = [[3,0,8,4],[2,4,5,7],[9,2,6,3],[0,3,1,0]] Output: 35 Explanation: The grid is: [ [3, 0, 8, 4], [2, 4, 5, 7], [9, 2, 6, 3], [0, 3, 1, 0] ] The skyline viewed from top or bottom is: [9, 4, 8, 7] The skyline viewed from left or right is: [8, 7, 9, 3] The grid after increasing the height of buildings without affecting skylines is: gridNew = [ [8, 4, 8, 7], [7, 4, 7, 7], [9, 4, 8, 7], [3, 3, 3, 3] ] Notes: 1 &lt; grid.length = grid[0].length &lt;= 50. All heights grid[i][j] are in the range [0, 100]. All buildings in grid[i][j] occupy the entire grid cell: that is, they are a 1 x 1 x grid[i][j] rectangular prism. 題目翻譯: 在二維陣列網格中，每個值 grid [i][j]表示位於那裡的建築物的高度。我們被允許以任何數量增加任何數量的建築物的高度（不同建築物的數量可以不同）。高度 0 也被認為是建築物。 最後，當從網格的所有四個方向（即頂部，底部，左側和右側）觀察時，“天際線”必須與原始網格的天際線相同。城市的天際線是從遠處觀看時由所有建築物形成的矩形的外部輪廓。請參閱以下示例。 建築物高度可以增加的最大總和是多少？ 程式思路:簡單講就是掃橫的掃直的取最大數存成兩個陣列，之後兩陣列的最大數再取較小數的那個就是答案了。例如範例(0,0) 橫排最大值是 8 直排最大值是 9，所以能蓋的高度就是 min(8,9) = 8 了 後面以此類推。 class Solution { public: int maxIncreaseKeepingSkyline(vector&lt;vector&lt;int>>&amp; grid) { vector &lt;int> row_max_array; vector &lt;int> col_max_array; for(auto i = 0;i &lt; grid.size();i++) { int max = 0; for(auto j = 0; j&lt; grid[0].size();j++) { if(i == 0) //Init { col_max_array.emplace_back(grid[0][j]); }else { if(grid[i][j] > col_max_array[j] ) col_max_array[j] = grid[i][j]; } if(grid[i][j] > max ) max = grid[i][j]; } row_max_array.emplace_back(max); } int result = 0; for(auto i = 0;i &lt; grid.size();i++) { for(auto j = 0; j&lt; grid[0].size();j++) { result += min(col_max_array[j],row_max_array[i]) - grid[i][j]; } } return result; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Medium","slug":"Medium","permalink":"https://tsaiyuyan.github.io/tags/Medium/"}]},{"title":"VS Code (Visual Studio Code) 編輯工具-快捷鍵","slug":"Windows/VS Code (Visual Studio Code) 編輯工具-快捷鍵","date":"2019-03-21T04:00:00.000Z","updated":"2020-06-19T07:24:37.718Z","comments":true,"path":"2019/03/21/windows/vs-code-visual-studio-code-bian-ji-gong-ju-kuai-jie-jian/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/21/windows/vs-code-visual-studio-code-bian-ji-gong-ju-kuai-jie-jian/","excerpt":"","text":"顯示最近打開過的檔案Ctrl + e 顯示終端機Ctrl + ` 整個區塊註解Ctrl + / 新增編輯器Ctrl + \\ 找某個檔案裡面的字串Ctrl + F 找檔案群裡的字串，就像是 grep -r XXX *Ctrl + SHIFT + F 取代Ctrl + H 到某行Ctrl + G ，再 :123 或 Ctrl + P 再 : 123 打開最近開啟的文件Ctrl + P 縮排ALT + Z Ctrl + [ 或 Ctrl + ] 刪除目前行CTRL + X 直接複製此行Ctrl + C 且 Ctrl + V 文字放大縮小Ctrl + 或 Ctrl - 左側邊顯示隱藏Ctrl + B 編輯器的選擇，也就是說 Ctrl + \\ 後是多一個編輯器，而不是選擇一個文件Ctrl + 1 或 2 或 3 到最後一行Ctrl + End","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[{"name":"vscode","slug":"vscode","permalink":"https://tsaiyuyan.github.io/tags/vscode/"}]},{"title":"412. Fizz Buzz","slug":"Leetcode/412_Fizz Buzz","date":"2019-03-21T03:47:00.000Z","updated":"2020-09-28T07:48:37.835Z","comments":true,"path":"2019/03/21/leetcode/412-fizz-buzz/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/21/leetcode/412-fizz-buzz/","excerpt":"","text":"Link: https://leetcode.com/problems/fizz-buzz/ Write a program that outputs the string representation of numbers from 1 to n. But for multiples of three it should output “Fizz” instead of the number and for the multiples of five output “Buzz”. For numbers which are multiples of both three and five output “FizzBuzz”. Example: n = 15, Return: [ \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\" ] 題目翻譯: 編寫一個程序，輸出從 1 到 n 的數字的字符串表示。 但是對於三的倍數，它應該輸出“Fizz”而不是數字和五個輸出“Buzz”的倍數。對於三個和五個輸出“FizzBu​​zz”的倍數的數字。 程式思路: 很 easy 的題目，但不知道為啥遞交率才 59%。 class Solution { public: vector&lt;string> fizzBuzz(int n) { vector&lt;string> res; for(int i = 1;i &lt;= n;i++) { string foo; if(i%3 == 0) { foo += \"Fizz\"; } if(i%5 == 0) { foo += \"Buzz\"; } if(foo.length()==0) { foo += std::to_string(i); } res.push_back(foo); } return res; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"709. To Lower Case","slug":"Leetcode/709_To Lower Case","date":"2019-03-21T03:43:00.000Z","updated":"2020-09-28T07:49:42.975Z","comments":true,"path":"2019/03/21/leetcode/709-to-lower-case/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/21/leetcode/709-to-lower-case/","excerpt":"","text":"Link: https://leetcode.com/problems/to-lower-case/ Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. Example 1: Input: \"Hello\" Output: \"hello\" Example 2: Input: \"here\" Output: \"here\" Example 3: Input: \"LOVELY\" Output: \"lovely\" 題目翻譯:做一個大寫轉小寫 ToLowerCase()的 function 程式思路:看要用 STD 提供的 function 或是自己寫一個都能輕鬆解題。 class Solution { public: string toLowerCase(string str) { /* // c int offset = 'A' - 'a'; for(int i =0; i &lt; str.length() ; i++) { if(str[i] >='A' &amp;&amp; str[i] &lt;= 'Z') { str[i] -= offset; } } */ // or c++ std::transform std::transform(str.begin(), str.end(), str.begin(), ::tolower); /* // or c++ std::for_each for_each(str.begin(), str.end(), [](char &amp;x){x = tolower(x);}); */ return str; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"Photoshop 使用筆記","slug":"Photoshop 使用筆記","date":"2019-03-21T03:41:00.000Z","updated":"2020-05-11T07:35:19.119Z","comments":true,"path":"2019/03/21/photoshop-shi-yong-bi-ji/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/21/photoshop-shi-yong-bi-ji/","excerpt":"","text":"Photoshop 有許多指令不用滑鼠點選，透過鍵盤使用快捷鍵，將可省下不少時間。快 捷鍵不必刻意將它背下，只要指令常用，稍去了解一下它的快捷鍵，將可用得得心 應手。 引用自：http://www.iamcooky.com/blog/article.asp?id=74 以下是較常使用的快捷鍵： Ctrl+A 全選（All） Ctrl+L 色階(Level) Ctrl+C 複製（Copy） Ctrl+Z 復原 Ctrl+P 貼上（Paste） Ctrl+＋ 放大檢視 Ctrl+I 負面效果（Invert） Ctrl+－ 縮小檢視 Ctrl+Shift+I 反選（Inverse） Ctrl+０ 顯示全頁 Ctrl+D 取消選取 Alt+Backspace(或 Delete) 填入前景色 Ctrl+Backspace(或 Delete) 填入背景色 Ctrl+H 隱藏(顯示)選取 Ctrl+‵ 跳回 RGB Ctrl+點選圖層 載入選框 空白鍵 切換手形工具 ★ 快捷鍵大全 ★ 雙擊面板=Open file ctrl+雙擊面板=New file shift+雙擊面板=Save alt+雙擊面板=Open as ctrl+shift+=Save as ctrl+alt+o=實際圖元顯示 ctrl+h=隱藏選定區域 ctrl+d=取消選定區域 ctrl+w=關閉文件 ctrl+q=退出 photoshop ▲ f=標準顯示模式 → 帶功能表的全屏顯示模式 → 全屏顯示模式 按 Tab 鍵可以顯示或隱藏工具箱和調色板，按“Shift+Tab”鍵可以顯示或隱藏除工具箱外的其他調色板。 esc=取消操作 可以通過按鍵盤上的某一字母鍵來快速選擇某一工具，各個工具的字母快捷鍵如下： Mar-quee-M, Lasso-l, Airbrush-a, Eraser-E, Rubber Stamp-S, Focus-R, Path-P, Line-N, Paint Bucket-K, Hand-H, Move-V, Magic Wand-W, Paintbrush-B, Pencil-Y, Smudge-U, Toning-O, Type-T, Gradient-G, Eyedropper-I, Zoom-Z, Default Colors-D, Switch Colors-X, Standard Mode-Q, Quick Mask Mode-Q, Shift、Ctr、Alt 連鍵：使用其他工具時，按住 Ctrl 鍵可切換到 Move 工具的功能（除了選擇 Hand 工具時）；按住空白鍵可切換到 Hand 工具的功能。 使用其他工具時，按“Ctrl+空白鍵”可切換到 Zoom In 工具放大圖像顯示比例：按“Alt+Ctrl+空白鍵”可切換到 Zoom Out 工具縮小圖像顯示比例。 按“Ctrl+[+]”鍵可使圖像檔持續放大顯示比例，但視窗不隨之放大；按“Ctrl+[-]”鍵可使圖像檔持續縮小顯示比例，但視窗不隨之縮小。 按“Ctrl+Alt+[+]”鍵可使圖像檔持續放大顯示比例，且視窗隨之放大；按“Ctrl+Alt+[-]”鍵可使圖像檔持續縮小顯示比例，且視窗隨之縮小。 在 Hand 工具上雙擊滑鼠可以使圖像匹配視窗的大小顯示。 按“Ctrl+Alt+[數位鍵 0]”或在 Zoom 工具上雙擊滑鼠可使圖像檔以 1：1 比例顯示。 按“Shift+Backspace”鍵可直接調用 Fill（填充）對話方塊。 按“Alt+Backspace(delete)”鍵可將前景色填入選取框，按“Ctrl+Backspace(delete)”鍵可將背景色填入選取框內 在 Layers、Channels、Paths 調色板上，按 Alt 單擊這些調色板底部的工具圖示時，對於有對話方塊的工具可調出相應的對話方塊來更改設置。 移動圖層和選取框時，按住 Shift 鍵可做水準、垂直或 45 度角的移動，按鍵盤上的方向鍵可做每次 lpixel 的移動，按住 Shift 鍵再按鍵盤上的方向鍵可做每次 10pixel 的移動。 在使用選取工具時，按 Shift 鍵拖動滑鼠可以在原選取框外增加選取範圍（開集）；按 Alt 鍵拖動滑鼠可以刪除與原選取框重疊部分的選取範圍；同時按 Shift 與 Alt 鍵拖動滑鼠可以選取與原選取框重疊的範圍（交集）。 調用 Curves 對話方塊時，按住 Alt 鍵於格線內單擊滑鼠可以增加格線，提高曲線精度。 更改某一對話方塊的設置後，若要恢復為預設值，只要按住 Alt 鍵，Cancel 鍵會變成 Reset 鍵，在 Reset 鍵上單擊即可。 若要將某一圖層上的圖像拷貝到尺寸不同的圖像視窗中央位置時，可以在拖動滑鼠的同時按住 Shift 鍵，圖像拖動到目的視窗後會自動居中。 若要將圖像用於網路傳輸，可將圖像模式設置為 Indexed Color 索引色彩色模式，有檔小、傳輸快的優點，如果再選擇 GIF89a Export(GIF 輸出），可以設置透明的效果，並將檔保存成 GIF 格式。 在使用自由變形（Layer/Free Transform）功能時，按 Ctrl 鍵並拖動某一控制點可以進行隨意變形的調整；“Shift+Ctrl”鍵並拖動某一控制點可以進行傾斜調整；按 Alt 鍵並拖動某一控制點可以進行對稱調整；按“Shift+Ctrl+Alt”鍵並拖動某一控制點可以進行透視效果的調整。 在 layers 調色板上，按住 Ctrl 用滑鼠單擊某一圖層時，可載入該層圖像成選取框(Background 層除外，改名後可以）。 使用路徑(Path)工具時的幾個技巧：使用筆形(Pen)工具製作路徑時按住 Shift 鍵可以強制路徑或方向線成水準、垂直或 45 度角，按住 Ctrl 鍵可暫時切換到路徑選取工具，按住 Alt 鍵將筆形游標在在黑色節點上單擊可以改變方向線的方向，使曲線能夠轉折；按 Alt 鍵用路徑選取(Direct Selection)工具單擊路徑會選取整個路徑；要同時選取多個路徑可以按住 Shift 後逐個單擊；使用路徑選工具時按住“Ctrl+Alt”鍵移近路徑會切換到加節點與減節點筆形工具。 若要切換路徑(path)是否顯示，可以按住 Shift 鍵後在路徑調色板的路徑欄上單擊滑鼠, 或者在路徑調色版灰色區域單擊即可. 若要一起執行數個宏(Action),可以先增加一個宏，然後錄製每一個所要執行的宏。 若要在一個宏(Action)中的某一命令後新增一條命令，可以先選中該命令，然後單擊調色板上的開始錄製(Begin recording)圖示，選擇要增加的命令，再單擊停止錄製(Stop recording)圖示即可。 在使用 Filter/Render/Clouds 濾鏡時，若要產生更多明顯的支紋圖案，可先按住 Alt 鍵後再執行該命令；若要生成低漫射支彩效果，可先按住 Shift 鍵後再執行命令。 在使用 Filter/Render/Lighting Effects 濾鏡時，若要在對話方塊內複製光源時，可先按住 Alt 鍵後再拖動光源即可實現複製。 若要在 Color 調色板上直接切換色彩模式，可先按住 Shift 鍵後，再將游標移到色彩條上單擊即可。 矩形、橢圓選框工具 【M】 裁剪工具 【C】 移動工具 【V】 套索、多邊形套索、磁性套索 【L】 魔棒工具 【W】 噴槍工具 【J】 畫筆工具 【B】 像皮圖章、圖案圖章 【S】 歷史記錄畫筆工具 【Y】 像皮擦工具 【E】 鉛筆、直線工具 【N】 模糊、銳化、塗抹工具 【R】 減淡、加深、海棉工具 【O】 鋼筆、自由鋼筆、磁性鋼筆 【P】 添加錨點工具 【+】 刪除錨點工具 【-】 直接選取工具 【A】 文字、文字蒙板、直排文字、直排文字蒙板 【T】 度量工具 【U】 直線漸變、徑向漸變、對稱漸變、角度漸變、菱形漸變 【G】 油漆桶工具 【K】 吸管、顏色取樣器 【I】 抓手工具 【H】 縮放工具 【Z】 默認前景色和背景色 【D】 切換前景色和背景色 【X】 切換標準模式和快速蒙板模式 【Q】 標準螢幕模式、帶有功能表欄的全屏模式、全屏模式 【F】 臨時使用移動工具 【Ctrl】 臨時使用吸色工具 【Alt】 臨時使用抓手工具 【空格】 打開工具選項面板 【Enter】 快速輸入工具選項(當前工具選項面板中至少有一個可調節數字) 【0】至【9】 迴圈選擇畫筆 【[】或【]】 選擇第一個畫筆 【Shift】+【[】 選擇最後一個畫筆 【Shift】+【]】 建立新漸變(在”漸變編輯器”中) 【Ctrl】+【N】 檔操作 新建圖形檔 【Ctrl】+【N】 用默認設置創建新檔 【Ctrl】+【Alt】+【N】 打開已有的圖像 【Ctrl】+【O】 打開為… 【Ctrl】+【Alt】+【O】 關閉當前圖像 【Ctrl】+【W】 保存當前圖像 【Ctrl】+【S】 另存為… 【Ctrl】+【Shift】+【S】 存儲副本 【Ctrl】+【Alt】+【S】 頁面設置 【Ctrl】+【Shift】+【P】 列印 【Ctrl】+【P】 打開“預置”對話方塊 【Ctrl】+【K】 顯示最後一次顯示的“預置”對話方塊 【Alt】+【Ctrl】+【K】 設置“常規”選項(在預置對話方塊中) 【Ctrl】+【1】 設置“存儲檔”(在預置對話方塊中) 【Ctrl】+【2】 設置“顯示和游標”(在預置對話方塊中) 【Ctrl】+【3】 設置“透明區域與色域”(在預置對話方塊中) 【Ctrl】+【4】 設置“單位與尺規”(在預置對話方塊中) 【Ctrl】+【5】 設置“參考線與網格”(在預置對話方塊中) 【Ctrl】+【6】 設置“增效工具與暫存檔”(在預置對話方塊中) 【Ctrl】+【7】 設置“記憶體與圖像快取記憶體”(在預置對話方塊中) 【Ctrl】+【8】 編輯操作 還原/重做前一步操作 【Ctrl】+【Z】 還原兩步以上操作 【Ctrl】+【Alt】+【Z】 重做兩步以上操作 【Ctrl】+【Shift】+【Z】 剪切選取的圖像或路徑 【Ctrl】+【X】或【F2】 拷貝選取的圖像或路徑 【Ctrl】+【C】 合併拷貝 【Ctrl】+【Shift】+【C】 將剪貼板的內容粘到當前圖形中 【Ctrl】+【V】或【F4】 將剪貼板的內容粘到選框中 【Ctrl】+【Shift】+【V】 自由變換 【Ctrl】+【T】 應用自由變換(在自由變換模式下) 【Enter】 從中心或對稱點開始變換 (在自由變換模式下) 【Alt】 限制(在自由變換模式下) 【Shift】 扭曲(在自由變換模式下) 【Ctrl】 取消變形(在自由變換模式下) 【Esc】 自由變換複製的象素資料 【Ctrl】+【Shift】+【T】 再次變換複製的象素資料並建立一個副本 【Ctrl】+【Shift】+【Alt】+【T】 刪除選框中的圖案或選取的路徑 【DEL】 用背景色填充所選區域或整個圖層 【Ctrl】+【BackSpace】或【Ctrl】+【Del】 用前景色填充所選區域或整個圖層 【Alt】+【BackSpace】或【Alt】+【Del】 彈出“填充”對話方塊 【Shift】+【BackSpace】 從歷史記錄中填充 【Alt】+【Ctrl】+【Backspace】 圖像調整 調整色階 【Ctrl】+【L】 自動調整色階 【Ctrl】+【Shift】+【L】 打開曲線調整對話方塊 【Ctrl】+【M】 在所選通道的曲線上添加新的點(‘曲線’對話方塊中) 在圖像中【Ctrl】加點按 在複合曲線以外的所有曲線上添加新的點(‘曲線’對話方塊中) 【Ctrl】+【Shift】 加點按 移動所選點(‘曲線’對話方塊中) 【↑】/【↓】/【←】/【→】 以 10 點為增幅移動所選點以 10 點為增幅(‘曲線’對話方塊中) 【Shift】+【箭頭】 選擇多個控制點(‘曲線’對話方塊中) 【Shift】加點按 前移控制點(‘曲線’對話方塊中) 【Ctrl】+【Tab】 後移控制點(‘曲線’對話方塊中) 【Ctrl】+【Shift】+【Tab】 添加新的點(‘曲線’對話方塊中) 點按網格 刪除點(‘曲線’對話方塊中) 【Ctrl】加點按點 取消選擇所選通道上的所有點(‘曲線’對話方塊中) 【Ctrl】+【D】 使曲線網格更精細或更粗糙(‘曲線’對話方塊中) 【Alt】加點按網格 選擇彩色通道(‘曲線’對話方塊中) 【Ctrl】+【~】 選擇單色通道(‘曲線’對話方塊中) 【Ctrl】+【數位】 打開“色彩平衡”對話方塊 【Ctrl】+【B】 打開“色相/飽和度”對話方塊 【Ctrl】+【U】 全圖調整(在色相/飽和度”對話方塊中) 【Ctrl】+【~】 只調整紅色(在色相/飽和度”對話方塊中) 【Ctrl】+【1】 只調整黃色(在色相/飽和度”對話方塊中) 【Ctrl】+【2】 只調整綠色(在色相/飽和度”對話方塊中) 【Ctrl】+【3】 只調整青色(在色相/飽和度”對話方塊中) 【Ctrl】+【4】 只調整藍色(在色相/飽和度”對話方塊中) 【Ctrl】+【5】 只調整洋紅(在色相/飽和度”對話方塊中) 【Ctrl】+【6】 去色 【Ctrl】+【Shift】+【U】 反相 【Ctrl】+【I】 圖層操作 從對話方塊新建一個圖層 【Ctrl】+【Shift】+【N】 以默認選項建立一個新的圖層 【Ctrl】+【Alt】+【Shift】+【N】 通過拷貝建立一個圖層 【Ctrl】+【J】 通過剪切建立一個圖層 【Ctrl】+【Shift】+【J】 與前一圖層編組 【Ctrl】+【G】 取消編組 【Ctrl】+【Shift】+【G】 向下合併或合併聯接圖層 【Ctrl】+【E】 合併可見圖層 【Ctrl】+【Shift】+【E】 蓋印或蓋印聯接圖層 【Ctrl】+【Alt】+【E】 蓋印可見圖層 【Ctrl】+【Alt】+【Shift】+【E】 將當前層下移一層 【Ctrl】+【[】 將當前層上移一層 【Ctrl】+【]】 將當前層移到最下麵 【Ctrl】+【Shift】+【[】 將當前層移到最上面 【Ctrl】+【Shift】+【]】 啟動下一個圖層 【Alt】+【[】 啟動上一個圖層 【Alt】+【]】 啟動底部圖層 【Shift】+【Alt】+【[】 啟動頂部圖層 【Shift】+【Alt】+【]】 調整當前圖層的透明度(當前工具為無數字參數的,如移動工具) 【0】至【9】 保留當前圖層的透明區域(開關) 【/】 投影效果(在”效果”對話方塊中) 【Ctrl】+【1】 內陰影效果(在”效果”對話方塊中) 【Ctrl】+【2】 外發光效果(在”效果”對話方塊中) 【Ctrl】+【3】 內發光效果(在”效果”對話方塊中) 【Ctrl】+【4】 斜面和浮雕效果(在”效果”對話方塊中) 【Ctrl】+【5】 應用當前所選效果並使參數可調(在”效果”對話方塊中) 【A】 圖層混合模式 迴圈選擇混合模式 【Alt】+【-】或【+】 正常 【Ctrl】+【Alt】+【N】 閾值（點陣圖模式） 【Ctrl】+【Alt】+【L】 溶解 【Ctrl】+【Alt】+【I】 背後 【Ctrl】+【Alt】+【Q】 清除 【Ctrl】+【Alt】+【R】 正片疊底 【Ctrl】+【Alt】+【M】 螢幕 【Ctrl】+【Alt】+【S】 疊加 【Ctrl】+【Alt】+【O】 柔光 【Ctrl】+【Alt】+【F】 強光 【Ctrl】+【Alt】+【H】 顏色減淡 【Ctrl】+【Alt】+【D】 顏色加深 【Ctrl】+【Alt】+【B】 變暗 【Ctrl】+【Alt】+【K】 變亮 【Ctrl】+【Alt】+【G】 差值 【Ctrl】+【Alt】+【E】 排除 【Ctrl】+【Alt】+【X】 色相 【Ctrl】+【Alt】+【U】 飽和度 【Ctrl】+【Alt】+【T】 顏色 【Ctrl】+【Alt】+【C】 光度 【Ctrl】+【Alt】+【Y】 去色 海棉工具+【Ctrl】+【Alt】+【J】 加色 海棉工具+【Ctrl】+【Alt】+【A】 暗調 減淡/加深工具+【Ctrl】+【Alt】+【W】 中間調 減淡/加深工具+【Ctrl】+【Alt】+【V】 高光 減淡/加深工具+【Ctrl】+【Alt】+【Z】 選擇功能 全部選取 【Ctrl】+【A】 取消選擇 【Ctrl】+【D】 重新選擇 【Ctrl】+【Shift】+【D】 羽化選擇 【Ctrl】+【Alt】+【D】 反向選擇 【Ctrl】+【Shift】+【I】 路徑變選區 數位鍵盤的【Enter】 載入選區 【Ctrl】+點按圖層、路徑、通道面板中的縮約圖 濾鏡 按上次的參數再做一次上次的濾鏡 【Ctrl】+【F】 退去上次所做濾鏡的效果 【Ctrl】+【Shift】+【F】 重複上次所做的濾鏡(可調參數) 【Ctrl】+【Alt】+【F】 選擇工具(在“3D 變化”濾鏡中) 【V】 立方體工具(在“3D 變化”濾鏡中) 【M】 球體工具(在“3D 變化”濾鏡中) 【N】 柱體工具(在“3D 變化”濾鏡中) 【C】 軌跡球(在“3D 變化”濾鏡中) 【R】 全景相機工具(在“3D 變化”濾鏡中) 【E】 視圖操作 顯示彩色通道 【Ctrl】+【~】 顯示單色通道 【Ctrl】+【數位】 顯示複合通道 【~】 以 CMYK 方式預覽(開關) 【Ctrl】+【Y】 打開/關閉色域警告 【Ctrl】+【Shift】+【Y】 放大視圖 【Ctrl】+【+】 縮小視圖 【Ctrl】+【-】 滿畫布顯示 【Ctrl】+【0】 實際象素顯示 【Ctrl】+【Alt】+【0】 向上捲動一屏 【PageUp】 向下捲動一屏 【PageDown】 向左捲動一屏 【Ctrl】+【PageUp】 向右捲動一屏 【Ctrl】+【PageDown】 向上捲動 10 個單位 【Shift】+【PageUp】 向下捲動 10 個單位 【Shift】+【PageDown】 向左捲動 10 個單位 【Shift】+【Ctrl】+【PageUp】 向右捲動 10 個單位 【Shift】+【Ctrl】+【PageDown】 將視圖移到左上角 【Home】 將視圖移到右下角 【End】 顯示/隱藏選擇區域 【Ctrl】+【H】 顯示/隱藏路徑 【Ctrl】+【Shift】+【H】 顯示/隱藏尺規 【Ctrl】+【R】 顯示/隱藏參考線 【Ctrl】+【;】 顯示/隱藏網格 【Ctrl】+【”】 貼緊參考線 【Ctrl】+【Shift】+【;】 鎖定參考線 【Ctrl】+【Alt】+【;】 貼緊網格 【Ctrl】+【Shift】+【”】 顯示/隱藏“畫筆”面板 【F5】 顯示/隱藏“顏色”面板 【F6】 顯示/隱藏“圖層”面板 【F7】 顯示/隱藏“資訊”面板 【F8】 顯示/隱藏“動作”面板 【F9】 顯示/隱藏所有命令面板 【TAB】 顯示或隱藏工具箱以外的所有調板 【Shift】+【TAB】 文字處理(在”文字工具”對話方塊中) 左對齊或頂對齊 【Ctrl】+【Shift】+【L】 中對齊 【Ctrl】+【Shift】+【C】 右對齊或底對齊 【Ctrl】+【Shift】+【R】 左／右選擇 1 個字元 【Shift】+【←】/【→】 下／上選擇 1 行 【Shift】+【↑】/【↓】 選擇所有字元 【Ctrl】+【A】 選擇從插入點到滑鼠點按點的字元 【Shift】加點按 左／右移動 1 個字元 【←】/【→】 下／上移動 1 行 【↑】/【↓】 左／右移動 1 個字 【Ctrl】+【←】/【→】 將所選文本的文字大小減小 2 點象素 【Ctrl】+【Shift】+【&lt;】 將所選文本的文字大小增大 2 點象素 【Ctrl】+【Shift】+【&gt;】 將所選文本的文字大小減小 10 點象素 【Ctrl】+【Alt】+【Shift】+【&lt;】 將所選文本的文字大小增大 10 點象素 【Ctrl】+【Alt】+【Shift】+【&gt;】 將行距減小 2 點象素 【Alt】+【↓】 將行距增大 2 點象素 【Alt】+【↑】 將基線位移減小 2 點象素 【Shift】+【Alt】+【↓】 將基線位移增加 2 點象素 【Shift】+【Alt】+【↑】 將字距微調或字距調整減小 20/1000ems 【Alt】+【←】 將字距微調或字距調整增加 20/1000ems 【Alt】+【→】 將字距微調或字距調整減小 100/1000ems 【Ctrl】+【Alt】+【←】 將字距微調或字距調整增加 100/1000ems 【Ctrl】+【Alt】+【→】 選擇通道中白的圖元（包括半色調）【Ctrl】+【Alt】+【1~9】","categories":[{"name":"Photoshop","slug":"Photoshop","permalink":"https://tsaiyuyan.github.io/categories/Photoshop/"}],"tags":[]},{"title":"771. Jewels and Stones","slug":"Leetcode/771_Jewels and Stones","date":"2019-03-21T03:39:00.000Z","updated":"2020-09-28T07:49:39.046Z","comments":true,"path":"2019/03/21/leetcode/771-jewels-and-stones/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/21/leetcode/771-jewels-and-stones/","excerpt":"","text":"Link: https://leetcode.com/problems/jewels-and-stones/submissions/ You’re given strings J representing the types of stones that are jewels, and S representing the stones you have. Each character in S is a type of stone you have. You want to know how many of the stones you have are also jewels. The letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so “a” is considered a different type of stone from “A”. Example 1: Input: J = \"aA\", S = \"aAAbbbb\" Output: 3 Example 2: Input: J = \"z\", S = \"ZZ\" Output: 0 Note: S and J will consist of letters and have length at most 50. The characters in J are distinct. 題目翻譯: 你得到的字符串 J 代表珠寶的石頭類型，S 代表你擁有的寶石。 S 中的每個角色都是你擁有的一種石頭。你想知道你有多少寶石也是珠寶。J 中的字母保證不同，J 和 S 中的所有字符都是字母。字母區分大小寫，因此“a”被認為是與“A”不同類型的石頭。 程式思路: 建立一個珠寶石頭類型 hash table 在比對自已擁有的珠寶，就能輕鬆解題。 class Solution { public: int numJewelsInStones(string J, string S) { unsigned int ret = 0; std::unordered_map&lt;char,int> umap; for (unsigned i=0; i&lt;J.length(); ++i) { umap.insert( pair&lt;char, int>( J.at(i), i)); } for (unsigned i=0; i&lt;S.length(); ++i) { if(umap.find(S.at(i)) != umap.end()) ret ++; } return ret; } };","categories":[{"name":"LeetCode","slug":"LeetCode","permalink":"https://tsaiyuyan.github.io/categories/LeetCode/"}],"tags":[{"name":"c/c++","slug":"c-c","permalink":"https://tsaiyuyan.github.io/tags/c-c/"},{"name":"Easy","slug":"Easy","permalink":"https://tsaiyuyan.github.io/tags/Easy/"}]},{"title":"visual-studio 控制Windows螢幕小鍵盤的方法(非administrator)","slug":"Windows/VC++ 控制Windows螢幕小鍵盤的方法(非administrator)","date":"2019-03-20T08:39:00.000Z","updated":"2020-09-28T07:48:37.875Z","comments":true,"path":"2019/03/20/windows/vc-kong-zhi-windows-ying-mu-xiao-jian-pan-de-fang-fa-fei-administrator/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/20/windows/vc-kong-zhi-windows-ying-mu-xiao-jian-pan-de-fang-fa-fei-administrator/","excerpt":"","text":"環境 OS: Windows7 IDE:Visual Studio 2012 0.功能描述 windows 在使用螢幕小鍵盤的時候，千萬不要傻傻的自己撰寫一個虛擬鍵盤，你以前 XP 時代或許還行得通，但碰到現在 UAC 時代(vista 以後預設都是開啟)，你最好就是直接用作業系統提供的，好處很多，不用自己撰寫多國語系，就算客戶有埋怨，我們也可以跟客戶講說，我們是呼叫系統的。 1.呼叫小鍵盤 簡單的用 cmd 方式就可以呼叫了 ShellExecute( NULL, NULL, L\"osk\", NULL,NULL,SW_SHOW); 用 FindWindow 確認有沒有開啟成功。 if(::FindWindow(L\"OSKMainClass\", NULL)) { printf(\"osk open successed\\n\"); } 2.移動小鍵盤 MoveWindow 或是 SetWindowPos 在 UAC 的狀態下，用一般使用者都是沒辦法移動小鍵盤了，所以呢，呼叫小鍵盤前，需要去修改”登錄擋”，沒錯就是登錄擋，HKEY_CURRENT_USER\\SOFTWARE\\Microsoft\\Osk，到這個位置把參數換一換就能夠達到 MoveWindow 的功能了。 DWORD WindowLeft=0;//視窗左上角的位置 DWORD WindowTop=0;//視窗左上角的位置 DWORD WindowWidth=1024//視窗左上角的位置 DWORD WindowHeight=768//視窗左上角的位置 HKEY hKey; LPCTSTR sk = TEXT(\"SOFTWARE\\\\Microsoft\\\\Osk\"); LONG openRes = RegOpenKeyEx(HKEY_CURRENT_USER, sk, 0, KEY_ALL_ACCESS , &amp;hKey); if (openRes==ERROR_SUCCESS) { printf(\"Success opening key.\"); auto lambda = [=] (const wchar_t *valuename,DWORD value){ LONG setRes = RegSetValueEx(hKey, valuename, 0, REG_DWORD, (const BYTE*)&amp;value, sizeof(value)); if (setRes == ERROR_SUCCESS) { wprintf(L\"Success writing to Registry. valuename = %s value = %d\",valuename,value); } else { wprintf(L\"Error writing to Registry. valuename = %s value = %d\",valuename,value); } //cout &lt;&lt; setRes &lt;&lt; endl; }; lambda(L\"WindowLeft\",WindowLeft); lambda(L\"WindowTop\",WindowTop); lambda(L\"WindowWidth\",WindowWidth); lambda(L\"WindowHeight\",WindowHeight); lambda(L\"UseTextPrediction\",0); //關閉文字預測 lambda(L\"NavigationMode\",0); //關閉 Nav模式 LONG closeOut = RegCloseKey(hKey); if (closeOut == ERROR_SUCCESS) { printf(\"Success closing key.\"); } else { printf(\"Error closing key.\"); } } else { printf(\"Error opening key.\"); } 3.關閉小鍵盤&amp;修改一些客製參數 用 SendMessage 對 osk 發送 SC_CLOSE 即可 HWND hKbd=0; hKbd = ::FindWindowW(L\"OSKMainClass\",NULL); if(hKbd) { ::SendMessage(hKbd,WM_SYSCOMMAND, SC_CLOSE,0); // } 4.Administrator 無節操控制(不建議) 用最強權限控制，當然是最沒有節操的。","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[{"name":"visual-studio","slug":"visual-studio","permalink":"https://tsaiyuyan.github.io/tags/visual-studio/"}]},{"title":"Hexo Blog Note","slug":"Hexo/Hexo Blog Note","date":"2019-03-20T02:00:00.000Z","updated":"2020-05-11T07:35:19.106Z","comments":true,"path":"2019/03/20/hexo/hexo-blog-note/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/20/hexo/hexo-blog-note/","excerpt":"","text":"20200422 更新 系統環境配置 安裝 Node.js 安裝 Git 安裝 Hexo $ cd d:/hexo $ npm install hexo-cli -g $ hexo init blog $ cd blog $ npm install $ hexo g # 或者hexo generate $ hexo s # 或者hexo server，可以在http://localhost:4000/ 查看 Hexo 常用命令 hexo generate (hexo g) 生成靜態文件，會在當前目錄下生成一個新的叫做 public 的文件夾 hexo server (hexo s) 啟動本地 web 服務，用於博客的預覽 hexo deploy (hexo d) 佈署播客到遠端（比如 github, heroku 等平台） hexo clean 清掉佈署檔案，重建時會用到 Yuyan’s 配置package.json $npm install XXXXXXXXX --save { \"name\": \"hexo-site\", \"version\": \"0.0.0\", \"private\": true, \"hexo\": { \"version\": \"4.2.0\" }, \"dependencies\": { \"hexo\": \"^4.2.0\", \"hexo-blog-encrypt\": \"^2.1.0\", \"hexo-deployer-git\": \"^0.3.1\", \"hexo-generator-archive\": \"^0.1.4\", \"hexo-generator-category\": \"^0.1.3\", \"hexo-generator-index\": \"^0.2.0\", \"hexo-generator-json-content\": \"^4.1.3\", \"hexo-generator-search\": \"^2.4.0\", \"hexo-generator-tag\": \"^0.2.0\", \"hexo-helper-live2d\": \"^3.1.1\", \"hexo-pagination\": \"^0.1.0\", \"hexo-permalink-pinyin\": \"^1.0.0\", \"hexo-prism-plugin\": \"^2.3.0\", \"hexo-renderer-ejs\": \"^0.3.0\", \"hexo-renderer-jade\": \"^0.3.0\", \"hexo-renderer-markdown-it\": \"^4.1.0\", \"hexo-renderer-stylus\": \"^0.3.3\", \"hexo-server\": \"^0.2.0\", \"hexo-wordcount\": \"^6.0.1\", \"live2d-widget-model-hijiki\": \"^1.0.5\", \"markdown-it-abbr\": \"^1.0.4\", \"markdown-it-checkbox\": \"^1.1.0\", \"markdown-it-container\": \"^2.0.0\", \"markdown-it-deflist\": \"^2.0.3\", \"markdown-it-emoji\": \"^1.4.0\", \"markdown-it-footnote\": \"^3.0.2\", \"markdown-it-imsize\": \"^2.0.1\", \"markdown-it-ins\": \"^3.0.0\", \"markdown-it-mark\": \"^3.0.0\", \"markdown-it-regexp\": \"^0.4.0\", \"markdown-it-sub\": \"^1.0.0\", \"markdown-it-sup\": \"^1.0.0\", \"markdown-it-task-checkbox\": \"^1.0.6\" } } hexo’s _config.yma 最後加上 # Markdown-it config ## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki markdown: render: html: true # Doesn't escape HTML content so the tags will appear as html. xhtmlOut: false # Parser will not produce XHTML compliant code. breaks: true # Parser produces `` tags every time there is a line break in the source document. linkify: false # Returns text links as text. typographer: true # Substitution of common typographical elements will take place. quotes: '“”‘’' # \"double\" will be turned into “single” # 'single' will be turned into ‘single’ plugins: - markdown-it-abbr - name: markdown-it-container options: success - name: markdown-it-container options: info - name: markdown-it-container options: warning - name: markdown-it-container options: danger - markdown-it-deflist - name: markdown-it-emoji options: shortcuts: {} - markdown-it-footnote - markdown-it-imsize - markdown-it-ins - markdown-it-mark - markdown-it-regexp - markdown-it-sub - markdown-it-sup - markdown-it-task-checkbox anchors: level: 2, 6 # Minimum level for ID creation. (Ex. h2 to h6) collisionSuffix: 'v' # A suffix that is prepended to the number given if the ID is repeated. permalink: true # If true, creates an anchor tag with a permalink besides the heading. permalinkClass: header-anchor # Class used for the permalink anchor tag. permalinkSymbol: '' # The symbol used to make the permalink. edit node_modules/markdown-it-task-checkbox/index.js function makeCheckbox(token, id, options, TokenConstructor) { var checkbox = new TokenConstructor(\"checkbox_input\", \"input\", 0); checkbox.attrs = [ [\"type\", \"checkbox\"], [\"id\", id], ]; var checked = /^\\[[xX]\\][ \\u00A0]/.test(token.content); // if token.content starts with '[x] ' or '[X] ' if (checked === true) { checkbox.attrs.push([\"checked\", \"true\"]); } if (options.disabled === true) { //checkbox.attrs.push([\"disabled\", \"false\"]); //marked by yuyan 20200422 } checkbox.attrs.push([\"onclick\", \"return false;\"]); //added by yuyan 20200422,such as disable function return checkbox; } edit \\themes\\hexo-theme-matery\\source\\materialize.min.css label{font-size:.8rem;color:#9e9e9e}改成label{font-size:.8rem;color:#34495e}這是為了讓checkbox 的文字不要那麼淡。 改成type=”checkbox”:not(:checked),type=”checkbox”:checked{position:absolute;pointer-events:none}這是為了讓checkbox 不要被透明掉","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://tsaiyuyan.github.io/categories/Hexo/"}],"tags":[]},{"title":"Windows 右鍵清單加入 Force a program to run without administrator","slug":"Windows/Windows 右鍵清單加入 Force a program to run without administrator","date":"2019-03-19T07:40:00.000Z","updated":"2020-05-11T07:35:19.237Z","comments":true,"path":"2019/03/19/windows/windows-you-jian-qing-dan-jia-ru-force-a-program-to-run-without-administrator/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/19/windows/windows-you-jian-qing-dan-jia-ru-force-a-program-to-run-without-administrator/","excerpt":"","text":"功能描述 有時候程式 mainfest 有 UAC 詢問會強制讓使用者使用管理員權限開啟程式，但因為 RD 要用一般使用者而懶得切換測試，這時用此功能即可方便的用一般使用者開啟程式，方便測試一些權限相關的功能。 Add Right Click menu - Force a program to run without administrator privileges or UAC.regWindows Registry Editor Version 5.00 #https://superuser.com/questions/171917/force-a-program-to-run-without-administrator-privileges-or-uac [HKEY_CLASSES_ROOT\\*\\shell\\forcerunasinvoker] @=\"Run without privilege elevation\" [HKEY_CLASSES_ROOT\\*\\shell\\forcerunasinvoker\\command] @=\"cmd /min /C \\\"set __COMPAT_LAYER=RUNASINVOKER &amp;&amp; start \\\"\\\" \\\"%1\\\"\\\"\"","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[]},{"title":"Windows 關閉視窗搖曳功能","slug":"Windows/Windows 視窗搖曳功能","date":"2019-03-19T07:24:00.000Z","updated":"2020-05-11T07:35:19.239Z","comments":true,"path":"2019/03/19/windows/windows-shi-chuang-yao-yi-gong-neng/","link":"","permalink":"https://tsaiyuyan.github.io/2019/03/19/windows/windows-shi-chuang-yao-yi-gong-neng/","excerpt":"","text":"功能描述windows 在滑鼠按住視窗標題欄時 若使用搖動會讓其他開啟的視窗一併縮小，如果想要還原必須在搖回去，在公司使用時會讓工作不是很方便，所以用利用 reg 的方式修改讓 windows 關閉此功能。 Disable_Aero_Shake_for_all_users.regWindows Registry Editor Version 5.00 ; Created by: Shawn Brink ; Created on: March 1st 2015 ; Tutorial: https://www.tenforums.com/tutorials/4417-aero-shake-enable-disable-windows-10-a.html [HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\Explorer] \"NoWindowMinimizingShortcuts\"=dword:00000001 [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Explorer] NoWindowMinimizingShortcuts\"=dword:00000001 Disable_Aero_Shake_for_current_user.regWindows Registry Editor Version 5.00 ; Created by: Shawn Brink ; Created on: November 6th 2016 ; Tutorial: https://www.tenforums.com/tutorials/4417-aero-shake-enable-disable-windows-10-a.html [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced] \"DisallowShaking\"=dword:00000001 Enable_Aero_Shake_for_all_users.regWindows Registry Editor Version 5.00 ; Created by: Shawn Brink ; Created on: March 1st 2015 ; Tutorial: https://www.tenforums.com/tutorials/4417-aero-shake-enable-disable-windows-10-a.html [HKEY_CURRENT_USER\\SOFTWARE\\Policies\\Microsoft\\Windows\\Explorer] \"NoWindowMinimizingShortcuts\"=- [HKEY_LOCAL_MACHINE\\SOFTWARE\\Policies\\Microsoft\\Windows\\Explorer] \"NoWindowMinimizingShortcuts\"=- Enable_Aero_Shake_for_current_user.regWindows Registry Editor Version 5.00 ; Created by: Shawn Brink ; Created on: November 6th 2016 ; Tutorial: https://www.tenforums.com/tutorials/4417-aero-shake-enable-disable-windows-10-a.html [HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced] \"DisallowShaking\"=dword:00000000","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[]},{"title":"Yuyan's Exportxlsx 專案","slug":"ezio_worklog/Yuyan's Exportxlsx 專案","date":"2018-11-29T05:39:00.000Z","updated":"2020-09-21T05:44:38.176Z","comments":true,"path":"2018/11/29/ezio-worklog/yuyan-s-exportxlsx-zhuan-an/","link":"","permalink":"https://tsaiyuyan.github.io/2018/11/29/ezio-worklog/yuyan-s-exportxlsx-zhuan-an/","excerpt":"","text":"CC 報表產生器功能 對每台 NVR 產生 VLOSS 報表，並將即時串流影像用 ffmeg 解碼截圖輸出至 xlsx 尚未擴展功能 將每個 NVR 報表利用 ThreadPool 分開進行(但依序進行其實效果也不差 缺點是 MFC 介面無法更新) Lastest Vesion ver 1.0.0.7 New Function 效能改善(搭配 cache 功能) - 如果程式工作到一半，被任何因素導致中斷(ex.斷電，手動關閉等…)，下次如果再跑同樣資料的報表，會自動獲取 cache 來使用，大幅減少重新取得資料的時間。 新增 Scan 按鈕，Scan 按鈕內的 command port 會自動偵測，如果跟原本已加入的 NVR 衝突的話，會以 Scan 設定的為主。 delete &amp; scan 可以使用多選功能， 利用 ctrl 或是 shift 可進行多重選擇。 取消 1.0.0.6 版以前所有前置鏡頭定義，更改為 PB 鏡頭，PB 鏡頭圖片上會有時間日期，照片取得順序為 Cache (已跑過的報表) &gt; “上一個月 1 號 9:00 am “ &gt; 最早追溯時間鏡頭。 當次鏡頭欄位 更改為 Live 鏡頭， 圖片上會有時間日期，每次跑報表時皆會變化。 新增 Cache 功能，建議使用者使用同一部電腦跑報表，這樣 Cache 才能發揮最大效益， Cache 保存為 image ( PB 鏡頭) 跟 Alarm VLOSS 計算(最花時間)。 Cache 支援當月份 Alarm 存取。 UI 更動，為資料範圍以月為單位，使用者須自行選定範圍。排程設定 跟 手動設定 稍微不同。 UI 更動，進度條 會顯示%數，但目前切割範圍比較大所以在 IP 過少的情況下 可能會跳很快。(如果還是不放心程式是否有正在運作，可以點選 system manu 叫出 console 視窗。抑或是觀察文件夾下的 exportxlsx// image 看有否變動。) 新增 Test Login 按鈕，功能是可以偵測列表上目前設定的帳號能否登入成功。 Note AVSlot 跟 AVClip 不同步的問題。 如果是下載不同時區的 NVR ，PB 鏡頭也是會有晚上的可能。 不是所有 NVR 都支援萬用密碼，所以當 rup4jo3dkru4 帳號無法登入成功時，請使用者設定自訂義帳號登入。 海康格式圖片不支援 nvr 要完成下列這些事情 登入 NVR(60009 port) 詢問 nvr 下 ch 資料(60009 port) 詢問 avslot 追溯時間 ch 數(59999 port) 取得 live 圖片 ch 數 (3514 port) 取得 PB 圖片ch數(60006 port)+詢問 avclipch 數(60009 port) 取得 active alarm (60009 port) 取得 history alarm(60009 port) 提取 cache ch 數 (本地端提取) OpenLibrary cURL libxlsxwriter ffmpeg-64","categories":[{"name":"ezio_worklog","slug":"ezio-worklog","permalink":"https://tsaiyuyan.github.io/categories/ezio-worklog/"}],"tags":[]},{"title":"Windows 32-bits、64-bits 作業系統的 Registry 注意事項","slug":"Windows/Windows 32-bits、64-bits 作業系統的 Registry 注意事項","date":"2018-03-06T08:36:00.000Z","updated":"2020-05-11T07:35:19.230Z","comments":true,"path":"2018/03/06/windows/windows-32-bits-64-bits-zuo-ye-xi-tong-de-registry-zhu-yi-shi-xiang/","link":"","permalink":"https://tsaiyuyan.github.io/2018/03/06/windows/windows-32-bits-64-bits-zuo-ye-xi-tong-de-registry-zhu-yi-shi-xiang/","excerpt":"","text":"此為轉載文章 在 64-bits 的作業系統下執行 32-bits 的應用程式時，若需要寫入 Registry 時，會發現機碼被作業系統預設寫入 Wow6432Node 的目錄底下，不論是 HKEY_CURRENT_USER 還是 HKEY_LOCAL_MACHINE 皆相同。 在 HKEY_CURRENT_USER\\Software\\ 底下寫入機碼就會預設出現在 HKEY_CURRENT_USER\\Software\\Wow6432Node\\ 的同樣位置同理在 HKEY_LOCAL_MACHINE\\SOFTWARE\\ 底下寫入機碼，就會出現在 HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\ 底下相同的位置 位置不變，只是多了一層 Wow6432Node 的資料夾，這是為了做 32-bits 應用程式與 64-bits 作業系統的對應而產生的結果。 其實一般來說不太需要特別注意這件事，應用程式的寫作上以原本的路徑在讀寫就行了，要不要指向 Wow6432Node 完全由作業系統來決定，但是有些例外，如果某些值作業系統只會去參考在原本的非 Wow6432Node 路徑下時，而這個值被寫到 Wow6432Node 的位置下就沒辦法發揮預期的效果了，HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps\\ 就是一個例子，如果有一個 32-bits 的應用程式在此處寫入機碼，依前面所言，會被寫到 HKEY_LOCAL_MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\Windows Error Reporting\\LocalDumps\\ 裡面，而這樣是無效的，因為作業系統只會參考原本非 Wow6432Node 底下的機碼。 所以我們可加入一個新的參數，指定 32-bits 的應用程式在 64-bits 的作業系統下建立、讀取、寫入機碼時，不要在 Wow6432Node 下執行，而是在原本的位置做寫入，可以參考 MSDN 的說明：Accessing an Alternate Registry View 參數分別為 KEY_WOW64_64KEY：Access a 64-bit key from either a 32-bit or 64-bit application.與 KEY_WOW64_32KEY：Access a 32-bit key from either a 32-bit or 64-bit application. 以 RegCreateKeyEx 作示範就像這樣 if (ERROR_SUCCESS != RegCreateKeyEx(HKEY_LOCAL_MACHINE, _T(\"Software\\\\Microsoft\\\\Windows\\\\Windows Error Reporting\\\\LocalDumps\\\\MyApp.exe\"), 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE|KEY_WOW64_64KEY, NULL, &amp;hKey, &amp;disp)) { return; } 轉載來源: http://ascii-iicsa.blogspot.tw/2013/06/32-bits64-bits-registry.html","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[{"name":"regedit","slug":"regedit","permalink":"https://tsaiyuyan.github.io/tags/regedit/"}]},{"title":"Windows UAC白名單設置","slug":"Windows/Windows UAC白名單設置","date":"2018-02-22T03:00:00.000Z","updated":"2020-05-11T07:35:19.233Z","comments":true,"path":"2018/02/22/windows/windows-uac-bai-ming-dan-she-zhi/","link":"","permalink":"https://tsaiyuyan.github.io/2018/02/22/windows/windows-uac-bai-ming-dan-she-zhi/","excerpt":"","text":"UAC 簡介 使用者帳戶控制（英語：User Account Control，UAC）是 Windows Vista 中新出現的安全技術，通過限制應用軟體而改進 Windows 作業系統的安全性。Windows 7 中保持了這個功能，但是可以允許使用者選擇 UAC 的安全等級。 情況描述 程式因為某些功能(ex.License 需要取得硬體資訊)，在執行過程需要系統管理員 administrator 權限執行，但當程式轉手賣給客戶後，客戶公司的 MIS，想用一般使用者的帳號去執行，此時會被要求輸入 administrator 的密碼，這時就會發生希望修改程式權限的要求。基於公司保護 License 的情況下當然不可能修改程式執行權限需求，但又要滿足客戶能夠讓一般 user 使用。 我們已知限制的條件 程式必須以 administrator 執行 &lt;== 程式設計師要求 一般使用者要能夠執行 &lt;== MIS 要求 不可完全關閉系統 UAC &lt;== MIS 要求 看到這些限制答案就已經呼之欲出了，就是將請將程式設置 UAC 白名單，讓一般使用者在不過問前提下(小盾牌)也能夠執行程式。 我們要看到的結果是“一般使用者帳號 執行有盾牌的程式 將不會過問 UAC，而且程式能夠以 administrator 的權限去執行” 解決方案一、利用微軟提供的工具利用微軟提供的應用程式相容性工具 Microsoft Application Compatibility Toolkit 1.首先下載跟安裝 下載: === win10 以前(不含win10)) === Microsoft Application Compatibility Toolkit 5.6 (ACT) https://www.microsoft.com/en-us/download/details.aspx?id=7352 === win10 === Windows Assessment and Deployment Kit (ADK) https://docs.microsoft.com/en-us/windows-hardware/get-started/adk-install 其實裡面包含ACT 只要選擇ACT安裝即可，中文是應用程式程式相容性工具，如下圖所示 2.安裝完後開啟 “ Compatibility Administrator (64-bit) “ (如果是 32-bit 的程式請進入 32-bit) windows7 的預設路徑: C:\\Program Files (x86)\\Microsoft Application Compatibility Toolkit\\Compatibility Administrator (64-bit)\\Compatadmin.exe C:\\Program Files (x86)\\Microsoft Application Compatibility Toolkit\\Compatibility Administrator (32-bit)\\Compatadmin.exewindows10 的預設路徑: C:\\Program Files (x86)\\Windows Kits\\8.1\\ADK\\Microsoft Application Compatibility Toolkit\\Compatibility Administrator (64-bit)\\Compatadmin.exe C:\\Program Files (x86)\\Windows Kits\\8.1\\ADK\\Microsoft Application Compatibility Toolkit\\Compatibility Administrator (32-bit)\\Compatadmin.exe3.先對 “ New Database(1) [Untitled_1] “ 按一下，接著點選 Fix，如下圖 4.接著會進入一個視窗， “ Name of the program to be fixed “ 那行是輸入想設為白名單的程式名稱(其實隨便打也沒差)， “ Name of the vendor for this program “ 可以不用理他， “ Program file location “ 這行就是你想設為白名單程式的路徑，點選旁邊 “ Browse… “ 即可設定，好了之後按下一步，下圖為範例 5.尋找 “ RunAsAdmin “ 、 “ RunAsHighest “ 、 “ RunAsInvoker “ 並打勾，好了之後按下一步，如下圖紅框 6.不用進行設定，直接下一步，如圖 7.一樣不用改，直接按完成 8.對 “ New Database(1) [Untitled_1] “ 按下 Ctrl + R，改一個新的名子，改完之後按下 Save 9.對 “ XXX [Untitled_1] “ (XXX = 你改的名子)按右鍵，點選 “ Install “ 10.如果出現 “ The database ‘XXX’ was successfully installed “ 就是成功了 以上圖片跟文字說明大部分取至巴哈網友 GaGLA21726 來源: https://home.gamer.com.tw/creationDetail.php?sn=2145134 二、修改註冊碼 regedit1.使用系統管理員-&gt;開始-&gt;執行-&gt; 輸入 regedit \\HKEY_LOCAL_MACHINE\\Software\\Microsoft\\Windows NT\\CurrentVersion\\AppCompatFlags\\Layers PS: 這邊注意的一點，部分網站都是教說寫在HKEY_CURRENT_USER，但是本案例使用的是HKEY_LOCAL_MACHINE 因為HKEY_CURRENT_USER 在不同的使用者帳號下所看到的註冊碼是不同的， 有點類似 HKEY_CURRENT_USER 是屬於Local的變數--->ex.某使用者的文件 HKEY_LOCAL_MACHINE則是Global 變數的感覺--->ex.公用文件 所以根據需求來決定要寫在HKEY_LOCAL_MACHINE 或是 HKEY_CURRENT_USER 2.如果沒看到 Layers 請自行新增 在 AppCompatFlag 按右鍵-&gt;新增-&gt;機碼 名稱改為 Layers 3.選擇 Layers 按右鍵-&gt;新增-&gt;字串值 數值名稱: 執行程式路徑 數值資料: ~ RUNASADMIN RUNASINVOKER Note: ~ 表示有多參數的意思 RUNASADMIN 以系統管理員權限執行 RUNASINVOKER 不彈出UAC警告視窗","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[{"name":"side-project","slug":"side-project","permalink":"https://tsaiyuyan.github.io/tags/side-project/"},{"name":"UAC","slug":"UAC","permalink":"https://tsaiyuyan.github.io/tags/UAC/"},{"name":"Microsoft Application Compatibility Toolkit (ACT)","slug":"Microsoft-Application-Compatibility-Toolkit-ACT","permalink":"https://tsaiyuyan.github.io/tags/Microsoft-Application-Compatibility-Toolkit-ACT/"},{"name":"Windows Assessment and Deployment Kit (ADK)","slug":"Windows-Assessment-and-Deployment-Kit-ADK","permalink":"https://tsaiyuyan.github.io/tags/Windows-Assessment-and-Deployment-Kit-ADK/"}]},{"title":"Git clean 指令","slug":"Git clean 指令","date":"2018-02-21T02:53:00.000Z","updated":"2020-05-11T07:35:19.100Z","comments":true,"path":"2018/02/21/git-clean-zhi-ling/","link":"","permalink":"https://tsaiyuyan.github.io/2018/02/21/git-clean-zhi-ling/","excerpt":"","text":"檢查即將被移除的”已忽略檔案” (含資料夾內)git clean -nXdf 移除”已忽略檔案” (含資料夾內)git clean -Xdf 檢查即將被移除的”已忽略檔案”和”未版控檔案”(含資料夾內)git clean -nxdf 移除”已忽略檔案”和”未版控檔案” (含資料夾內)git clean -xdf Note: 如果大寫的 X 被改成小寫 x，會連沒被版控的檔案都會刪除 &lt;== 注意此部分。 使用 clean 指令前，務必先執行檢查參數 -n ，確認無誤再做移除之動作。","categories":[{"name":"版控","slug":"版控","permalink":"https://tsaiyuyan.github.io/categories/%E7%89%88%E6%8E%A7/"}],"tags":[{"name":"git","slug":"git","permalink":"https://tsaiyuyan.github.io/tags/git/"},{"name":"clean","slug":"clean","permalink":"https://tsaiyuyan.github.io/tags/clean/"}]},{"title":"C++ 中文unicode在終端機而且卡住解決方法","slug":"C++ 中文unicode在終端機而且卡住解決方法","date":"2018-02-13T10:00:00.000Z","updated":"2020-09-28T07:48:51.800Z","comments":true,"path":"2018/02/13/c-zhong-wen-unicode-zai-zhong-duan-ji-er-qie-qia-zhu-jie-jue-fang-fa/","link":"","permalink":"https://tsaiyuyan.github.io/2018/02/13/c-zhong-wen-unicode-zai-zhong-duan-ji-er-qie-qia-zhu-jie-jue-fang-fa/","excerpt":"","text":"1.環境 使用 VS2017 測試，實際上只要有支援到 std:locale 的編譯器即可(基本上都有支援) 再來專案設置使用unicode開發 //project-&gt;General-&gt;Character Set = &gt; “Use Unicode Character Set” 2. 程式碼//main.cpp #include &lt;iostream> using namespace std; //project->General->Character Set = > \"Use Unicode Character Set\" int main (int argc,char *argv[]) { locale::global(locale(\"\")); wcout.imbue(locale(\"\")); wcout &lt;&lt; L\"wcout &lt;&lt; abcdefg\" &lt;&lt; endl; wcout &lt;&lt; L\"wcout &lt;&lt; 測試中文:一二三四\" &lt;&lt; endl; //使用完畢時要呼叫下面兩行 ,才不會有 memory leak問題 &lt;===重要 locale::global(locale(\"C\")); wcout.imbue(locale(\"C\")); //===== 無使用 std::locale 會發生終端機打印時卡住 wcout &lt;&lt; L\"wcout &lt;&lt; abcdefg\" &lt;&lt; endl; wcout &lt;&lt; L\"wcout &lt;&lt; 測試中文:一二三四\" &lt;&lt; endl; //\"測試中文:一二三四\" can't printf int x; cin >> x; return 0; } 3.Outputwcout < abcdefg wcout < 測試中文:一二三四 wcout < abcdefg wcout","categories":[{"name":"C/C++","slug":"C-C","permalink":"https://tsaiyuyan.github.io/categories/C-C/"}],"tags":[{"name":"std::locale","slug":"std-locale","permalink":"https://tsaiyuyan.github.io/tags/std-locale/"}]},{"title":"Ubuntu加入新的帳戶","slug":"Linux/Ubuntu 加入新的帳戶","date":"2018-02-13T07:10:00.000Z","updated":"2020-05-11T07:35:19.162Z","comments":true,"path":"2018/02/13/linux/ubuntu-jia-ru-xin-de-zhang-hu/","link":"","permalink":"https://tsaiyuyan.github.io/2018/02/13/linux/ubuntu-jia-ru-xin-de-zhang-hu/","excerpt":"","text":"原本目的:以前開 AWS 會拿到一組金鑰，但每次都用鑰匙 ssh 登入連線實在很不方便。 1.Ubuntu 加入新的帳戶 (tsaiyuyan 為例)$sudo adduser tsaiyuyan 2.(可選) 可加入 sudo group$sudo adduser &lt;username> sudo ===>&lt;username> 這邊示範是 tsaiyuyan 3.開始設定屬性$sudo visudo 會有一個檔案 tsaiyuyan ALL=(ALL) ALL 加入此參數 ctrl +x 離開 ->問說是否Save ->選擇yes ->會跑出一些啥其他的命令，直接按Enter就可以了不用管 $sudo vim /etc/ssh/sshd_config (PasswordAuthentication)打開以後，找到這一行！ 將它改成yes! 接著儲存離開！ 然後就重開 ssh，指令如下： $sudo /etc/init.d/ssh restart 完成以後，你就能使用帳號、密碼登入了！不用每次都要附上 Key 這麼麻煩！！！如果還是不能登入，就使用重新開機在嘗試。 $shutdown -r now","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"}]},{"title":"Ubuntu工具tmux","slug":"Linux/Ubuntu 工具 tmux","date":"2018-02-13T07:06:00.000Z","updated":"2020-05-11T07:35:19.168Z","comments":true,"path":"2018/02/13/linux/ubuntu-gong-ju-tmux/","link":"","permalink":"https://tsaiyuyan.github.io/2018/02/13/linux/ubuntu-gong-ju-tmux/","excerpt":"","text":"0.功能簡述這個工具可以將終端機切成好幾個 bash 來使用，就可以不用一直多開終端機或是 putty 連線，導致視窗過多時找不到想看的終端機。 1.安裝$sudo apt-get tmux 2.開始使用$tmux 3.操作筆記(官方)常用 tmux ls 列出所有未關閉的 bash; tmux a -t N 移動到未關閉的 bash N; Ctrl + b + % 分割畫面(水平); Ctrl + b + space 分割畫面(垂直); Ctrl + b + 數字 切換到指定的數字畫面; Ctrl + b + c 建立新的視窗；(增加一個新bash) Ctrl + b + d 卸載目前的 client；(跳出目前 的tmux Ctrl + d = exit 目前的bash exit Ctrl + b + l 與先前選擇的視窗間切換； Ctrl + b + n 移動到下個視窗； Ctrl + b + p 移動到上個視窗； Ctrl + b + & 刪除目前的視窗； Ctrl + b + , 重新命名目前的視窗； Ctrl + b + % 將目前的視窗分離到兩個區塊； Ctrl + b + q 顯示各分割區塊的號碼（用來切換到不同的區塊） Ctrl + b + o 切換到下個區塊； Ctrl + b + ? 列出所有快捷鍵的說明； Ctrl + b + w 列出目前 clinet 的視窗，可以用數字鍵切換；","categories":[{"name":"Linux","slug":"Linux","permalink":"https://tsaiyuyan.github.io/categories/Linux/"}],"tags":[{"name":"ubuntu","slug":"ubuntu","permalink":"https://tsaiyuyan.github.io/tags/ubuntu/"},{"name":"tools","slug":"tools","permalink":"https://tsaiyuyan.github.io/tags/tools/"}]},{"title":"VC++ How to Detect if I'm Compiling Code With Visual Studio Version?","slug":"Windows/VC++ How to Detect if Im Compiling Code With Visual Studio Version","date":"2018-02-12T09:57:00.000Z","updated":"2020-05-11T07:35:19.215Z","comments":true,"path":"2018/02/12/windows/vc-how-to-detect-if-im-compiling-code-with-visual-studio-version/","link":"","permalink":"https://tsaiyuyan.github.io/2018/02/12/windows/vc-how-to-detect-if-im-compiling-code-with-visual-studio-version/","excerpt":"","text":"版本對照代碼MSVC++ 14.1 _MSC_VER == 1912 (Visual Studio 2017) MSVC++ 14.1 _MSC_VER == 1911 (Visual Studio 2017) MSVC++ 14.1 _MSC_VER == 1910 (Visual Studio 2017) MSVC++ 14.0 _MSC_VER == 1900 (Visual Studio 2015) MSVC++ 12.0 _MSC_VER == 1800 (Visual Studio 2013) MSVC++ 11.0 _MSC_VER == 1700 (Visual Studio 2012) MSVC++ 10.0 _MSC_VER == 1600 (Visual Studio 2010) MSVC++ 9.0 _MSC_FULL_VER == 150030729 (Visual Studio 2008, SP1) MSVC++ 9.0 _MSC_VER == 1500 (Visual Studio 2008) MSVC++ 8.0 _MSC_VER == 1400 (Visual Studio 2005) MSVC++ 7.1 _MSC_VER == 1310 (Visual Studio 2003) MSVC++ 7.0 _MSC_VER == 1300 MSVC++ 6.0 _MSC_VER == 1200 MSVC++ 5.0 _MSC_VER == 1100使用範例#if _MSC_VER &gt;= 1900 // … vs2015(含)以上的版本 #elif _MSC_VER &gt;= 1800 // … vs2013(含)以上的版本 #else // …其他版本 #endif參考網站 How to Detect if I’m Compiling Code With Visual Studio 2008? Pre-defined Compiler Macros Visual C++ Team Blog/Visual C++ Compiler Version123","categories":[{"name":"Windows","slug":"Windows","permalink":"https://tsaiyuyan.github.io/categories/Windows/"}],"tags":[{"name":"visual-studio","slug":"visual-studio","permalink":"https://tsaiyuyan.github.io/tags/visual-studio/"}]},{"title":"Hello World","slug":"Hexo/Hexo hello-world","date":"2016-12-31T16:00:00.000Z","updated":"2021-10-18T05:35:53.933Z","comments":true,"path":"2017/01/01/hexo/hexo-hello-world/","link":"","permalink":"https://tsaiyuyan.github.io/2017/01/01/hexo/hexo-hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new \"My New Post\" More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://tsaiyuyan.github.io/categories/Hexo/"}],"tags":[]}]}